var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = typeof require !== "undefined" ? require : (x) => {
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
import http from "http";
import https from "https";
import zlib from "zlib";
import Stream, { PassThrough, pipeline } from "stream";
import { types } from "util";
import { randomBytes } from "crypto";
import { format } from "url";
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof Stream)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    if (error2 instanceof FetchBaseError) {
      throw error2;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve3, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve3(response2);
      return;
    }
    const send2 = (options2.protocol === "https:" ? https : http).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof Stream.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send2(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error2) {
                reject(error2);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve3(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = pipeline(response_, new PassThrough(), (error2) => {
        reject(error2);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pipeline(body, zlib.createGunzip(zlibOptions), (error2) => {
          reject(error2);
        });
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pipeline(response_, new PassThrough(), (error2) => {
          reject(error2);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pipeline(body, zlib.createInflate(), (error2) => {
              reject(error2);
            });
          } else {
            body = pipeline(body, zlib.createInflateRaw(), (error2) => {
              reject(error2);
            });
          }
          response = new Response(body, responseOptions);
          resolve3(response);
        });
        return;
      }
      if (codings === "br") {
        body = pipeline(body, zlib.createBrotliDecompress(), (error2) => {
          reject(error2);
        });
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve3(response);
    });
    writeToStream(request_, request);
  });
}
var src, dataUriToBuffer$1, Readable, wm, Blob, fetchBlob, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ({ Readable } = Stream);
    wm = new WeakMap();
    Blob = class {
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob;
    Blob$1 = fetchBlob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => randomBytes(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = Stream.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof Stream) {
          body.on("error", (err) => {
            const error2 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough({ highWaterMark });
        p2 = new PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof Stream) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name of this.keys()) {
          callback(this.get(name), name);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status || 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-node/files/shims.js
import { createRequire } from "module";
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-node/files/shims.js"() {
    init_install_fetch();
    Object.defineProperty(globalThis, "require", {
      enumerable: true,
      value: createRequire(import.meta.url)
    });
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    init_shims();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    init_shims();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        module.exports = _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      } else {
        module.exports = _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      }
      return _typeof(obj);
    }
    module.exports = _typeof;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireWildcard.js
var require_interopRequireWildcard = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireWildcard.js"(exports, module) {
    init_shims();
    var _typeof = require_typeof()["default"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    module.exports = _interopRequireWildcard;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    init_shims();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    module.exports = _arrayLikeToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    init_shims();
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return arrayLikeToArray(arr);
    }
    module.exports = _arrayWithoutHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    init_shims();
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module.exports = _iterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    init_shims();
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray(o, minLen);
    }
    module.exports = _unsupportedIterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    init_shims();
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    init_shims();
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module.exports = _toConsumableArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    init_shims();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
    init_shims();
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
    init_shims();
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    module.exports = _iterableToArrayLimit;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
    init_shims();
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
    init_shims();
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    module.exports = _slicedToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    init_shims();
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
    init_shims();
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    module.exports = _isNativeReflectConstruct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module) {
    init_shims();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        module.exports = _construct = Reflect.construct;
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      } else {
        module.exports = _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    init_shims();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    init_shims();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    module.exports = _createClass;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    init_shims();
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    init_shims();
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module.exports = _possibleConstructorReturn;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    init_shims();
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    init_shims();
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module.exports = _inherits;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    init_shims();
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define2(Gp, "constructor", GeneratorFunctionPrototype);
      define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve3, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve3, reject);
              }, function(err) {
                invoke("throw", err, resolve3, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve3(result);
            }, function(error2) {
              return invoke("throw", error2, resolve3, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve3, reject) {
              invoke(method, arg, resolve3, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(typeof module === "object" ? module.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    init_shims();
    module.exports = require_runtime();
  }
});

// node_modules/@jimp/utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/@jimp/utils/dist/index.js"(exports) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isNodePattern = isNodePattern;
    exports.throwError = throwError;
    exports.scan = scan;
    exports.scanIterator = scanIterator;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _marked = /* @__PURE__ */ _regenerator["default"].mark(scanIterator);
    function isNodePattern(cb) {
      if (typeof cb === "undefined") {
        return false;
      }
      if (typeof cb !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return true;
    }
    function throwError(error2, cb) {
      if (typeof error2 === "string") {
        error2 = new Error(error2);
      }
      if (typeof cb === "function") {
        return cb.call(this, error2);
      }
      throw error2;
    }
    function scan(image2, x, y, w, h, f) {
      x = Math.round(x);
      y = Math.round(y);
      w = Math.round(w);
      h = Math.round(h);
      for (var _y = y; _y < y + h; _y++) {
        for (var _x = x; _x < x + w; _x++) {
          var idx = image2.bitmap.width * _y + _x << 2;
          f.call(image2, _x, _y, idx);
        }
      }
      return image2;
    }
    function scanIterator(image2, x, y, w, h) {
      var _y, _x, idx;
      return _regenerator["default"].wrap(function scanIterator$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              x = Math.round(x);
              y = Math.round(y);
              w = Math.round(w);
              h = Math.round(h);
              _y = y;
            case 5:
              if (!(_y < y + h)) {
                _context.next = 17;
                break;
              }
              _x = x;
            case 7:
              if (!(_x < x + w)) {
                _context.next = 14;
                break;
              }
              idx = image2.bitmap.width * _y + _x << 2;
              _context.next = 11;
              return {
                x: _x,
                y: _y,
                idx,
                image: image2
              };
            case 11:
              _x++;
              _context.next = 7;
              break;
            case 14:
              _y++;
              _context.next = 5;
              break;
            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _marked);
    }
  }
});

// node_modules/any-base/src/converter.js
var require_converter = __commonJS({
  "node_modules/any-base/src/converter.js"(exports, module) {
    init_shims();
    "use strict";
    function Converter(srcAlphabet, dstAlphabet) {
      if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error("Bad alphabet");
      }
      this.srcAlphabet = srcAlphabet;
      this.dstAlphabet = dstAlphabet;
    }
    Converter.prototype.convert = function(number) {
      var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
      if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
      }
      if (this.srcAlphabet === this.dstAlphabet) {
        return number;
      }
      for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
      }
      do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
          divide = divide * fromBase + numberMap[i];
          if (divide >= toBase) {
            numberMap[newlen++] = parseInt(divide / toBase, 10);
            divide = divide % toBase;
          } else if (newlen > 0) {
            numberMap[newlen++] = 0;
          }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
      } while (newlen !== 0);
      return result;
    };
    Converter.prototype.isValid = function(number) {
      var i = 0;
      for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
          return false;
        }
      }
      return true;
    };
    module.exports = Converter;
  }
});

// node_modules/any-base/index.js
var require_any_base = __commonJS({
  "node_modules/any-base/index.js"(exports, module) {
    init_shims();
    var Converter = require_converter();
    function anyBase(srcAlphabet, dstAlphabet) {
      var converter = new Converter(srcAlphabet, dstAlphabet);
      return function(number) {
        return converter.convert(number);
      };
    }
    anyBase.BIN = "01";
    anyBase.OCT = "01234567";
    anyBase.DEC = "0123456789";
    anyBase.HEX = "0123456789abcdef";
    module.exports = anyBase;
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports, module) {
    init_shims();
    var path2 = __require("path");
    var fs3 = __require("fs");
    var _0777 = parseInt("0777", 8);
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs3;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path2.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path2.dirname(p) === p)
              return cb(er);
            mkdirP(path2.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs3;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path2.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path2.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/pixelmatch/index.js
var require_pixelmatch = __commonJS({
  "node_modules/pixelmatch/index.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = pixelmatch;
    function pixelmatch(img1, img2, output, width, height, options2) {
      if (!options2)
        options2 = {};
      var threshold = options2.threshold === void 0 ? 0.1 : options2.threshold;
      var maxDelta = 35215 * threshold * threshold, diff = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var pos = (y * width + x) * 4;
          var delta = colorDelta(img1, img2, pos, pos);
          if (delta > maxDelta) {
            if (!options2.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
              if (output)
                drawPixel(output, pos, 255, 255, 0);
            } else {
              if (output)
                drawPixel(output, pos, 255, 0, 0);
              diff++;
            }
          } else if (output) {
            var val = blend(grayPixel(img1, pos), 0.1);
            drawPixel(output, pos, val, val, val);
          }
        }
      }
      return diff;
    }
    function antialiased(img, x1, y1, width, height, img2) {
      var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, minX, minY, maxX, maxY;
      for (var x = x0; x <= x2; x++) {
        for (var y = y0; y <= y2; y++) {
          if (x === x1 && y === y1)
            continue;
          var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
          if (delta === 0)
            zeroes++;
          else if (delta < 0)
            negatives++;
          else if (delta > 0)
            positives++;
          if (zeroes > 2)
            return false;
          if (!img2)
            continue;
          if (delta < min) {
            min = delta;
            minX = x;
            minY = y;
          }
          if (delta > max) {
            max = delta;
            maxX = x;
            maxY = y;
          }
        }
      }
      if (!img2)
        return true;
      if (negatives === 0 || positives === 0)
        return false;
      return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);
    }
    function colorDelta(img1, img2, k, m, yOnly) {
      var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
      if (yOnly)
        return y;
      var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
      return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
    }
    function rgb2y(r, g, b) {
      return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
    }
    function rgb2i(r, g, b) {
      return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
    }
    function rgb2q(r, g, b) {
      return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
    }
    function blend(c, a) {
      return 255 + (c - 255) * a;
    }
    function drawPixel(output, pos, r, g, b) {
      output[pos + 0] = r;
      output[pos + 1] = g;
      output[pos + 2] = b;
      output[pos + 3] = 255;
    }
    function grayPixel(img, i) {
      var a = img[i + 3] / 255, r = blend(img[i + 0], a), g = blend(img[i + 1], a), b = blend(img[i + 2], a);
      return rgb2y(r, g, b);
    }
  }
});

// node_modules/tinycolor2/tinycolor.js
var require_tinycolor = __commonJS({
  "node_modules/tinycolor2/tinycolor.js"(exports, module) {
    init_shims();
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor(color, opts) {
        color = color ? color : "";
        opts = opts || {};
        if (color instanceof tinycolor) {
          return color;
        }
        if (!(this instanceof tinycolor)) {
          return new tinycolor(color, opts);
        }
        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb.r / 255;
          GsRGB = rgb.g / 255;
          BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B = BsRGB / 12.92;
          } else {
            B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s2 + "%, " + v + "%)" : "hsva(" + h + ", " + s2 + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          var h = mathRound(hsl.h * 360), s2 = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s2 + "%, " + l + "%)" : "hsla(" + h + ", " + s2 + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s2 = tinycolor(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format2) {
          var formatSet = !!format2;
          format2 = format2 || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor(this.toString());
        },
        _applyModification: function(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color._r;
          this._g = color._g;
          this._b = color._b;
          this.setAlpha(color._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor.fromRatio = function(color, opts) {
        if (typeof color == "object") {
          var newColor = {};
          for (var i in color) {
            if (color.hasOwnProperty(i)) {
              if (i === "a") {
                newColor[i] = color[i];
              } else {
                newColor[i] = convertToPercentage(color[i]);
              }
            }
          }
          color = newColor;
        }
        return tinycolor(color, opts);
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s2 = null;
        var v = null;
        var l = null;
        var ok = false;
        var format2 = false;
        if (typeof color == "string") {
          color = stringInputToObject(color);
        }
        if (typeof color == "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l);
            ok = true;
            format2 = "hsl";
          }
          if (color.hasOwnProperty("a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format2,
          r: mathMin(255, mathMax(rgb.r, 0)),
          g: mathMin(255, mathMax(rgb.g, 0)),
          b: mathMin(255, mathMax(rgb.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s2, l = (max + min) / 2;
        if (max == min) {
          h = s2 = 0;
        } else {
          var d2 = max - min;
          s2 = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d2 + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d2 + 2;
              break;
            case b:
              h = (r - g) / d2 + 4;
              break;
          }
          h /= 6;
        }
        return { h, s: s2, l };
      }
      function hslToRgb(h, s2, l) {
        var r, g, b;
        h = bound01(h, 360);
        s2 = bound01(s2, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        if (s2 === 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s2, v = max;
        var d2 = max - min;
        s2 = max === 0 ? 0 : d2 / max;
        if (max == min) {
          h = 0;
        } else {
          switch (max) {
            case r:
              h = (g - b) / d2 + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d2 + 2;
              break;
            case b:
              h = (r - g) / d2 + 4;
              break;
          }
          h /= 6;
        }
        return { h, s: s2, v };
      }
      function hsvToRgb(h, s2, v) {
        h = bound01(h, 360) * 6;
        s2 = bound01(s2, 100);
        v = bound01(v, 100);
        var i = Math2.floor(h), f = h - i, p = v * (1 - s2), q = v * (1 - f * s2), t = v * (1 - (1 - f) * s2), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToArgbHex(r, g, b, a) {
        var hex = [
          pad2(convertDecimalToHex(a)),
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        return hex.join("");
      }
      tinycolor.equals = function(color1, color2) {
        if (!color1 || !color2) {
          return false;
        }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
      };
      tinycolor.random = function() {
        return tinycolor.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
      }
      function saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
      }
      function greyscale(color) {
        return tinycolor(color).desaturate(100);
      }
      function lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
      }
      function brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
        return tinycolor(rgb);
      }
      function darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
      }
      function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
      }
      function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
      }
      function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor(color),
          tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor(color),
          tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor(color),
          tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(tinycolor(hsl));
        }
        return ret;
      }
      function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s2 = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor({ h, s: s2, v }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor(rgba);
      };
      tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;
        for (var i = 0; i < colorList.length; i++) {
          readability = tinycolor.readability(baseColor, colorList[i]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
          }
        }
        if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor.hexNames = flip(names);
      function flip(o) {
        var flipped = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
          }
        }
        return flipped;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));
        if (processPercent) {
          n = parseInt(n * max, 10) / 100;
        }
        if (Math2.abs(n - max) < 1e-6) {
          return 1;
        }
        return n % max / parseFloat(max);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          n = n * 100 + "%";
        }
        return n;
      }
      function convertDecimalToHex(d2) {
        return Math2.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
      }
      function stringInputToObject(color) {
        color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match;
        if (match = matchers.rgb.exec(color)) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color)) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color)) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color)) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color)) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color)) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size !== "small" && size !== "large") {
          size = "small";
        }
        return { "level": level, "size": size };
      }
      if (typeof module !== "undefined" && module.exports) {
        module.exports = tinycolor;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return tinycolor;
        });
      } else {
        window.tinycolor = tinycolor;
      }
    })(Math);
  }
});

// node_modules/@jimp/core/dist/modules/phash.js
var require_phash = __commonJS({
  "node_modules/@jimp/core/dist/modules/phash.js"(exports, module) {
    init_shims();
    "use strict";
    function ImagePHash(size, smallerSize) {
      this.size = this.size || size;
      this.smallerSize = this.smallerSize || smallerSize;
      initCoefficients(this.size);
    }
    ImagePHash.prototype.size = 32;
    ImagePHash.prototype.smallerSize = 8;
    ImagePHash.prototype.distance = function(s1, s2) {
      var counter = 0;
      for (var k = 0; k < s1.length; k++) {
        if (s1[k] !== s2[k]) {
          counter++;
        }
      }
      return counter / s1.length;
    };
    ImagePHash.prototype.getHash = function(img) {
      img = img.clone().resize(this.size, this.size);
      img.grayscale();
      var vals = [];
      for (var x = 0; x < img.bitmap.width; x++) {
        vals[x] = [];
        for (var y = 0; y < img.bitmap.height; y++) {
          vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
        }
      }
      var dctVals = applyDCT(vals, this.size);
      var total = 0;
      for (var _x = 0; _x < this.smallerSize; _x++) {
        for (var _y = 0; _y < this.smallerSize; _y++) {
          total += dctVals[_x][_y];
        }
      }
      var avg = total / (this.smallerSize * this.smallerSize);
      var hash2 = "";
      for (var _x2 = 0; _x2 < this.smallerSize; _x2++) {
        for (var _y2 = 0; _y2 < this.smallerSize; _y2++) {
          hash2 += dctVals[_x2][_y2] > avg ? "1" : "0";
        }
      }
      return hash2;
    };
    function intToRGBA(i) {
      var rgba = {};
      rgba.r = Math.floor(i / Math.pow(256, 3));
      rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
      rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
      rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
      return rgba;
    }
    var c = [];
    function initCoefficients(size) {
      for (var i = 1; i < size; i++) {
        c[i] = 1;
      }
      c[0] = 1 / Math.sqrt(2);
    }
    function applyDCT(f, size) {
      var N = size;
      var F = [];
      for (var u = 0; u < N; u++) {
        F[u] = [];
        for (var v = 0; v < N; v++) {
          var sum = 0;
          for (var i = 0; i < N; i++) {
            for (var j = 0; j < N; j++) {
              sum += Math.cos((2 * i + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i][j];
            }
          }
          sum *= c[u] * c[v] / 4;
          F[u][v] = sum;
        }
      }
      return F;
    }
    module.exports = ImagePHash;
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    init_shims();
    function _extends() {
      module.exports = _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/phin/lib/phin.compiled.js
var require_phin_compiled = __commonJS({
  "node_modules/phin/lib/phin.compiled.js"(exports, module) {
    init_shims();
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var http2 = __require("http");
    var https2 = __require("https");
    var url = __require("url");
    var qs2 = __require("querystring");
    var zlib2 = __require("zlib");
    var util = __require("util");
    var phin = function phin2(opts, cb) {
      if (typeof opts !== "string") {
        if (!opts.hasOwnProperty("url")) {
          throw new Error("Missing url option from options for request method.");
        }
      }
      var addr = (typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object" ? url.parse(opts.url) : url.parse(opts);
      var options2 = { "hostname": addr.hostname, "port": addr.port || (addr.protocol.toLowerCase() === "http:" ? 80 : 443), "path": addr.path, "method": "GET", "headers": {}, "auth": addr.auth || null, "parse": "none", "stream": false };
      if ((typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object") {
        options2 = Object.assign(options2, opts);
      }
      options2.port = Number(options2.port);
      if (options2.hasOwnProperty("timeout"))
        delete options2.timeout;
      if (options2.compressed === true) {
        options2.headers["accept-encoding"] = "gzip, deflate";
      }
      if (opts.hasOwnProperty("form")) {
        if (_typeof(opts.form) !== "object") {
          throw new Error("phin 'form' option must be of type Object if present.");
        }
        var formDataString = qs2.stringify(opts.form);
        options2.headers["Content-Type"] = "application/x-www-form-urlencoded";
        options2.headers["Content-Length"] = Buffer.byteLength(formDataString);
        opts.data = formDataString;
      }
      var req = void 0;
      var resHandler = function resHandler2(res) {
        var stream = res;
        if (options2.compressed === true) {
          if (res.headers["content-encoding"] === "gzip") {
            stream = res.pipe(zlib2.createGunzip());
          } else if (res.headers["content-encoding"] === "deflate") {
            stream = res.pipe(zlib2.createInflate());
          }
        }
        if (options2.stream === true) {
          res.stream = stream;
          if (cb)
            cb(null, res);
        } else {
          res.body = new Buffer([]);
          stream.on("data", function(chunk) {
            res.body = Buffer.concat([res.body, chunk]);
          });
          stream.on("end", function() {
            if (cb) {
              if (options2.parse === "json") {
                try {
                  res.body = JSON.parse(res.body.toString());
                } catch (err) {
                  cb("Invalid JSON received.", res);
                  return;
                }
              }
              cb(null, res);
            }
          });
        }
      };
      switch (addr.protocol.toLowerCase()) {
        case "http:":
          req = http2.request(options2, resHandler);
          break;
        case "https:":
          req = https2.request(options2, resHandler);
          break;
        default:
          if (cb)
            cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
          return;
      }
      if (typeof opts.timeout === "number") {
        req.setTimeout(opts.timeout, function() {
          req.abort();
          if (cb)
            cb(new Error("Timeout has been reached."), null);
          cb = null;
        });
      }
      req.on("error", function(err) {
        if (cb)
          cb(err, null);
      });
      if (opts.hasOwnProperty("data")) {
        var postData = opts.data;
        if (!(opts.data instanceof Buffer) && _typeof(opts.data) === "object") {
          var contentType = options2.headers["content-type"] || options2.headers["Content-Type"];
          if (contentType === "application/x-www-form-urlencoded") {
            postData = qs2.stringify(opts.data);
          } else {
            try {
              postData = JSON.stringify(opts.data);
            } catch (err) {
              if (cb)
                cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
            }
          }
        }
        req.write(postData);
      }
      req.end();
    };
    phin.promisified = function(opts, http3) {
      return new Promise(function(resolve3, reject) {
        phin(opts, function(err, res) {
          if (err) {
            reject(err);
          } else {
            resolve3(res);
          }
        }, http3);
      });
    };
    if (util.promisify) {
      phin[util.promisify.custom] = phin.promisified;
    }
    module.exports = phin;
  }
});

// node_modules/@jimp/core/dist/request.js
var require_request = __commonJS({
  "node_modules/@jimp/core/dist/request.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _extends2 = _interopRequireDefault(require_extends());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(source, true).forEach(function(key) {
            (0, _defineProperty2["default"])(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(source).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    if (process.browser || process.env.ENVIRONMENT === "BROWSER" || typeof process.versions.electron !== "undefined" && process.type === "renderer" && typeof XMLHttpRequest === "function") {
      module.exports = function(options2, cb) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", options2.url, true);
        xhr.responseType = "arraybuffer";
        xhr.addEventListener("load", function() {
          if (xhr.status < 400) {
            try {
              var data = Buffer.from(this.response);
              cb(null, xhr, data);
            } catch (error2) {
              return cb(new Error("Response is not a buffer for url " + options2.url + ". Error: " + error2.message));
            }
          } else {
            cb(new Error("HTTP Status " + xhr.status + " for url " + options2.url));
          }
        });
        xhr.addEventListener("error", function(e) {
          cb(e);
        });
        xhr.send();
      };
    } else {
      module.exports = function(_ref, cb) {
        var options2 = (0, _extends2["default"])({}, _ref);
        var p = require_phin_compiled();
        p(_objectSpread({
          compression: true
        }, options2), function(err, res) {
          if (err === null) {
            cb(null, res, res.body);
          } else {
            cb(err);
          }
        });
      };
    }
  }
});

// node_modules/@jimp/core/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@jimp/core/dist/constants.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EDGE_CROP = exports.EDGE_WRAP = exports.EDGE_EXTEND = exports.BLEND_EXCLUSION = exports.BLEND_DIFFERENCE = exports.BLEND_HARDLIGHT = exports.BLEND_LIGHTEN = exports.BLEND_DARKEN = exports.BLEND_OVERLAY = exports.BLEND_SCREEN = exports.BLEND_ADD = exports.BLEND_MULTIPLY = exports.BLEND_DESTINATION_OVER = exports.BLEND_SOURCE_OVER = exports.VERTICAL_ALIGN_BOTTOM = exports.VERTICAL_ALIGN_MIDDLE = exports.VERTICAL_ALIGN_TOP = exports.HORIZONTAL_ALIGN_RIGHT = exports.HORIZONTAL_ALIGN_CENTER = exports.HORIZONTAL_ALIGN_LEFT = exports.AUTO = void 0;
    var AUTO = -1;
    exports.AUTO = AUTO;
    var HORIZONTAL_ALIGN_LEFT = 1;
    exports.HORIZONTAL_ALIGN_LEFT = HORIZONTAL_ALIGN_LEFT;
    var HORIZONTAL_ALIGN_CENTER = 2;
    exports.HORIZONTAL_ALIGN_CENTER = HORIZONTAL_ALIGN_CENTER;
    var HORIZONTAL_ALIGN_RIGHT = 4;
    exports.HORIZONTAL_ALIGN_RIGHT = HORIZONTAL_ALIGN_RIGHT;
    var VERTICAL_ALIGN_TOP = 8;
    exports.VERTICAL_ALIGN_TOP = VERTICAL_ALIGN_TOP;
    var VERTICAL_ALIGN_MIDDLE = 16;
    exports.VERTICAL_ALIGN_MIDDLE = VERTICAL_ALIGN_MIDDLE;
    var VERTICAL_ALIGN_BOTTOM = 32;
    exports.VERTICAL_ALIGN_BOTTOM = VERTICAL_ALIGN_BOTTOM;
    var BLEND_SOURCE_OVER = "srcOver";
    exports.BLEND_SOURCE_OVER = BLEND_SOURCE_OVER;
    var BLEND_DESTINATION_OVER = "dstOver";
    exports.BLEND_DESTINATION_OVER = BLEND_DESTINATION_OVER;
    var BLEND_MULTIPLY = "multiply";
    exports.BLEND_MULTIPLY = BLEND_MULTIPLY;
    var BLEND_ADD = "add";
    exports.BLEND_ADD = BLEND_ADD;
    var BLEND_SCREEN = "screen";
    exports.BLEND_SCREEN = BLEND_SCREEN;
    var BLEND_OVERLAY = "overlay";
    exports.BLEND_OVERLAY = BLEND_OVERLAY;
    var BLEND_DARKEN = "darken";
    exports.BLEND_DARKEN = BLEND_DARKEN;
    var BLEND_LIGHTEN = "lighten";
    exports.BLEND_LIGHTEN = BLEND_LIGHTEN;
    var BLEND_HARDLIGHT = "hardLight";
    exports.BLEND_HARDLIGHT = BLEND_HARDLIGHT;
    var BLEND_DIFFERENCE = "difference";
    exports.BLEND_DIFFERENCE = BLEND_DIFFERENCE;
    var BLEND_EXCLUSION = "exclusion";
    exports.BLEND_EXCLUSION = BLEND_EXCLUSION;
    var EDGE_EXTEND = 1;
    exports.EDGE_EXTEND = EDGE_EXTEND;
    var EDGE_WRAP = 2;
    exports.EDGE_WRAP = EDGE_WRAP;
    var EDGE_CROP = 3;
    exports.EDGE_CROP = EDGE_CROP;
  }
});

// node_modules/@jimp/core/dist/composite/composite-modes.js
var require_composite_modes = __commonJS({
  "node_modules/@jimp/core/dist/composite/composite-modes.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.srcOver = srcOver;
    exports.dstOver = dstOver;
    exports.multiply = multiply;
    exports.add = add;
    exports.screen = screen;
    exports.overlay = overlay;
    exports.darken = darken;
    exports.lighten = lighten;
    exports.hardLight = hardLight;
    exports.difference = difference;
    exports.exclusion = exclusion;
    function srcOver(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var r = (src2.r * src2.a + dst.r * dst.a * (1 - src2.a)) / a;
      var g = (src2.g * src2.a + dst.g * dst.a * (1 - src2.a)) / a;
      var b = (src2.b * src2.a + dst.b * dst.a * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function dstOver(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var r = (dst.r * dst.a + src2.r * src2.a * (1 - dst.a)) / a;
      var g = (dst.g * dst.a + src2.g * src2.a * (1 - dst.a)) / a;
      var b = (dst.b * dst.a + src2.b * src2.a * (1 - dst.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function multiply(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
      var g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
      var b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function add(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (sra + dra) / a;
      var g = (sga + dga) / a;
      var b = (sba + dba) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function screen(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (sra * dst.a + dra * src2.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
      var g = (sga * dst.a + dga * src2.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
      var b = (sba * dst.a + dba * src2.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function overlay(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a) : sra * (1 + dst.a) + dra * (1 + src2.a) - 2 * dra * sra - dst.a * src2.a) / a;
      var g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a) : sga * (1 + dst.a) + dga * (1 + src2.a) - 2 * dga * sga - dst.a * src2.a) / a;
      var b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a) : sba * (1 + dst.a) + dba * (1 + src2.a) - 2 * dba * sba - dst.a * src2.a) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function darken(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (Math.min(sra * dst.a, dra * src2.a) + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
      var g = (Math.min(sga * dst.a, dga * src2.a) + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
      var b = (Math.min(sba * dst.a, dba * src2.a) + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function lighten(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (Math.max(sra * dst.a, dra * src2.a) + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
      var g = (Math.max(sga * dst.a, dga * src2.a) + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
      var b = (Math.max(sba * dst.a, dba * src2.a) + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function hardLight(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (2 * sra <= src2.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a) : sra * (1 + dst.a) + dra * (1 + src2.a) - 2 * dra * sra - dst.a * src2.a) / a;
      var g = (2 * sga <= src2.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a) : sga * (1 + dst.a) + dga * (1 + src2.a) - 2 * dga * sga - dst.a * src2.a) / a;
      var b = (2 * sba <= src2.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a) : sba * (1 + dst.a) + dba * (1 + src2.a) - 2 * dba * sba - dst.a * src2.a) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function difference(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src2.a)) / a;
      var g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src2.a)) / a;
      var b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function exclusion(src2, dst) {
      var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src2.a *= ops;
      var a = dst.a + src2.a - dst.a * src2.a;
      var sra = src2.r * src2.a;
      var sga = src2.g * src2.a;
      var sba = src2.b * src2.a;
      var dra = dst.r * dst.a;
      var dga = dst.g * dst.a;
      var dba = dst.b * dst.a;
      var r = (sra * dst.a + dra * src2.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
      var g = (sga * dst.a + dga * src2.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
      var b = (sba * dst.a + dba * src2.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
  }
});

// node_modules/@jimp/core/dist/composite/index.js
var require_composite = __commonJS({
  "node_modules/@jimp/core/dist/composite/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = composite;
    var _utils = require_dist();
    var constants = _interopRequireWildcard(require_constants());
    var compositeModes = _interopRequireWildcard(require_composite_modes());
    function composite(src2, x, y) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var cb = arguments.length > 4 ? arguments[4] : void 0;
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!(src2 instanceof this.constructor)) {
        return _utils.throwError.call(this, "The source must be a Jimp image", cb);
      }
      if (typeof x !== "number" || typeof y !== "number") {
        return _utils.throwError.call(this, "x and y must be numbers", cb);
      }
      var _options = options2, mode = _options.mode, opacitySource = _options.opacitySource, opacityDest = _options.opacityDest;
      if (!mode) {
        mode = constants.BLEND_SOURCE_OVER;
      }
      if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
        opacitySource = 1;
      }
      if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
        opacityDest = 1;
      }
      var blendmode = compositeModes[mode];
      x = Math.round(x);
      y = Math.round(y);
      var baseImage = this;
      if (opacityDest !== 1) {
        baseImage.opacity(opacityDest);
      }
      src2.scanQuiet(0, 0, src2.bitmap.width, src2.bitmap.height, function(sx, sy, idx) {
        var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);
        var blended = blendmode({
          r: this.bitmap.data[idx + 0] / 255,
          g: this.bitmap.data[idx + 1] / 255,
          b: this.bitmap.data[idx + 2] / 255,
          a: this.bitmap.data[idx + 3] / 255
        }, {
          r: baseImage.bitmap.data[dstIdx + 0] / 255,
          g: baseImage.bitmap.data[dstIdx + 1] / 255,
          b: baseImage.bitmap.data[dstIdx + 2] / 255,
          a: baseImage.bitmap.data[dstIdx + 3] / 255
        }, opacitySource);
        baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
        baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
        baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    module.exports = exports.default;
  }
});

// node_modules/@jimp/core/dist/utils/promisify.js
var require_promisify = __commonJS({
  "node_modules/@jimp/core/dist/utils/promisify.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var promisify = function promisify2(fun, ctx) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return new Promise(function(resolve3, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          }
          resolve3(data);
        });
        fun.bind(ctx).apply(void 0, args);
      });
    };
    var _default = promisify;
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/core/dist/utils/mime.js
var require_mime = __commonJS({
  "node_modules/@jimp/core/dist/utils/mime.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getExtension = exports.getType = exports.addType = void 0;
    var mimeTypes = {};
    var findType = function findType2(extension) {
      return Object.entries(mimeTypes).find(function(type) {
        return type[1].includes(extension);
      }) || [];
    };
    var addType = function addType2(mime, extensions) {
      mimeTypes[mime] = extensions;
    };
    exports.addType = addType;
    var getType2 = function getType3(path2) {
      var pathParts = path2.split("/").slice(-1);
      var extension = pathParts[pathParts.length - 1].split(".").pop();
      var type = findType(extension);
      return type[0];
    };
    exports.getType = getType2;
    var getExtension = function getExtension2(type) {
      return (mimeTypes[type.toLowerCase()] || [])[0];
    };
    exports.getExtension = getExtension;
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports, module) {
    init_shims();
    "use strict";
    var toBytes = (s2) => [...s2].map((c) => c.charCodeAt(0));
    var xpiZipFilename = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes = toBytes("[Content_Types].xml");
    var oxmlRels = toBytes("_rels/.rels");
    module.exports = (input) => {
      const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, options2) => {
        options2 = Object.assign({
          offset: 0
        }, options2);
        for (let i = 0; i < header.length; i++) {
          if (options2.mask) {
            if (header[i] !== (options2.mask[i] & buf[i + options2.offset])) {
              return false;
            }
          } else if (header[i] !== buf[i + options2.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options2) => check(toBytes(header), options2);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr2) => i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
        let zipHeaderIndex = 0;
        let oxmlFound = false;
        let type = null;
        do {
          const offset = zipHeaderIndex + 30;
          if (!oxmlFound) {
            oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
          }
          if (!type) {
            if (checkString("word/", { offset })) {
              type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            } else if (checkString("ppt/", { offset })) {
              type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            } else if (checkString("xl/", { offset })) {
              type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
          }
          if (oxmlFound && type) {
            return type;
          }
          zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
        } while (zipHeaderIndex >= 0);
        if (type) {
          return type;
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || check([109, 112, 52, 50], { offset: 8 }) || check([105, 115, 111, 109], { offset: 8 }) || check([105, 115, 111, 50], { offset: 8 }) || check([109, 109, 112, 52], { offset: 8 }) || check([77, 52, 86], { offset: 8 }) || check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 51, 103], { offset: 4 })) {
        return {
          ext: "3gp",
          mime: "video/3gpp"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 228] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/mp4"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([119, 118, 112, 107])) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77, 0])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 })) {
        if (check([109, 105, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif"
          };
        }
        if (check([109, 115, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif-sequence"
          };
        }
        if (check([104, 101, 105, 99], { offset: 8 }) || check([104, 101, 105, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic"
          };
        }
        if (check([104, 101, 118, 99], { offset: 8 }) || check([104, 101, 118, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic-sequence"
          };
        }
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      return null;
    };
  }
});

// node_modules/exif-parser/lib/jpeg.js
var require_jpeg = __commonJS({
  "node_modules/exif-parser/lib/jpeg.js"(exports, module) {
    init_shims();
    module.exports = {
      parseSections: function(stream, iterator) {
        var len, markerType;
        stream.setBigEndian(true);
        while (stream.remainingLength() > 0 && markerType !== 218) {
          if (stream.nextUInt8() !== 255) {
            throw new Error("Invalid JPEG section offset");
          }
          markerType = stream.nextUInt8();
          if (markerType >= 208 && markerType <= 217 || markerType === 218) {
            len = 0;
          } else {
            len = stream.nextUInt16() - 2;
          }
          iterator(markerType, stream.branch(0, len));
          stream.skip(len);
        }
      },
      getSizeFromSOFSection: function(stream) {
        stream.skip(1);
        return {
          height: stream.nextUInt16(),
          width: stream.nextUInt16()
        };
      },
      getSectionName: function(markerType) {
        var name, index2;
        switch (markerType) {
          case 216:
            name = "SOI";
            break;
          case 196:
            name = "DHT";
            break;
          case 219:
            name = "DQT";
            break;
          case 221:
            name = "DRI";
            break;
          case 218:
            name = "SOS";
            break;
          case 254:
            name = "COM";
            break;
          case 217:
            name = "EOI";
            break;
          default:
            if (markerType >= 224 && markerType <= 239) {
              name = "APP";
              index2 = markerType - 224;
            } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
              name = "SOF";
              index2 = markerType - 192;
            } else if (markerType >= 208 && markerType <= 215) {
              name = "RST";
              index2 = markerType - 208;
            }
            break;
        }
        var nameStruct = {
          name
        };
        if (typeof index2 === "number") {
          nameStruct.index = index2;
        }
        return nameStruct;
      }
    };
  }
});

// node_modules/exif-parser/lib/exif.js
var require_exif = __commonJS({
  "node_modules/exif-parser/lib/exif.js"(exports, module) {
    init_shims();
    function readExifValue(format2, stream) {
      switch (format2) {
        case 1:
          return stream.nextUInt8();
        case 3:
          return stream.nextUInt16();
        case 4:
          return stream.nextUInt32();
        case 5:
          return [stream.nextUInt32(), stream.nextUInt32()];
        case 6:
          return stream.nextInt8();
        case 8:
          return stream.nextUInt16();
        case 9:
          return stream.nextUInt32();
        case 10:
          return [stream.nextInt32(), stream.nextInt32()];
        case 11:
          return stream.nextFloat();
        case 12:
          return stream.nextDouble();
        default:
          throw new Error("Invalid format while decoding: " + format2);
      }
    }
    function getBytesPerComponent(format2) {
      switch (format2) {
        case 1:
        case 2:
        case 6:
        case 7:
          return 1;
        case 3:
        case 8:
          return 2;
        case 4:
        case 9:
        case 11:
          return 4;
        case 5:
        case 10:
        case 12:
          return 8;
        default:
          return 0;
      }
    }
    function readExifTag(tiffMarker, stream) {
      var tagType = stream.nextUInt16(), format2 = stream.nextUInt16(), bytesPerComponent = getBytesPerComponent(format2), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components, values, value, c;
      if (valueBytes > 4) {
        stream = tiffMarker.openWithOffset(stream.nextUInt32());
      }
      if (format2 === 2) {
        values = stream.nextString(components);
        var lastNull = values.indexOf("\0");
        if (lastNull !== -1) {
          values = values.substr(0, lastNull);
        }
      } else if (format2 === 7) {
        values = stream.nextBuffer(components);
      } else if (format2 !== 0) {
        values = [];
        for (c = 0; c < components; ++c) {
          values.push(readExifValue(format2, stream));
        }
      }
      if (valueBytes < 4) {
        stream.skip(4 - valueBytes);
      }
      return [tagType, values, format2];
    }
    function readIFDSection(tiffMarker, stream, iterator) {
      var numberOfEntries = stream.nextUInt16(), tag, i;
      for (i = 0; i < numberOfEntries; ++i) {
        tag = readExifTag(tiffMarker, stream);
        iterator(tag[0], tag[1], tag[2]);
      }
    }
    function readHeader(stream) {
      var exifHeader = stream.nextString(6);
      if (exifHeader !== "Exif\0\0") {
        throw new Error("Invalid EXIF header");
      }
      var tiffMarker = stream.mark();
      var tiffHeader = stream.nextUInt16();
      if (tiffHeader === 18761) {
        stream.setBigEndian(false);
      } else if (tiffHeader === 19789) {
        stream.setBigEndian(true);
      } else {
        throw new Error("Invalid TIFF header");
      }
      if (stream.nextUInt16() !== 42) {
        throw new Error("Invalid TIFF data");
      }
      return tiffMarker;
    }
    module.exports = {
      IFD0: 1,
      IFD1: 2,
      GPSIFD: 3,
      SubIFD: 4,
      InteropIFD: 5,
      parseTags: function(stream, iterator) {
        var tiffMarker;
        try {
          tiffMarker = readHeader(stream);
        } catch (e) {
          return false;
        }
        var subIfdOffset, gpsOffset, interopOffset;
        var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = this.IFD0;
        readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format2) {
          switch (tagType) {
            case 34853:
              gpsOffset = value[0];
              break;
            case 34665:
              subIfdOffset = value[0];
              break;
            default:
              iterator(IFD0, tagType, value, format2);
              break;
          }
        });
        var ifd1Offset = ifd0Stream.nextUInt32();
        if (ifd1Offset !== 0) {
          var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
          readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
        }
        if (gpsOffset) {
          var gpsStream = tiffMarker.openWithOffset(gpsOffset);
          readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
        }
        if (subIfdOffset) {
          var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
          readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format2) {
            if (tagType === 40965) {
              interopOffset = value[0];
            } else {
              iterator(InteropIFD, tagType, value, format2);
            }
          });
        }
        if (interopOffset) {
          var interopStream = tiffMarker.openWithOffset(interopOffset);
          readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
        }
        return true;
      }
    };
  }
});

// node_modules/exif-parser/lib/date.js
var require_date = __commonJS({
  "node_modules/exif-parser/lib/date.js"(exports, module) {
    init_shims();
    function parseNumber(s2) {
      return parseInt(s2, 10);
    }
    var hours = 3600;
    var minutes = 60;
    function parseDateTimeParts(dateParts, timeParts) {
      dateParts = dateParts.map(parseNumber);
      timeParts = timeParts.map(parseNumber);
      var year = dateParts[0];
      var month = dateParts[1] - 1;
      var day = dateParts[2];
      var hours2 = timeParts[0];
      var minutes2 = timeParts[1];
      var seconds = timeParts[2];
      var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
      var timestamp = date / 1e3;
      return timestamp;
    }
    function parseDateWithTimezoneFormat(dateTimeStr) {
      var dateParts = dateTimeStr.substr(0, 10).split("-");
      var timeParts = dateTimeStr.substr(11, 8).split(":");
      var timezoneStr = dateTimeStr.substr(19, 6);
      var timezoneParts = timezoneStr.split(":").map(parseNumber);
      var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
      var timestamp = parseDateTimeParts(dateParts, timeParts);
      timestamp -= timezoneOffset;
      if (typeof timestamp === "number" && !isNaN(timestamp)) {
        return timestamp;
      }
    }
    function parseDateWithSpecFormat(dateTimeStr) {
      var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
      var timestamp = parseDateTimeParts(dateParts, timeParts);
      if (typeof timestamp === "number" && !isNaN(timestamp)) {
        return timestamp;
      }
    }
    function parseExifDate(dateTimeStr) {
      var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
      var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
      var timestamp;
      if (isTimezoneFormat) {
        return parseDateWithTimezoneFormat(dateTimeStr);
      } else if (isSpecFormat) {
        return parseDateWithSpecFormat(dateTimeStr);
      }
    }
    module.exports = {
      parseDateWithSpecFormat,
      parseDateWithTimezoneFormat,
      parseExifDate
    };
  }
});

// node_modules/exif-parser/lib/simplify.js
var require_simplify = __commonJS({
  "node_modules/exif-parser/lib/simplify.js"(exports, module) {
    init_shims();
    var exif = require_exif();
    var date = require_date();
    var degreeTags = [
      {
        section: exif.GPSIFD,
        type: 2,
        name: "GPSLatitude",
        refType: 1,
        refName: "GPSLatitudeRef",
        posVal: "N"
      },
      {
        section: exif.GPSIFD,
        type: 4,
        name: "GPSLongitude",
        refType: 3,
        refName: "GPSLongitudeRef",
        posVal: "E"
      }
    ];
    var dateTags = [
      {
        section: exif.SubIFD,
        type: 306,
        name: "ModifyDate"
      },
      {
        section: exif.SubIFD,
        type: 36867,
        name: "DateTimeOriginal"
      },
      {
        section: exif.SubIFD,
        type: 36868,
        name: "CreateDate"
      },
      {
        section: exif.SubIFD,
        type: 306,
        name: "ModifyDate"
      }
    ];
    module.exports = {
      castDegreeValues: function(getTagValue, setTagValue) {
        degreeTags.forEach(function(t) {
          var degreeVal = getTagValue(t);
          if (degreeVal) {
            var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
            var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
            var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
            setTagValue(t, degree);
          }
        });
      },
      castDateValues: function(getTagValue, setTagValue) {
        dateTags.forEach(function(t) {
          var dateStrVal = getTagValue(t);
          if (dateStrVal) {
            var timestamp = date.parseExifDate(dateStrVal);
            if (typeof timestamp !== "undefined") {
              setTagValue(t, timestamp);
            }
          }
        });
      },
      simplifyValue: function(values, format2) {
        if (Array.isArray(values)) {
          values = values.map(function(value) {
            if (format2 === 10 || format2 === 5) {
              return value[0] / value[1];
            }
            return value;
          });
          if (values.length === 1) {
            values = values[0];
          }
        }
        return values;
      }
    };
  }
});

// node_modules/exif-parser/lib/exif-tags.js
var require_exif_tags = __commonJS({
  "node_modules/exif-parser/lib/exif-tags.js"(exports, module) {
    init_shims();
    module.exports = {
      exif: {
        1: "InteropIndex",
        2: "InteropVersion",
        11: "ProcessingSoftware",
        254: "SubfileType",
        255: "OldSubfileType",
        256: "ImageWidth",
        257: "ImageHeight",
        258: "BitsPerSample",
        259: "Compression",
        262: "PhotometricInterpretation",
        263: "Thresholding",
        264: "CellWidth",
        265: "CellLength",
        266: "FillOrder",
        269: "DocumentName",
        270: "ImageDescription",
        271: "Make",
        272: "Model",
        273: "StripOffsets",
        274: "Orientation",
        277: "SamplesPerPixel",
        278: "RowsPerStrip",
        279: "StripByteCounts",
        280: "MinSampleValue",
        281: "MaxSampleValue",
        282: "XResolution",
        283: "YResolution",
        284: "PlanarConfiguration",
        285: "PageName",
        286: "XPosition",
        287: "YPosition",
        288: "FreeOffsets",
        289: "FreeByteCounts",
        290: "GrayResponseUnit",
        291: "GrayResponseCurve",
        292: "T4Options",
        293: "T6Options",
        296: "ResolutionUnit",
        297: "PageNumber",
        300: "ColorResponseUnit",
        301: "TransferFunction",
        305: "Software",
        306: "ModifyDate",
        315: "Artist",
        316: "HostComputer",
        317: "Predictor",
        318: "WhitePoint",
        319: "PrimaryChromaticities",
        320: "ColorMap",
        321: "HalftoneHints",
        322: "TileWidth",
        323: "TileLength",
        324: "TileOffsets",
        325: "TileByteCounts",
        326: "BadFaxLines",
        327: "CleanFaxData",
        328: "ConsecutiveBadFaxLines",
        330: "SubIFD",
        332: "InkSet",
        333: "InkNames",
        334: "NumberofInks",
        336: "DotRange",
        337: "TargetPrinter",
        338: "ExtraSamples",
        339: "SampleFormat",
        340: "SMinSampleValue",
        341: "SMaxSampleValue",
        342: "TransferRange",
        343: "ClipPath",
        344: "XClipPathUnits",
        345: "YClipPathUnits",
        346: "Indexed",
        347: "JPEGTables",
        351: "OPIProxy",
        400: "GlobalParametersIFD",
        401: "ProfileType",
        402: "FaxProfile",
        403: "CodingMethods",
        404: "VersionYear",
        405: "ModeNumber",
        433: "Decode",
        434: "DefaultImageColor",
        435: "T82Options",
        437: "JPEGTables",
        512: "JPEGProc",
        513: "ThumbnailOffset",
        514: "ThumbnailLength",
        515: "JPEGRestartInterval",
        517: "JPEGLosslessPredictors",
        518: "JPEGPointTransforms",
        519: "JPEGQTables",
        520: "JPEGDCTables",
        521: "JPEGACTables",
        529: "YCbCrCoefficients",
        530: "YCbCrSubSampling",
        531: "YCbCrPositioning",
        532: "ReferenceBlackWhite",
        559: "StripRowCounts",
        700: "ApplicationNotes",
        999: "USPTOMiscellaneous",
        4096: "RelatedImageFileFormat",
        4097: "RelatedImageWidth",
        4098: "RelatedImageHeight",
        18246: "Rating",
        18247: "XP_DIP_XML",
        18248: "StitchInfo",
        18249: "RatingPercent",
        32781: "ImageID",
        32931: "WangTag1",
        32932: "WangAnnotation",
        32933: "WangTag3",
        32934: "WangTag4",
        32995: "Matteing",
        32996: "DataType",
        32997: "ImageDepth",
        32998: "TileDepth",
        33405: "Model2",
        33421: "CFARepeatPatternDim",
        33422: "CFAPattern2",
        33423: "BatteryLevel",
        33424: "KodakIFD",
        33432: "Copyright",
        33434: "ExposureTime",
        33437: "FNumber",
        33445: "MDFileTag",
        33446: "MDScalePixel",
        33447: "MDColorTable",
        33448: "MDLabName",
        33449: "MDSampleInfo",
        33450: "MDPrepDate",
        33451: "MDPrepTime",
        33452: "MDFileUnits",
        33550: "PixelScale",
        33589: "AdventScale",
        33590: "AdventRevision",
        33628: "UIC1Tag",
        33629: "UIC2Tag",
        33630: "UIC3Tag",
        33631: "UIC4Tag",
        33723: "IPTC-NAA",
        33918: "IntergraphPacketData",
        33919: "IntergraphFlagRegisters",
        33920: "IntergraphMatrix",
        33921: "INGRReserved",
        33922: "ModelTiePoint",
        34016: "Site",
        34017: "ColorSequence",
        34018: "IT8Header",
        34019: "RasterPadding",
        34020: "BitsPerRunLength",
        34021: "BitsPerExtendedRunLength",
        34022: "ColorTable",
        34023: "ImageColorIndicator",
        34024: "BackgroundColorIndicator",
        34025: "ImageColorValue",
        34026: "BackgroundColorValue",
        34027: "PixelIntensityRange",
        34028: "TransparencyIndicator",
        34029: "ColorCharacterization",
        34030: "HCUsage",
        34031: "TrapIndicator",
        34032: "CMYKEquivalent",
        34118: "SEMInfo",
        34152: "AFCP_IPTC",
        34232: "PixelMagicJBIGOptions",
        34264: "ModelTransform",
        34306: "WB_GRGBLevels",
        34310: "LeafData",
        34377: "PhotoshopSettings",
        34665: "ExifOffset",
        34675: "ICC_Profile",
        34687: "TIFF_FXExtensions",
        34688: "MultiProfiles",
        34689: "SharedData",
        34690: "T88Options",
        34732: "ImageLayer",
        34735: "GeoTiffDirectory",
        34736: "GeoTiffDoubleParams",
        34737: "GeoTiffAsciiParams",
        34850: "ExposureProgram",
        34852: "SpectralSensitivity",
        34853: "GPSInfo",
        34855: "ISO",
        34856: "Opto-ElectricConvFactor",
        34857: "Interlace",
        34858: "TimeZoneOffset",
        34859: "SelfTimerMode",
        34864: "SensitivityType",
        34865: "StandardOutputSensitivity",
        34866: "RecommendedExposureIndex",
        34867: "ISOSpeed",
        34868: "ISOSpeedLatitudeyyy",
        34869: "ISOSpeedLatitudezzz",
        34908: "FaxRecvParams",
        34909: "FaxSubAddress",
        34910: "FaxRecvTime",
        34954: "LeafSubIFD",
        36864: "ExifVersion",
        36867: "DateTimeOriginal",
        36868: "CreateDate",
        37121: "ComponentsConfiguration",
        37122: "CompressedBitsPerPixel",
        37377: "ShutterSpeedValue",
        37378: "ApertureValue",
        37379: "BrightnessValue",
        37380: "ExposureCompensation",
        37381: "MaxApertureValue",
        37382: "SubjectDistance",
        37383: "MeteringMode",
        37384: "LightSource",
        37385: "Flash",
        37386: "FocalLength",
        37387: "FlashEnergy",
        37388: "SpatialFrequencyResponse",
        37389: "Noise",
        37390: "FocalPlaneXResolution",
        37391: "FocalPlaneYResolution",
        37392: "FocalPlaneResolutionUnit",
        37393: "ImageNumber",
        37394: "SecurityClassification",
        37395: "ImageHistory",
        37396: "SubjectArea",
        37397: "ExposureIndex",
        37398: "TIFF-EPStandardID",
        37399: "SensingMethod",
        37434: "CIP3DataFile",
        37435: "CIP3Sheet",
        37436: "CIP3Side",
        37439: "StoNits",
        37500: "MakerNote",
        37510: "UserComment",
        37520: "SubSecTime",
        37521: "SubSecTimeOriginal",
        37522: "SubSecTimeDigitized",
        37679: "MSDocumentText",
        37680: "MSPropertySetStorage",
        37681: "MSDocumentTextPosition",
        37724: "ImageSourceData",
        40091: "XPTitle",
        40092: "XPComment",
        40093: "XPAuthor",
        40094: "XPKeywords",
        40095: "XPSubject",
        40960: "FlashpixVersion",
        40961: "ColorSpace",
        40962: "ExifImageWidth",
        40963: "ExifImageHeight",
        40964: "RelatedSoundFile",
        40965: "InteropOffset",
        41483: "FlashEnergy",
        41484: "SpatialFrequencyResponse",
        41485: "Noise",
        41486: "FocalPlaneXResolution",
        41487: "FocalPlaneYResolution",
        41488: "FocalPlaneResolutionUnit",
        41489: "ImageNumber",
        41490: "SecurityClassification",
        41491: "ImageHistory",
        41492: "SubjectLocation",
        41493: "ExposureIndex",
        41494: "TIFF-EPStandardID",
        41495: "SensingMethod",
        41728: "FileSource",
        41729: "SceneType",
        41730: "CFAPattern",
        41985: "CustomRendered",
        41986: "ExposureMode",
        41987: "WhiteBalance",
        41988: "DigitalZoomRatio",
        41989: "FocalLengthIn35mmFormat",
        41990: "SceneCaptureType",
        41991: "GainControl",
        41992: "Contrast",
        41993: "Saturation",
        41994: "Sharpness",
        41995: "DeviceSettingDescription",
        41996: "SubjectDistanceRange",
        42016: "ImageUniqueID",
        42032: "OwnerName",
        42033: "SerialNumber",
        42034: "LensInfo",
        42035: "LensMake",
        42036: "LensModel",
        42037: "LensSerialNumber",
        42112: "GDALMetadata",
        42113: "GDALNoData",
        42240: "Gamma",
        44992: "ExpandSoftware",
        44993: "ExpandLens",
        44994: "ExpandFilm",
        44995: "ExpandFilterLens",
        44996: "ExpandScanner",
        44997: "ExpandFlashLamp",
        48129: "PixelFormat",
        48130: "Transformation",
        48131: "Uncompressed",
        48132: "ImageType",
        48256: "ImageWidth",
        48257: "ImageHeight",
        48258: "WidthResolution",
        48259: "HeightResolution",
        48320: "ImageOffset",
        48321: "ImageByteCount",
        48322: "AlphaOffset",
        48323: "AlphaByteCount",
        48324: "ImageDataDiscard",
        48325: "AlphaDataDiscard",
        50215: "OceScanjobDesc",
        50216: "OceApplicationSelector",
        50217: "OceIDNumber",
        50218: "OceImageLogic",
        50255: "Annotations",
        50341: "PrintIM",
        50560: "USPTOOriginalContentType",
        50706: "DNGVersion",
        50707: "DNGBackwardVersion",
        50708: "UniqueCameraModel",
        50709: "LocalizedCameraModel",
        50710: "CFAPlaneColor",
        50711: "CFALayout",
        50712: "LinearizationTable",
        50713: "BlackLevelRepeatDim",
        50714: "BlackLevel",
        50715: "BlackLevelDeltaH",
        50716: "BlackLevelDeltaV",
        50717: "WhiteLevel",
        50718: "DefaultScale",
        50719: "DefaultCropOrigin",
        50720: "DefaultCropSize",
        50721: "ColorMatrix1",
        50722: "ColorMatrix2",
        50723: "CameraCalibration1",
        50724: "CameraCalibration2",
        50725: "ReductionMatrix1",
        50726: "ReductionMatrix2",
        50727: "AnalogBalance",
        50728: "AsShotNeutral",
        50729: "AsShotWhiteXY",
        50730: "BaselineExposure",
        50731: "BaselineNoise",
        50732: "BaselineSharpness",
        50733: "BayerGreenSplit",
        50734: "LinearResponseLimit",
        50735: "CameraSerialNumber",
        50736: "DNGLensInfo",
        50737: "ChromaBlurRadius",
        50738: "AntiAliasStrength",
        50739: "ShadowScale",
        50740: "DNGPrivateData",
        50741: "MakerNoteSafety",
        50752: "RawImageSegmentation",
        50778: "CalibrationIlluminant1",
        50779: "CalibrationIlluminant2",
        50780: "BestQualityScale",
        50781: "RawDataUniqueID",
        50784: "AliasLayerMetadata",
        50827: "OriginalRawFileName",
        50828: "OriginalRawFileData",
        50829: "ActiveArea",
        50830: "MaskedAreas",
        50831: "AsShotICCProfile",
        50832: "AsShotPreProfileMatrix",
        50833: "CurrentICCProfile",
        50834: "CurrentPreProfileMatrix",
        50879: "ColorimetricReference",
        50898: "PanasonicTitle",
        50899: "PanasonicTitle2",
        50931: "CameraCalibrationSig",
        50932: "ProfileCalibrationSig",
        50933: "ProfileIFD",
        50934: "AsShotProfileName",
        50935: "NoiseReductionApplied",
        50936: "ProfileName",
        50937: "ProfileHueSatMapDims",
        50938: "ProfileHueSatMapData1",
        50939: "ProfileHueSatMapData2",
        50940: "ProfileToneCurve",
        50941: "ProfileEmbedPolicy",
        50942: "ProfileCopyright",
        50964: "ForwardMatrix1",
        50965: "ForwardMatrix2",
        50966: "PreviewApplicationName",
        50967: "PreviewApplicationVersion",
        50968: "PreviewSettingsName",
        50969: "PreviewSettingsDigest",
        50970: "PreviewColorSpace",
        50971: "PreviewDateTime",
        50972: "RawImageDigest",
        50973: "OriginalRawFileDigest",
        50974: "SubTileBlockSize",
        50975: "RowInterleaveFactor",
        50981: "ProfileLookTableDims",
        50982: "ProfileLookTableData",
        51008: "OpcodeList1",
        51009: "OpcodeList2",
        51022: "OpcodeList3",
        51041: "NoiseProfile",
        51043: "TimeCodes",
        51044: "FrameRate",
        51058: "TStop",
        51081: "ReelName",
        51089: "OriginalDefaultFinalSize",
        51090: "OriginalBestQualitySize",
        51091: "OriginalDefaultCropSize",
        51105: "CameraLabel",
        51107: "ProfileHueSatMapEncoding",
        51108: "ProfileLookTableEncoding",
        51109: "BaselineExposureOffset",
        51110: "DefaultBlackRender",
        51111: "NewRawImageDigest",
        51112: "RawToPreviewGain",
        51125: "DefaultUserCrop",
        59932: "Padding",
        59933: "OffsetSchema",
        65e3: "OwnerName",
        65001: "SerialNumber",
        65002: "Lens",
        65024: "KDC_IFD",
        65100: "RawFile",
        65101: "Converter",
        65102: "WhiteBalance",
        65105: "Exposure",
        65106: "Shadows",
        65107: "Brightness",
        65108: "Contrast",
        65109: "Saturation",
        65110: "Sharpness",
        65111: "Smoothness",
        65112: "MoireFilter"
      },
      gps: {
        0: "GPSVersionID",
        1: "GPSLatitudeRef",
        2: "GPSLatitude",
        3: "GPSLongitudeRef",
        4: "GPSLongitude",
        5: "GPSAltitudeRef",
        6: "GPSAltitude",
        7: "GPSTimeStamp",
        8: "GPSSatellites",
        9: "GPSStatus",
        10: "GPSMeasureMode",
        11: "GPSDOP",
        12: "GPSSpeedRef",
        13: "GPSSpeed",
        14: "GPSTrackRef",
        15: "GPSTrack",
        16: "GPSImgDirectionRef",
        17: "GPSImgDirection",
        18: "GPSMapDatum",
        19: "GPSDestLatitudeRef",
        20: "GPSDestLatitude",
        21: "GPSDestLongitudeRef",
        22: "GPSDestLongitude",
        23: "GPSDestBearingRef",
        24: "GPSDestBearing",
        25: "GPSDestDistanceRef",
        26: "GPSDestDistance",
        27: "GPSProcessingMethod",
        28: "GPSAreaInformation",
        29: "GPSDateStamp",
        30: "GPSDifferential",
        31: "GPSHPositioningError"
      }
    };
  }
});

// node_modules/exif-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/exif-parser/lib/parser.js"(exports, module) {
    init_shims();
    var jpeg = require_jpeg();
    var exif = require_exif();
    var simplify = require_simplify();
    function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
      this.startMarker = startMarker;
      this.tags = tags;
      this.imageSize = imageSize;
      this.thumbnailOffset = thumbnailOffset;
      this.thumbnailLength = thumbnailLength;
      this.thumbnailType = thumbnailType;
      this.app1Offset = app1Offset;
    }
    ExifResult.prototype = {
      hasThumbnail: function(mime) {
        if (!this.thumbnailOffset || !this.thumbnailLength) {
          return false;
        }
        if (typeof mime !== "string") {
          return true;
        }
        if (mime.toLowerCase().trim() === "image/jpeg") {
          return this.thumbnailType === 6;
        }
        if (mime.toLowerCase().trim() === "image/tiff") {
          return this.thumbnailType === 1;
        }
        return false;
      },
      getThumbnailOffset: function() {
        return this.app1Offset + 6 + this.thumbnailOffset;
      },
      getThumbnailLength: function() {
        return this.thumbnailLength;
      },
      getThumbnailBuffer: function() {
        return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
      },
      _getThumbnailStream: function() {
        return this.startMarker.openWithOffset(this.getThumbnailOffset());
      },
      getImageSize: function() {
        return this.imageSize;
      },
      getThumbnailSize: function() {
        var stream = this._getThumbnailStream(), size;
        jpeg.parseSections(stream, function(sectionType, sectionStream) {
          if (jpeg.getSectionName(sectionType).name === "SOF") {
            size = jpeg.getSizeFromSOFSection(sectionStream);
          }
        });
        return size;
      }
    };
    function Parser(stream) {
      this.stream = stream;
      this.flags = {
        readBinaryTags: false,
        resolveTagNames: true,
        simplifyValues: true,
        imageSize: true,
        hidePointers: true,
        returnTags: true
      };
    }
    Parser.prototype = {
      enableBinaryFields: function(enable) {
        this.flags.readBinaryTags = !!enable;
        return this;
      },
      enablePointers: function(enable) {
        this.flags.hidePointers = !enable;
        return this;
      },
      enableTagNames: function(enable) {
        this.flags.resolveTagNames = !!enable;
        return this;
      },
      enableImageSize: function(enable) {
        this.flags.imageSize = !!enable;
        return this;
      },
      enableReturnTags: function(enable) {
        this.flags.returnTags = !!enable;
        return this;
      },
      enableSimpleValues: function(enable) {
        this.flags.simplifyValues = !!enable;
        return this;
      },
      parse: function() {
        var start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
        if (flags.resolveTagNames) {
          tagNames = require_exif_tags();
        }
        if (flags.resolveTagNames) {
          tags = {};
          getTagValue = function(t) {
            return tags[t.name];
          };
          setTagValue = function(t, value) {
            tags[t.name] = value;
          };
        } else {
          tags = [];
          getTagValue = function(t) {
            var i;
            for (i = 0; i < tags.length; ++i) {
              if (tags[i].type === t.type && tags[i].section === t.section) {
                return tags.value;
              }
            }
          };
          setTagValue = function(t, value) {
            var i;
            for (i = 0; i < tags.length; ++i) {
              if (tags[i].type === t.type && tags[i].section === t.section) {
                tags.value = value;
                return;
              }
            }
          };
        }
        jpeg.parseSections(stream, function(sectionType, sectionStream) {
          var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
          if (sectionType === 225) {
            validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format2) {
              if (!flags.readBinaryTags && format2 === 7) {
                return;
              }
              if (tagType === 513) {
                thumbnailOffset = value[0];
                if (flags.hidePointers) {
                  return;
                }
              } else if (tagType === 514) {
                thumbnailLength = value[0];
                if (flags.hidePointers) {
                  return;
                }
              } else if (tagType === 259) {
                thumbnailType = value[0];
                if (flags.hidePointers) {
                  return;
                }
              }
              if (!flags.returnTags) {
                return;
              }
              if (flags.simplifyValues) {
                value = simplify.simplifyValue(value, format2);
              }
              if (flags.resolveTagNames) {
                var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
                var name = sectionTagNames[tagType];
                if (!name) {
                  name = tagNames.exif[tagType];
                }
                if (!tags.hasOwnProperty(name)) {
                  tags[name] = value;
                }
              } else {
                tags.push({
                  section: ifdSection,
                  type: tagType,
                  value
                });
              }
            });
            if (validExifHeaders) {
              app1Offset = sectionOffset;
            }
          } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
            imageSize = jpeg.getSizeFromSOFSection(sectionStream);
          }
        });
        if (flags.simplifyValues) {
          simplify.castDegreeValues(getTagValue, setTagValue);
          simplify.castDateValues(getTagValue, setTagValue);
        }
        return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
      }
    };
    module.exports = Parser;
  }
});

// node_modules/exif-parser/lib/dom-bufferstream.js
var require_dom_bufferstream = __commonJS({
  "node_modules/exif-parser/lib/dom-bufferstream.js"(exports, module) {
    init_shims();
    function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
      this.global = global;
      offset = offset || 0;
      length = length || arrayBuffer.byteLength - offset;
      this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
      this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
      this.setBigEndian(bigEndian);
      this.offset = 0;
      this.parentOffset = (parentOffset || 0) + offset;
    }
    DOMBufferStream.prototype = {
      setBigEndian: function(bigEndian) {
        this.littleEndian = !bigEndian;
      },
      nextUInt8: function() {
        var value = this.view.getUint8(this.offset);
        this.offset += 1;
        return value;
      },
      nextInt8: function() {
        var value = this.view.getInt8(this.offset);
        this.offset += 1;
        return value;
      },
      nextUInt16: function() {
        var value = this.view.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      },
      nextUInt32: function() {
        var value = this.view.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      nextInt16: function() {
        var value = this.view.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      },
      nextInt32: function() {
        var value = this.view.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      nextFloat: function() {
        var value = this.view.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      nextDouble: function() {
        var value = this.view.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      },
      nextBuffer: function(length) {
        var value = this.arrayBuffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return value;
      },
      remainingLength: function() {
        return this.arrayBuffer.byteLength - this.offset;
      },
      nextString: function(length) {
        var value = this.arrayBuffer.slice(this.offset, this.offset + length);
        value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
        this.offset += length;
        return value;
      },
      mark: function() {
        var self2 = this;
        return {
          openWithOffset: function(offset) {
            offset = (offset || 0) + this.offset;
            return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
          },
          offset: this.offset,
          getParentOffset: function() {
            return self2.parentOffset;
          }
        };
      },
      offsetFrom: function(marker) {
        return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
      },
      skip: function(amount) {
        this.offset += amount;
      },
      branch: function(offset, length) {
        length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
        return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
      }
    };
    module.exports = DOMBufferStream;
  }
});

// node_modules/exif-parser/lib/bufferstream.js
var require_bufferstream = __commonJS({
  "node_modules/exif-parser/lib/bufferstream.js"(exports, module) {
    init_shims();
    function BufferStream(buffer, offset, length, bigEndian) {
      this.buffer = buffer;
      this.offset = offset || 0;
      length = typeof length === "number" ? length : buffer.length;
      this.endPosition = this.offset + length;
      this.setBigEndian(bigEndian);
    }
    BufferStream.prototype = {
      setBigEndian: function(bigEndian) {
        this.bigEndian = !!bigEndian;
      },
      nextUInt8: function() {
        var value = this.buffer.readUInt8(this.offset);
        this.offset += 1;
        return value;
      },
      nextInt8: function() {
        var value = this.buffer.readInt8(this.offset);
        this.offset += 1;
        return value;
      },
      nextUInt16: function() {
        var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      },
      nextUInt32: function() {
        var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      },
      nextInt16: function() {
        var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
        this.offset += 2;
        return value;
      },
      nextInt32: function() {
        var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return value;
      },
      nextFloat: function() {
        var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
        this.offset += 4;
        return value;
      },
      nextDouble: function() {
        var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
        this.offset += 8;
        return value;
      },
      nextBuffer: function(length) {
        var value = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return value;
      },
      remainingLength: function() {
        return this.endPosition - this.offset;
      },
      nextString: function(length) {
        var value = this.buffer.toString("utf8", this.offset, this.offset + length);
        this.offset += length;
        return value;
      },
      mark: function() {
        var self2 = this;
        return {
          openWithOffset: function(offset) {
            offset = (offset || 0) + this.offset;
            return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
          },
          offset: this.offset
        };
      },
      offsetFrom: function(marker) {
        return this.offset - marker.offset;
      },
      skip: function(amount) {
        this.offset += amount;
      },
      branch: function(offset, length) {
        length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
        return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
      }
    };
    module.exports = BufferStream;
  }
});

// node_modules/exif-parser/index.js
var require_exif_parser = __commonJS({
  "node_modules/exif-parser/index.js"(exports, module) {
    init_shims();
    var Parser = require_parser();
    function getGlobal() {
      return (1, eval)("this");
    }
    module.exports = {
      create: function(buffer, global) {
        global = global || getGlobal();
        if (buffer instanceof global.ArrayBuffer) {
          var DOMBufferStream = require_dom_bufferstream();
          return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
        } else {
          var NodeBufferStream = require_bufferstream();
          return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
        }
      }
    };
  }
});

// node_modules/@jimp/core/dist/utils/image-bitmap.js
var require_image_bitmap = __commonJS({
  "node_modules/@jimp/core/dist/utils/image-bitmap.js"(exports) {
    init_shims();
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseBitmap = parseBitmap;
    exports.getBuffer = getBuffer;
    exports.getBufferAsync = getBufferAsync;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _fileType = _interopRequireDefault(require_file_type());
    var _exifParser = _interopRequireDefault(require_exif_parser());
    var _utils = require_dist();
    var constants = _interopRequireWildcard(require_constants());
    var MIME = _interopRequireWildcard(require_mime());
    var _promisify = _interopRequireDefault(require_promisify());
    function getMIMEFromBuffer(buffer, path2) {
      var fileTypeFromBuffer = (0, _fileType["default"])(buffer);
      if (fileTypeFromBuffer) {
        return fileTypeFromBuffer.mime;
      }
      if (path2) {
        return MIME.getType(path2);
      }
      return null;
    }
    function getExifOrientation(img) {
      return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
    }
    function getExifOrientationTransformation(img) {
      var w = img.getWidth();
      var h = img.getHeight();
      switch (getExifOrientation(img)) {
        case 1:
          return null;
        case 2:
          return function(x, y) {
            return [w - x - 1, y];
          };
        case 3:
          return function(x, y) {
            return [w - x - 1, h - y - 1];
          };
        case 4:
          return function(x, y) {
            return [x, h - y - 1];
          };
        case 5:
          return function(x, y) {
            return [y, x];
          };
        case 6:
          return function(x, y) {
            return [y, h - x - 1];
          };
        case 7:
          return function(x, y) {
            return [w - y - 1, h - x - 1];
          };
        case 8:
          return function(x, y) {
            return [w - y - 1, x];
          };
        default:
          return null;
      }
    }
    function transformBitmap(img, width, height, transformation) {
      var _data = img.bitmap.data;
      var _width = img.bitmap.width;
      var data = Buffer.alloc(_data.length);
      for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
          var _transformation = transformation(x, y), _transformation2 = (0, _slicedToArray2["default"])(_transformation, 2), _x = _transformation2[0], _y = _transformation2[1];
          var idx = width * y + x << 2;
          var _idx = _width * _y + _x << 2;
          var pixel = _data.readUInt32BE(_idx);
          data.writeUInt32BE(pixel, idx);
        }
      }
      img.bitmap.data = data;
      img.bitmap.width = width;
      img.bitmap.height = height;
    }
    function exifRotate(img) {
      if (getExifOrientation(img) < 2)
        return;
      var transformation = getExifOrientationTransformation(img);
      var swapDimensions = getExifOrientation(img) > 4;
      var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
      var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
      transformBitmap(img, newWidth, newHeight, transformation);
    }
    function parseBitmap(data, path2, cb) {
      var mime = getMIMEFromBuffer(data, path2);
      if (typeof mime !== "string") {
        return cb(new Error("Could not find MIME for Buffer <" + path2 + ">"));
      }
      this._originalMime = mime.toLowerCase();
      try {
        var _mime = this.getMIME();
        if (this.constructor.decoders[_mime]) {
          this.bitmap = this.constructor.decoders[_mime](data);
        } else {
          return _utils.throwError.call(this, "Unsupported MIME type: " + _mime, cb);
        }
      } catch (error2) {
        return cb.call(this, error2, this);
      }
      try {
        this._exif = _exifParser["default"].create(data).parse();
        exifRotate(this);
      } catch (error2) {
      }
      cb.call(this, null, this);
      return this;
    }
    function compositeBitmapOverBackground(Jimp2, image2) {
      return new Jimp2(image2.bitmap.width, image2.bitmap.height, image2._background).composite(image2, 0, 0).bitmap;
    }
    function getBuffer(mime, cb) {
      if (mime === constants.AUTO) {
        mime = this.getMIME();
      }
      if (typeof mime !== "string") {
        return _utils.throwError.call(this, "mime must be a string", cb);
      }
      if (typeof cb !== "function") {
        return _utils.throwError.call(this, "cb must be a function", cb);
      }
      mime = mime.toLowerCase();
      if (this._rgba && this.constructor.hasAlpha[mime]) {
        this.bitmap.data = Buffer.from(this.bitmap.data);
      } else {
        this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
      }
      if (this.constructor.encoders[mime]) {
        var buffer = this.constructor.encoders[mime](this);
        cb.call(this, null, buffer);
      } else {
        cb.call(this, "Unsupported MIME type: " + mime);
      }
      return this;
    }
    function getBufferAsync(mime) {
      return (0, _promisify["default"])(getBuffer, this, mime);
    }
  }
});

// node_modules/@jimp/core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@jimp/core/dist/index.js"(exports) {
    init_shims();
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addConstants = addConstants;
    exports.addJimpMethods = addJimpMethods;
    exports.jimpEvMethod = jimpEvMethod;
    exports.jimpEvChange = jimpEvChange;
    Object.defineProperty(exports, "addType", {
      enumerable: true,
      get: function get3() {
        return MIME.addType;
      }
    });
    exports["default"] = void 0;
    var _construct2 = _interopRequireDefault(require_construct());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _events = _interopRequireDefault(__require("events"));
    var _utils = require_dist();
    var _anyBase = _interopRequireDefault(require_any_base());
    var _mkdirp = _interopRequireDefault(require_mkdirp());
    var _pixelmatch = _interopRequireDefault(require_pixelmatch());
    var _tinycolor = _interopRequireDefault(require_tinycolor());
    var _phash = _interopRequireDefault(require_phash());
    var _request = _interopRequireDefault(require_request());
    var _composite = _interopRequireDefault(require_composite());
    var _promisify = _interopRequireDefault(require_promisify());
    var MIME = _interopRequireWildcard(require_mime());
    var _imageBitmap = require_image_bitmap();
    var constants = _interopRequireWildcard(require_constants());
    var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
    var maxHashLength = [NaN, NaN];
    for (i = 2; i < 65; i++) {
      maxHash = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
      maxHashLength.push(maxHash.length);
    }
    var maxHash;
    var i;
    function noop3() {
    }
    function isArrayBuffer(test) {
      return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
    }
    function bufferFromArrayBuffer(arrayBuffer) {
      var buffer = Buffer.alloc(arrayBuffer.byteLength);
      var view = new Uint8Array(arrayBuffer);
      for (var _i = 0; _i < buffer.length; ++_i) {
        buffer[_i] = view[_i];
      }
      return buffer;
    }
    function loadFromURL(options2, cb) {
      (0, _request["default"])(options2, function(err, response, data) {
        if (err) {
          return cb(err);
        }
        if ("headers" in response && "location" in response.headers) {
          options2.url = response.headers.location;
          return loadFromURL(options2, cb);
        }
        if ((0, _typeof2["default"])(data) === "object" && Buffer.isBuffer(data)) {
          return cb(null, data);
        }
        var msg = "Could not load Buffer from <" + options2.url + "> (HTTP: " + response.statusCode + ")";
        return new Error(msg);
      });
    }
    function loadBufferFromPath(src2, cb) {
      if (_fs["default"] && typeof _fs["default"].readFile === "function" && !src2.match(/^(http|ftp)s?:\/\/./)) {
        _fs["default"].readFile(src2, cb);
      } else {
        loadFromURL({
          url: src2
        }, cb);
      }
    }
    function isRawRGBAData(obj) {
      return obj && (0, _typeof2["default"])(obj) === "object" && typeof obj.width === "number" && typeof obj.height === "number" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === "function" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
    }
    function makeRGBABufferFromRGB(buffer) {
      if (buffer.length % 3 !== 0) {
        throw new Error("Buffer length is incorrect");
      }
      var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
      var j = 0;
      for (var _i2 = 0; _i2 < buffer.length; _i2++) {
        rgbaBuffer[j] = buffer[_i2];
        if ((_i2 + 1) % 3 === 0) {
          rgbaBuffer[++j] = 255;
        }
        j++;
      }
      return rgbaBuffer;
    }
    var emptyBitmap = {
      data: null,
      width: null,
      height: null
    };
    var Jimp2 = /* @__PURE__ */ function(_EventEmitter) {
      (0, _inherits2["default"])(Jimp3, _EventEmitter);
      function Jimp3() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (0, _classCallCheck2["default"])(this, Jimp3);
        _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Jimp3).call(this));
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "bitmap", emptyBitmap);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_background", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_originalMime", Jimp3.MIME_PNG);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_exif", null);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rgba", true);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "writeAsync", function(path3) {
          return (0, _promisify["default"])(_this.write, (0, _assertThisInitialized2["default"])(_this), path3);
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBase64Async", function(mime) {
          return (0, _promisify["default"])(_this.getBase64, (0, _assertThisInitialized2["default"])(_this), mime);
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBuffer", _imageBitmap.getBuffer);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBufferAsync", _imageBitmap.getBufferAsync);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getPixelColour", _this.getPixelColor);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setPixelColour", _this.setPixelColor);
        var jimpInstance = (0, _assertThisInitialized2["default"])(_this);
        var cb = noop3;
        if (isArrayBuffer(args[0])) {
          args[0] = bufferFromArrayBuffer(args[0]);
        }
        function finish() {
          for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args2[_key2] = arguments[_key2];
          }
          var err = args2[0];
          var evData = err || {};
          evData.methodName = "constructor";
          setTimeout(function() {
            var _cb;
            if (err && cb === noop3) {
              jimpInstance.emitError("constructor", err);
            } else if (!err) {
              jimpInstance.emitMulti("constructor", "initialized");
            }
            (_cb = cb).call.apply(_cb, [jimpInstance].concat(args2));
          }, 1);
        }
        if (typeof args[0] === "number" && typeof args[1] === "number" || parseInt(args[0], 10) && parseInt(args[1], 10)) {
          var w = parseInt(args[0], 10);
          var h = parseInt(args[1], 10);
          cb = args[2];
          if (typeof args[2] === "number") {
            _this._background = args[2];
            cb = args[3];
          }
          if (typeof args[2] === "string") {
            _this._background = Jimp3.cssColorToHex(args[2]);
            cb = args[3];
          }
          if (typeof cb === "undefined") {
            cb = noop3;
          }
          if (typeof cb !== "function") {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
          }
          _this.bitmap = {
            data: Buffer.alloc(w * h * 4),
            width: w,
            height: h
          };
          for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {
            _this.bitmap.data.writeUInt32BE(_this._background, _i3);
          }
          finish(null, (0, _assertThisInitialized2["default"])(_this));
        } else if ((0, _typeof2["default"])(args[0]) === "object" && args[0].url) {
          cb = args[1] || noop3;
          if (typeof cb !== "function") {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
          }
          loadFromURL(args[0], function(err, data2) {
            if (err) {
              return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
            }
            _this.parseBitmap(data2, args[0].url, finish);
          });
        } else if (args[0] instanceof Jimp3) {
          var original = args[0];
          cb = args[1];
          if (typeof cb === "undefined") {
            cb = noop3;
          }
          if (typeof cb !== "function") {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
          }
          _this.bitmap = {
            data: Buffer.from(original.bitmap.data),
            width: original.bitmap.width,
            height: original.bitmap.height
          };
          _this._quality = original._quality;
          _this._deflateLevel = original._deflateLevel;
          _this._deflateStrategy = original._deflateStrategy;
          _this._filterType = original._filterType;
          _this._rgba = original._rgba;
          _this._background = original._background;
          _this._originalMime = original._originalMime;
          finish(null, (0, _assertThisInitialized2["default"])(_this));
        } else if (isRawRGBAData(args[0])) {
          var imageData = args[0];
          cb = args[1] || noop3;
          var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
          var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
          _this.bitmap = {
            data: buffer,
            width: imageData.width,
            height: imageData.height
          };
          finish(null, (0, _assertThisInitialized2["default"])(_this));
        } else if (typeof args[0] === "string") {
          var path2 = args[0];
          cb = args[1];
          if (typeof cb === "undefined") {
            cb = noop3;
          }
          if (typeof cb !== "function") {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
          }
          loadBufferFromPath(path2, function(err, data2) {
            if (err) {
              return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
            }
            _this.parseBitmap(data2, path2, finish);
          });
        } else if ((0, _typeof2["default"])(args[0]) === "object" && Buffer.isBuffer(args[0])) {
          var data = args[0];
          cb = args[1];
          if (typeof cb !== "function") {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
          }
          _this.parseBitmap(data, null, finish);
        } else {
          cb = args[args.length - 1];
          if (typeof cb !== "function") {
            cb = args[args.length - 2];
            if (typeof cb !== "function") {
              cb = noop3;
            }
          }
          var extraConstructor = Jimp3.__extraConstructors.find(function(c) {
            return c.test.apply(c, args);
          });
          if (extraConstructor) {
            new Promise(function(resolve3, reject) {
              var _extraConstructor$run;
              return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2["default"])(_this), resolve3, reject].concat(args));
            }).then(function() {
              return finish(null, (0, _assertThisInitialized2["default"])(_this));
            })["catch"](finish);
          } else {
            return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish));
          }
        }
        return _this;
      }
      (0, _createClass2["default"])(Jimp3, [{
        key: "parseBitmap",
        value: function parseBitmap(data, path2, finish) {
          _imageBitmap.parseBitmap.call(this, data, null, finish);
        }
      }, {
        key: "rgba",
        value: function rgba(bool, cb) {
          if (typeof bool !== "boolean") {
            return _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb);
          }
          this._rgba = bool;
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }, {
        key: "emitMulti",
        value: function emitMulti(methodName, eventName) {
          var data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          data = Object.assign(data, {
            methodName,
            eventName
          });
          this.emit("any", data);
          if (methodName) {
            this.emit(methodName, data);
          }
          this.emit(eventName, data);
        }
      }, {
        key: "emitError",
        value: function emitError(methodName, err) {
          this.emitMulti(methodName, "error", err);
        }
      }, {
        key: "getHeight",
        value: function getHeight() {
          return this.bitmap.height;
        }
      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.bitmap.width;
        }
      }, {
        key: "inspect",
        value: function inspect() {
          return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
        }
      }, {
        key: "toString",
        value: function toString() {
          return "[object Jimp]";
        }
      }, {
        key: "getMIME",
        value: function getMIME() {
          var mime = this._originalMime || Jimp3.MIME_PNG;
          return mime;
        }
      }, {
        key: "getExtension",
        value: function getExtension() {
          var mime = this.getMIME();
          return MIME.getExtension(mime);
        }
      }, {
        key: "write",
        value: function write(path2, cb) {
          var _this2 = this;
          if (!_fs["default"] || !_fs["default"].createWriteStream) {
            throw new Error("Cant access the filesystem. You can use the getBase64 method.");
          }
          if (typeof path2 !== "string") {
            return _utils.throwError.call(this, "path must be a string", cb);
          }
          if (typeof cb === "undefined") {
            cb = noop3;
          }
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", cb);
          }
          var mime = MIME.getType(path2) || this.getMIME();
          var pathObj = _path["default"].parse(path2);
          if (pathObj.dir) {
            _mkdirp["default"].sync(pathObj.dir);
          }
          this.getBuffer(mime, function(err, buffer) {
            if (err) {
              return _utils.throwError.call(_this2, err, cb);
            }
            var stream = _fs["default"].createWriteStream(path2);
            stream.on("open", function() {
              stream.write(buffer);
              stream.end();
            }).on("error", function(err2) {
              return _utils.throwError.call(_this2, err2, cb);
            });
            stream.on("finish", function() {
              cb.call(_this2, null, _this2);
            });
          });
          return this;
        }
      }, {
        key: "getBase64",
        value: function getBase64(mime, cb) {
          if (mime === Jimp3.AUTO) {
            mime = this.getMIME();
          }
          if (typeof mime !== "string") {
            return _utils.throwError.call(this, "mime must be a string", cb);
          }
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", cb);
          }
          this.getBuffer(mime, function(err, data) {
            if (err) {
              return _utils.throwError.call(this, err, cb);
            }
            var src2 = "data:" + mime + ";base64," + data.toString("base64");
            cb.call(this, null, src2);
          });
          return this;
        }
      }, {
        key: "hash",
        value: function hash2(base2, cb) {
          base2 = base2 || 64;
          if (typeof base2 === "function") {
            cb = base2;
            base2 = 64;
          }
          if (typeof base2 !== "number") {
            return _utils.throwError.call(this, "base must be a number", cb);
          }
          if (base2 < 2 || base2 > 64) {
            return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
          }
          var hash3 = this.pHash();
          hash3 = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, base2))(hash3);
          while (hash3.length < maxHashLength[base2]) {
            hash3 = "0" + hash3;
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, hash3);
          }
          return hash3;
        }
      }, {
        key: "pHash",
        value: function pHash() {
          var pHash2 = new _phash["default"]();
          return pHash2.getHash(this);
        }
      }, {
        key: "distanceFromHash",
        value: function distanceFromHash(compareHash) {
          var pHash = new _phash["default"]();
          var currentHash = pHash.getHash(this);
          return pHash.distance(currentHash, compareHash);
        }
      }, {
        key: "getPixelIndex",
        value: function getPixelIndex(x, y, edgeHandling, cb) {
          var xi;
          var yi;
          if (typeof edgeHandling === "function" && typeof cb === "undefined") {
            cb = edgeHandling;
            edgeHandling = null;
          }
          if (!edgeHandling) {
            edgeHandling = Jimp3.EDGE_EXTEND;
          }
          if (typeof x !== "number" || typeof y !== "number") {
            return _utils.throwError.call(this, "x and y must be numbers", cb);
          }
          x = Math.round(x);
          y = Math.round(y);
          xi = x;
          yi = y;
          if (edgeHandling === Jimp3.EDGE_EXTEND) {
            if (x < 0)
              xi = 0;
            if (x >= this.bitmap.width)
              xi = this.bitmap.width - 1;
            if (y < 0)
              yi = 0;
            if (y >= this.bitmap.height)
              yi = this.bitmap.height - 1;
          }
          if (edgeHandling === Jimp3.EDGE_WRAP) {
            if (x < 0) {
              xi = this.bitmap.width + x;
            }
            if (x >= this.bitmap.width) {
              xi = x % this.bitmap.width;
            }
            if (y < 0) {
              xi = this.bitmap.height + y;
            }
            if (y >= this.bitmap.height) {
              yi = y % this.bitmap.height;
            }
          }
          var i2 = this.bitmap.width * yi + xi << 2;
          if (xi < 0 || xi >= this.bitmap.width) {
            i2 = -1;
          }
          if (yi < 0 || yi >= this.bitmap.height) {
            i2 = -1;
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, i2);
          }
          return i2;
        }
      }, {
        key: "getPixelColor",
        value: function getPixelColor(x, y, cb) {
          if (typeof x !== "number" || typeof y !== "number")
            return _utils.throwError.call(this, "x and y must be numbers", cb);
          x = Math.round(x);
          y = Math.round(y);
          var idx = this.getPixelIndex(x, y);
          var hex = this.bitmap.data.readUInt32BE(idx);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, hex);
          }
          return hex;
        }
      }, {
        key: "setPixelColor",
        value: function setPixelColor(hex, x, y, cb) {
          if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number")
            return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
          x = Math.round(x);
          y = Math.round(y);
          var idx = this.getPixelIndex(x, y);
          this.bitmap.data.writeUInt32BE(hex, idx);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }, {
        key: "hasAlpha",
        value: function hasAlpha() {
          for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
            for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
              var idx = this.bitmap.width * yIndex + xIndex << 2;
              var alpha = this.bitmap.data[idx + 3];
              if (alpha !== 255) {
                return true;
              }
            }
          }
          return false;
        }
      }, {
        key: "scanIterator",
        value: function scanIterator(x, y, w, h) {
          if (typeof x !== "number" || typeof y !== "number") {
            return _utils.throwError.call(this, "x and y must be numbers");
          }
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers");
          }
          return (0, _utils.scanIterator)(this, x, y, w, h);
        }
      }]);
      return Jimp3;
    }(_events["default"]);
    function addConstants(constants2) {
      var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp2;
      Object.entries(constants2).forEach(function(_ref) {
        var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), name = _ref2[0], value = _ref2[1];
        jimpInstance[name] = value;
      });
    }
    function addJimpMethods(methods) {
      var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp2;
      Object.entries(methods).forEach(function(_ref3) {
        var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2), name = _ref4[0], value = _ref4[1];
        jimpInstance.prototype[name] = value;
      });
    }
    addConstants(constants);
    addJimpMethods({
      composite: _composite["default"]
    });
    Jimp2.__extraConstructors = [];
    Jimp2.appendConstructorOption = function(name, test, run2) {
      Jimp2.__extraConstructors.push({
        name,
        test,
        run: run2
      });
    };
    Jimp2.read = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return new Promise(function(resolve3, reject) {
        (0, _construct2["default"])(Jimp2, args.concat([function(err, image2) {
          if (err)
            reject(err);
          else
            resolve3(image2);
        }]));
      });
    };
    Jimp2.create = Jimp2.read;
    Jimp2.rgbaToInt = function(r, g, b, a, cb) {
      if (typeof r !== "number" || typeof g !== "number" || typeof b !== "number" || typeof a !== "number") {
        return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
      }
      if (r < 0 || r > 255) {
        return _utils.throwError.call(this, "r must be between 0 and 255", cb);
      }
      if (g < 0 || g > 255) {
        _utils.throwError.call(this, "g must be between 0 and 255", cb);
      }
      if (b < 0 || b > 255) {
        return _utils.throwError.call(this, "b must be between 0 and 255", cb);
      }
      if (a < 0 || a > 255) {
        return _utils.throwError.call(this, "a must be between 0 and 255", cb);
      }
      r = Math.round(r);
      b = Math.round(b);
      g = Math.round(g);
      a = Math.round(a);
      var i2 = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, i2);
      }
      return i2;
    };
    Jimp2.intToRGBA = function(i2, cb) {
      if (typeof i2 !== "number") {
        return _utils.throwError.call(this, "i must be a number", cb);
      }
      var rgba = {};
      rgba.r = Math.floor(i2 / Math.pow(256, 3));
      rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
      rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
      rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, rgba);
      }
      return rgba;
    };
    Jimp2.cssColorToHex = function(cssColor) {
      cssColor = cssColor || 0;
      if (typeof cssColor === "number")
        return Number(cssColor);
      return parseInt((0, _tinycolor["default"])(cssColor).toHex8(), 16);
    };
    Jimp2.limit255 = function(n) {
      n = Math.max(n, 0);
      n = Math.min(n, 255);
      return n;
    };
    Jimp2.diff = function(img1, img2) {
      var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
      if (!(img1 instanceof Jimp2) || !(img2 instanceof Jimp2))
        return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
      var bmp1 = img1.bitmap;
      var bmp2 = img2.bitmap;
      if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
        if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
          img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
        } else {
          img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
        }
      }
      if (typeof threshold !== "number" || threshold < 0 || threshold > 1) {
        return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
      }
      var diff = new Jimp2(bmp1.width, bmp1.height, 4294967295);
      var numDiffPixels = (0, _pixelmatch["default"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
        threshold
      });
      return {
        percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
        image: diff
      };
    };
    Jimp2.distance = function(img1, img2) {
      var phash = new _phash["default"]();
      var hash1 = phash.getHash(img1);
      var hash2 = phash.getHash(img2);
      return phash.distance(hash1, hash2);
    };
    Jimp2.compareHashes = function(hash1, hash2) {
      var phash = new _phash["default"]();
      return phash.distance(hash1, hash2);
    };
    Jimp2.colorDiff = function(rgba1, rgba2) {
      var pow = function pow2(n) {
        return Math.pow(n, 2);
      };
      var max = Math.max;
      var maxVal = 255 * 255 * 3;
      if (rgba1.a !== 0 && !rgba1.a) {
        rgba1.a = 255;
      }
      if (rgba2.a !== 0 && !rgba2.a) {
        rgba2.a = 255;
      }
      return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
    };
    function jimpEvMethod(methodName, evName, method) {
      var evNameBefore = "before-" + evName;
      var evNameAfter = evName.replace(/e$/, "") + "ed";
      Jimp2.prototype[methodName] = function() {
        var wrappedCb;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        var cb = args[method.length - 1];
        var jimpInstance = this;
        if (typeof cb === "function") {
          wrappedCb = function wrappedCb2() {
            for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args2[_key5] = arguments[_key5];
            }
            var err = args2[0], data = args2[1];
            if (err) {
              jimpInstance.emitError(methodName, err);
            } else {
              jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, data));
            }
            cb.apply(this, args2);
          };
          args[args.length - 1] = wrappedCb;
        } else {
          wrappedCb = false;
        }
        this.emitMulti(methodName, evNameBefore);
        var result;
        try {
          result = method.apply(this, args);
          if (!wrappedCb) {
            this.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, result));
          }
        } catch (error2) {
          error2.methodName = methodName;
          this.emitError(methodName, error2);
        }
        return result;
      };
      Jimp2.prototype[methodName + "Quiet"] = method;
    }
    jimpEvMethod("clone", "clone", function(cb) {
      var clone2 = new Jimp2(this);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(clone2, null, clone2);
      }
      return clone2;
    });
    function jimpEvChange(methodName, method) {
      jimpEvMethod(methodName, "change", method);
    }
    jimpEvChange("background", function(hex, cb) {
      if (typeof hex !== "number") {
        return _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb);
      }
      this._background = hex;
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    });
    jimpEvChange("scan", function(x, y, w, h, f, cb) {
      if (typeof x !== "number" || typeof y !== "number") {
        return _utils.throwError.call(this, "x and y must be numbers", cb);
      }
      if (typeof w !== "number" || typeof h !== "number") {
        return _utils.throwError.call(this, "w and h must be numbers", cb);
      }
      if (typeof f !== "function") {
        return _utils.throwError.call(this, "f must be a function", cb);
      }
      var result = (0, _utils.scan)(this, x, y, w, h, f);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, result);
      }
      return result;
    });
    if (process.env.ENVIRONMENT === "BROWSER") {
      if (typeof window !== "undefined" && (typeof window === "undefined" ? "undefined" : (0, _typeof2["default"])(window)) === "object") {
        gl = window;
      }
      if (typeof self !== "undefined" && (typeof self === "undefined" ? "undefined" : (0, _typeof2["default"])(self)) === "object") {
        gl = self;
      }
      gl.Jimp = Jimp2;
      gl.Buffer = Buffer;
    }
    var gl;
    var _default = Jimp2;
    exports["default"] = _default;
  }
});

// node_modules/@jimp/custom/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@jimp/custom/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = configure;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _core = _interopRequireWildcard(require_dist2());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(source, true).forEach(function(key) {
            (0, _defineProperty2["default"])(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(source).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function configure(configuration) {
      var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _core["default"];
      var jimpConfig = {
        hasAlpha: {},
        encoders: {},
        decoders: {},
        "class": {},
        constants: {}
      };
      function addToConfig(newConfig) {
        Object.entries(newConfig).forEach(function(_ref) {
          var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), key = _ref2[0], value = _ref2[1];
          jimpConfig[key] = _objectSpread({}, jimpConfig[key], {}, value);
        });
      }
      function addImageType(typeModule) {
        var type = typeModule();
        if (Array.isArray(type.mime)) {
          _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(type.mime));
        } else {
          Object.entries(type.mime).forEach(function(mimeType) {
            return _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(mimeType));
          });
        }
        delete type.mime;
        addToConfig(type);
      }
      function addPlugin(pluginModule) {
        var plugin = pluginModule(_core.jimpEvChange) || {};
        if (!plugin["class"] && !plugin.constants) {
          addToConfig({
            "class": plugin
          });
        } else {
          addToConfig(plugin);
        }
      }
      if (configuration.types) {
        configuration.types.forEach(addImageType);
        jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, {}, jimpConfig.decoders);
        jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, {}, jimpConfig.encoders);
        jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, {}, jimpConfig.hasAlpha);
      }
      if (configuration.plugins) {
        configuration.plugins.forEach(addPlugin);
      }
      (0, _core.addJimpMethods)(jimpConfig["class"], jimpInstance);
      (0, _core.addConstants)(jimpConfig.constants, jimpInstance);
      return _core["default"];
    }
    module.exports = exports.default;
  }
});

// node_modules/timm/lib/timm.js
var require_timm = __commonJS({
  "node_modules/timm/lib/timm.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clone = clone2;
    exports.addLast = addLast;
    exports.addFirst = addFirst;
    exports.removeLast = removeLast;
    exports.removeFirst = removeFirst;
    exports.insert = insert;
    exports.removeAt = removeAt;
    exports.replaceAt = replaceAt;
    exports.getIn = getIn;
    exports.set = set;
    exports.setIn = setIn;
    exports.update = update;
    exports.updateIn = updateIn;
    exports.merge = merge;
    exports.mergeDeep = mergeDeep;
    exports.mergeIn = mergeIn;
    exports.omit = omit;
    exports.addDefaults = addDefaults;
    exports.default = void 0;
    var INVALID_ARGS = "INVALID_ARGS";
    var IS_DEV = process.env.NODE_ENV !== "production";
    function throwStr(msg) {
      throw new Error(msg);
    }
    function getKeysAndSymbols(obj) {
      const keys = Object.keys(obj);
      if (Object.getOwnPropertySymbols) {
        return keys.concat(Object.getOwnPropertySymbols(obj));
      }
      return keys;
    }
    var hasOwnProperty = {}.hasOwnProperty;
    function clone2(obj0) {
      if (Array.isArray(obj0))
        return obj0.slice();
      const obj = obj0;
      const keys = getKeysAndSymbols(obj);
      const out = {};
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        out[key] = obj[key];
      }
      return out;
    }
    function isObject2(o) {
      return o != null && typeof o === "object";
    }
    function addLast(array, val) {
      if (Array.isArray(val))
        return array.concat(val);
      return array.concat([val]);
    }
    function addFirst(array, val) {
      if (Array.isArray(val))
        return val.concat(array);
      return [val].concat(array);
    }
    function removeLast(array) {
      if (!array.length)
        return array;
      return array.slice(0, array.length - 1);
    }
    function removeFirst(array) {
      if (!array.length)
        return array;
      return array.slice(1);
    }
    function insert(array, idx, val) {
      return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
    }
    function removeAt(array, idx) {
      if (idx >= array.length || idx < 0)
        return array;
      return array.slice(0, idx).concat(array.slice(idx + 1));
    }
    function replaceAt(array, idx, newItem) {
      if (array[idx] === newItem)
        return array;
      const len = array.length;
      const result = Array(len);
      for (let i = 0; i < len; i++) {
        result[i] = array[i];
      }
      result[idx] = newItem;
      return result;
    }
    function getIn(obj, path2) {
      if (!Array.isArray(path2)) {
        throwStr(IS_DEV ? "A path array should be provided when calling getIn()" : INVALID_ARGS);
      }
      if (obj == null)
        return void 0;
      let ptr = obj;
      for (let i = 0; i < path2.length; i++) {
        const key = path2[i];
        ptr = ptr != null ? ptr[key] : void 0;
        if (ptr === void 0)
          return ptr;
      }
      return ptr;
    }
    function set(obj0, key, val) {
      let obj = obj0;
      if (obj == null)
        obj = typeof key === "number" ? [] : {};
      if (obj[key] === val)
        return obj;
      const obj2 = clone2(obj);
      obj2[key] = val;
      return obj2;
    }
    function setIn(obj, path2, val) {
      if (!path2.length)
        return val;
      return doSetIn(obj, path2, val, 0);
    }
    function doSetIn(obj, path2, val, idx) {
      let newValue;
      const key = path2[idx];
      if (idx === path2.length - 1) {
        newValue = val;
      } else {
        const nestedObj = isObject2(obj) && isObject2(obj[key]) ? obj[key] : typeof path2[idx + 1] === "number" ? [] : {};
        newValue = doSetIn(nestedObj, path2, val, idx + 1);
      }
      return set(obj, key, newValue);
    }
    function update(obj, key, fnUpdate) {
      const prevVal = obj == null ? void 0 : obj[key];
      const nextVal = fnUpdate(prevVal);
      return set(obj, key, nextVal);
    }
    function updateIn(obj, path2, fnUpdate) {
      const prevVal = getIn(obj, path2);
      const nextVal = fnUpdate(prevVal);
      return setIn(obj, path2, nextVal);
    }
    function merge(a, b, c, d2, e, f, ...rest) {
      return rest.length ? doMerge.call(null, false, false, a, b, c, d2, e, f, ...rest) : doMerge(false, false, a, b, c, d2, e, f);
    }
    function mergeDeep(a, b, c, d2, e, f, ...rest) {
      return rest.length ? doMerge.call(null, false, true, a, b, c, d2, e, f, ...rest) : doMerge(false, true, a, b, c, d2, e, f);
    }
    function mergeIn(a, path2, b, c, d2, e, f, ...rest) {
      let prevVal = getIn(a, path2);
      if (prevVal == null)
        prevVal = {};
      let nextVal;
      if (rest.length) {
        nextVal = doMerge.call(null, false, false, prevVal, b, c, d2, e, f, ...rest);
      } else {
        nextVal = doMerge(false, false, prevVal, b, c, d2, e, f);
      }
      return setIn(a, path2, nextVal);
    }
    function omit(obj, attrs) {
      const omitList = Array.isArray(attrs) ? attrs : [attrs];
      let fDoSomething = false;
      for (let i = 0; i < omitList.length; i++) {
        if (hasOwnProperty.call(obj, omitList[i])) {
          fDoSomething = true;
          break;
        }
      }
      if (!fDoSomething)
        return obj;
      const out = {};
      const keys = getKeysAndSymbols(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (omitList.indexOf(key) >= 0)
          continue;
        out[key] = obj[key];
      }
      return out;
    }
    function addDefaults(a, b, c, d2, e, f, ...rest) {
      return rest.length ? doMerge.call(null, true, false, a, b, c, d2, e, f, ...rest) : doMerge(true, false, a, b, c, d2, e, f);
    }
    function doMerge(fAddDefaults, fDeep, first, ...rest) {
      let out = first;
      if (!(out != null)) {
        throwStr(IS_DEV ? "At least one object should be provided to merge()" : INVALID_ARGS);
      }
      let fChanged = false;
      for (let idx = 0; idx < rest.length; idx++) {
        const obj = rest[idx];
        if (obj == null)
          continue;
        const keys = getKeysAndSymbols(obj);
        if (!keys.length)
          continue;
        for (let j = 0; j <= keys.length; j++) {
          const key = keys[j];
          if (fAddDefaults && out[key] !== void 0)
            continue;
          let nextVal = obj[key];
          if (fDeep && isObject2(out[key]) && isObject2(nextVal)) {
            nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
          }
          if (nextVal === void 0 || nextVal === out[key])
            continue;
          if (!fChanged) {
            fChanged = true;
            out = clone2(out);
          }
          out[key] = nextVal;
        }
      }
      return out;
    }
    var timm = {
      clone: clone2,
      addLast,
      addFirst,
      removeLast,
      removeFirst,
      insert,
      removeAt,
      replaceAt,
      getIn,
      set,
      setIn,
      update,
      updateIn,
      merge,
      mergeDeep,
      mergeIn,
      omit,
      addDefaults
    };
    var _default = timm;
    exports.default = _default;
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports, module) {
    init_shims();
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image2, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeAPP1(image2.exifBuffer);
        writeDQT();
        writeSOF0(image2.width, image2.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image2.data;
        var width = image2.width;
        var height = image2.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init2() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init2();
    }
    if (typeof module !== "undefined") {
      module.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports, module) {
    init_shims();
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s2 = rs & 15, r = rs >> 4;
                if (s2 === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s2 !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s2);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load2(path2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path2, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse3(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module !== "undefined") {
      module.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        maxMemoryUsageInMB: 512
      };
      var opts = __spreadValues(__spreadValues({}, defaultOpts), userOpts);
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image2 = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image2["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image2, opts.formatAsRGBA);
      return image2;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports, module) {
    init_shims();
    var encode = require_encoder();
    var decode = require_decoder();
    module.exports = {
      encode,
      decode
    };
  }
});

// node_modules/@jimp/jpeg/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@jimp/jpeg/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _jpegJs = _interopRequireDefault(require_jpeg_js());
    var _utils = require_dist();
    var MIME_TYPE = "image/jpeg";
    var _default = function _default2() {
      return {
        mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["jpeg", "jpg", "jpe"]),
        constants: {
          MIME_JPEG: MIME_TYPE
        },
        decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _jpegJs["default"].decode),
        encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image2) {
          return _jpegJs["default"].encode(image2.bitmap, image2._quality).data;
        }),
        "class": {
          _quality: 100,
          quality: function quality(n, cb) {
            if (typeof n !== "number") {
              return _utils.throwError.call(this, "n must be a number", cb);
            }
            if (n < 0 || n > 100) {
              return _utils.throwError.call(this, "n must be a number 0 - 100", cb);
            }
            this._quality = Math.round(n);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/chunkstream.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var ChunkStream = module.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      var dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = new Buffer(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read2) {
      this._reads.shift();
      var smallerBuf = this._buffers[0];
      if (smallerBuf.length > read2.length) {
        this._buffered -= read2.length;
        this._buffers[0] = smallerBuf.slice(read2.length);
        read2.func.call(this, smallerBuf.slice(0, read2.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read2.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read2) {
      this._reads.shift();
      var pos = 0;
      var count = 0;
      var data = new Buffer(read2.length);
      while (pos < read2.length) {
        var buf = this._buffers[count++];
        var len = Math.min(buf.length, read2.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read2.length;
      read2.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          var read2 = this._reads[0];
          if (read2.allowLess) {
            this._processReadAllowingLess(read2);
          } else if (this._buffered >= read2.length) {
            this._processRead(read2);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/interlace.js"(exports) {
    init_shims();
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      var images = [];
      var xLeftOver = width % 8;
      var yLeftOver = height % 8;
      var xRepeats = (width - xLeftOver) / 8;
      var yRepeats = (height - yLeftOver) / 8;
      for (var i = 0; i < imagePasses.length; i++) {
        var pass = imagePasses[i];
        var passWidth = xRepeats * pass.x.length;
        var passHeight = yRepeats * pass.y.length;
        for (var j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length;
        var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        var outerYLeftOver = y % imagePasses[pass].y.length;
        var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/paeth-predictor.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = function paethPredictor(left, above, upLeft) {
      var paeth = left + above - upLeft;
      var pLeft = Math.abs(paeth - left);
      var pAbove = Math.abs(paeth - above);
      var pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse.js"(exports, module) {
    init_shims();
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      var byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module.exports = function(bitmapInfo, dependencies) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var interlace = bitmapInfo.interlace;
      var bpp = bitmapInfo.bpp;
      var depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        var passes = interlaceUtils.getImagePasses(width, height);
        for (var i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f3Up = lastLine ? lastLine[x] : 0;
        var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f4Up = lastLine ? lastLine[x] : 0;
        var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      var filter = rawData[0];
      var unfilteredLine;
      var currentImage = this._images[this._imageIndex];
      var byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = new Buffer(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      var buffers = [];
      var that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/constants.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/crc.js"(exports, module) {
    init_shims();
    "use strict";
    var crcTable = [];
    (function() {
      for (var i = 0; i < 256; i++) {
        var currentCrc = i;
        for (var j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (var i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      var crc = -1;
      for (var i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/parser.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants2();
    var CrcCalculator = require_crc();
    var Parser = module.exports = function(options2, dependencies) {
      this._options = options2;
      options2.checkCRC = options2.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      var signature = constants.PNG_SIGNATURE;
      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      var length = data.readUInt32BE(0);
      var type = data.readUInt32BE(4);
      var name = "";
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      var ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(new Buffer(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9];
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      var entries = Math.floor(data.length / 3);
      for (var i = 0; i < entries; i++) {
        this._palette.push([
          data[i * 3],
          data[i * 3 + 1],
          data[i * 3 + 2],
          255
        ]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      var leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/bitmapper.js"(exports) {
    init_shims();
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      var leftOver = [];
      var i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        var byte = data[i];
        i++;
        var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          var returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image2, pxData, getPxPos, bpp, data, rawPos) {
      var imageWidth = image2.width;
      var imageHeight = image2.height;
      var imagePass = image2.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image2, pxData, getPxPos, bpp, bits, maxBit) {
      var imageWidth = image2.width;
      var imageHeight = image2.height;
      var imagePass = image2.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pixelData = bits.get(bpp);
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var depth = bitmapInfo.depth;
      var bpp = bitmapInfo.bpp;
      var interlace = bitmapInfo.interlace;
      if (depth !== 8) {
        var bits = bitRetriever(data, depth);
      }
      var pxData;
      if (depth <= 8) {
        pxData = new Buffer(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      var maxBit = Math.pow(2, depth) - 1;
      var rawPos = 0;
      var images;
      var getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
          var returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/format-normaliser.js"(exports, module) {
    init_shims();
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      var maxOutSample = 255;
      var maxInSample = Math.pow(2, depth) - 1;
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module.exports = function(indata, imageData) {
      var depth = imageData.depth;
      var width = imageData.width;
      var height = imageData.height;
      var colorType = imageData.colorType;
      var transColor = imageData.transColor;
      var palette = imageData.palette;
      var outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = new Buffer(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/parser-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var zlib2 = __require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module.exports = function(options2) {
      ChunkStream.call(this);
      this._parser = new Parser(options2, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options2;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          var imageSize = rowSize * this._bitmapInfo.height;
          var chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          var leftToInflate = imageSize;
          var emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          var filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
      this.destroySoon();
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      try {
        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/bitpacker.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants2();
    module.exports = function(dataIn, width, height, options2) {
      var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options2.colorType) !== -1;
      if (options2.colorType === options2.inputColorType) {
        var bigEndian = function() {
          var buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options2.bitDepth === 8 || options2.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      var data = options2.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      var maxValue = 255;
      var inBpp = constants.COLORTYPE_TO_BPP_MAP[options2.inputColorType];
      if (inBpp === 4 && !options2.inputHasAlpha) {
        inBpp = 3;
      }
      var outBpp = constants.COLORTYPE_TO_BPP_MAP[options2.colorType];
      if (options2.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      var outData = new Buffer(width * height * outBpp);
      var inIndex = 0;
      var outIndex = 0;
      var bgColor = options2.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        var red;
        var green;
        var blue;
        var alpha = maxValue;
        switch (options2.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options2.inputColorType + " is not supported at present");
        }
        if (options2.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var rgba = getRGBA(data, inIndex);
          switch (options2.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options2.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE:
              var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options2.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            default:
              throw new Error("unrecognised color Type " + options2.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/filter-pack.js"(exports, module) {
    init_shims();
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var x = pxPos; x < length; x++) {
        var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        var val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module.exports = function(pxData, width, height, options2, bpp) {
      var filterTypes;
      if (!("filterType" in options2) || options2.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options2.filterType === "number") {
        filterTypes = [options2.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options2.bitDepth === 16) {
        bpp *= 2;
      }
      var byteWidth = width * bpp;
      var rawPos = 0;
      var pxPos = 0;
      var rawData = new Buffer((byteWidth + 1) * height);
      var sel = filterTypes[0];
      for (var y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          var min = Infinity;
          for (var i = 0; i < filterTypes.length; i++) {
            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/packer.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants2();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = __require("zlib");
    var Packer = module.exports = function(options2) {
      this._options = options2;
      options2.deflateChunkSize = options2.deflateChunkSize || 32 * 1024;
      options2.deflateLevel = options2.deflateLevel != null ? options2.deflateLevel : 9;
      options2.deflateStrategy = options2.deflateStrategy != null ? options2.deflateStrategy : 3;
      options2.inputHasAlpha = options2.inputHasAlpha != null ? options2.inputHasAlpha : true;
      options2.deflateFactory = options2.deflateFactory || zlib2.createDeflate;
      options2.bitDepth = options2.bitDepth || 8;
      options2.colorType = typeof options2.colorType === "number" ? options2.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options2.inputColorType = typeof options2.inputColorType === "number" ? options2.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.colorType) === -1) {
        throw new Error("option color type:" + options2.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.inputColorType) === -1) {
        throw new Error("option input color type:" + options2.inputColorType + " is not supported at present");
      }
      if (options2.bitDepth !== 8 && options2.bitDepth !== 16) {
        throw new Error("option bit depth:" + options2.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      var packedData = bitPacker(data, width, height, this._options);
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      var filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      var len = data ? data.length : 0;
      var buf = new Buffer(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      var buf = new Buffer(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      var buf = new Buffer(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/packer-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var constants = require_constants2();
    var Packer = require_packer();
    var PackerAsync = module.exports = function(opt) {
      Stream2.call(this);
      var options2 = opt || {};
      this._packer = new Packer(options2);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", new Buffer(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      var filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/sync-inflate.js"(exports, module) {
    init_shims();
    "use strict";
    var assert = __require("assert").ok;
    var zlib2 = __require("zlib");
    var util = __require("util");
    var kMaxLength = __require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      var self2 = this;
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var leftToInflate = this._maxLength;
      var inOff = 0;
      var buffers = [];
      var nread = 0;
      var error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      var buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      var flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/sync-reader.js"(exports, module) {
    init_shims();
    "use strict";
    var SyncReader = module.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        var read2 = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
          this._reads.shift();
          var buf = this._buffer;
          this._buffer = buf.slice(read2.length);
          read2.func.call(this, buf.slice(0, read2.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    init_shims();
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      var outBuffers = [];
      var reader = new SyncReader(inBuffer);
      var filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/parser-sync.js"(exports, module) {
    init_shims();
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = __require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module.exports = function(buffer, options2) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var err;
      function handleError(_err_) {
        err = _err_;
      }
      var metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      var gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      var inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      var reader = new SyncReader(buffer);
      var parser = new Parser(options2, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      var inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      var inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        var imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      var unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/packer-sync.js"(exports, module) {
    init_shims();
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = __require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants2();
    var Packer = require_packer();
    module.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var options2 = opt || {};
      var packer = new Packer(options2);
      var chunks = [];
      chunks.push(new Buffer(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      var compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/png-sync.js"(exports) {
    init_shims();
    "use strict";
    var parse3 = require_parser_sync();
    var pack = require_packer_sync();
    exports.read = function(buffer, options2) {
      return parse3(buffer, options2 || {});
    };
    exports.write = function(png, options2) {
      return pack(png, options2);
    };
  }
});

// node_modules/@jimp/png/node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/@jimp/png/node_modules/pngjs/lib/png.js"(exports) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports.PNG = function(options2) {
      Stream2.call(this);
      options2 = options2 || {};
      this.width = options2.width | 0;
      this.height = options2.height | 0;
      this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
      if (options2.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options2);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options2);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        var onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (var y = 0; y < height; y++) {
        src2.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src2.width + srcX << 2, (srcY + y) * src2.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src2) {
      if (src2.gamma) {
        for (var y = 0; y < src2.height; y++) {
          for (var x = 0; x < src2.width; x++) {
            var idx = src2.width * y + x << 2;
            for (var i = 0; i < 3; i++) {
              var sample = src2.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
              src2.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src2.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/@jimp/png/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@jimp/png/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _pngjs = require_png();
    var _utils = require_dist();
    var MIME_TYPE = "image/png";
    var PNG_FILTER_AUTO = -1;
    var PNG_FILTER_NONE = 0;
    var PNG_FILTER_SUB = 1;
    var PNG_FILTER_UP = 2;
    var PNG_FILTER_AVERAGE = 3;
    var PNG_FILTER_PATH = 4;
    var _default = function _default2() {
      return {
        mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["png"]),
        constants: {
          MIME_PNG: MIME_TYPE,
          PNG_FILTER_AUTO,
          PNG_FILTER_NONE,
          PNG_FILTER_SUB,
          PNG_FILTER_UP,
          PNG_FILTER_AVERAGE,
          PNG_FILTER_PATH
        },
        hasAlpha: (0, _defineProperty2["default"])({}, MIME_TYPE, true),
        decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _pngjs.PNG.sync.read),
        encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
          var png = new _pngjs.PNG({
            width: data.bitmap.width,
            height: data.bitmap.height
          });
          png.data = data.bitmap.data;
          return _pngjs.PNG.sync.write(png, {
            width: data.bitmap.width,
            height: data.bitmap.height,
            deflateLevel: data._deflateLevel,
            deflateStrategy: data._deflateStrategy,
            filterType: data._filterType,
            colorType: typeof data._colorType === "number" ? data._colorType : data._rgba ? 6 : 2,
            inputHasAlpha: data._rgba
          });
        }),
        "class": {
          _deflateLevel: 9,
          _deflateStrategy: 3,
          _filterType: PNG_FILTER_AUTO,
          _colorType: null,
          deflateLevel: function deflateLevel(l, cb) {
            if (typeof l !== "number") {
              return _utils.throwError.call(this, "l must be a number", cb);
            }
            if (l < 0 || l > 9) {
              return _utils.throwError.call(this, "l must be a number 0 - 9", cb);
            }
            this._deflateLevel = Math.round(l);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          },
          deflateStrategy: function deflateStrategy(s2, cb) {
            if (typeof s2 !== "number") {
              return _utils.throwError.call(this, "s must be a number", cb);
            }
            if (s2 < 0 || s2 > 3) {
              return _utils.throwError.call(this, "s must be a number 0 - 3", cb);
            }
            this._deflateStrategy = Math.round(s2);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          },
          filterType: function filterType(f, cb) {
            if (typeof f !== "number") {
              return _utils.throwError.call(this, "n must be a number", cb);
            }
            if (f < -1 || f > 4) {
              return _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb);
            }
            this._filterType = Math.round(f);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          },
          colorType: function colorType(s2, cb) {
            if (typeof s2 !== "number") {
              return _utils.throwError.call(this, "s must be a number", cb);
            }
            if (s2 !== 0 && s2 !== 2 && s2 !== 4 && s2 !== 6) {
              return _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb);
            }
            this._colorType = Math.round(s2);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/bmp-js/lib/encoder.js
var require_encoder2 = __commonJS({
  "node_modules/bmp-js/lib/encoder.js"(exports, module) {
    init_shims();
    function BmpEncoder(imgData) {
      this.buffer = imgData.data;
      this.width = imgData.width;
      this.height = imgData.height;
      this.extraBytes = this.width % 4;
      this.rgbSize = this.height * (3 * this.width + this.extraBytes);
      this.headerInfoSize = 40;
      this.data = [];
      this.flag = "BM";
      this.reserved = 0;
      this.offset = 54;
      this.fileSize = this.rgbSize + this.offset;
      this.planes = 1;
      this.bitPP = 24;
      this.compress = 0;
      this.hr = 0;
      this.vr = 0;
      this.colors = 0;
      this.importantColors = 0;
    }
    BmpEncoder.prototype.encode = function() {
      var tempBuffer = new Buffer(this.offset + this.rgbSize);
      this.pos = 0;
      tempBuffer.write(this.flag, this.pos, 2);
      this.pos += 2;
      tempBuffer.writeUInt32LE(this.fileSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.reserved, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.offset, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.width, this.pos);
      this.pos += 4;
      tempBuffer.writeInt32LE(-this.height, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt16LE(this.planes, this.pos);
      this.pos += 2;
      tempBuffer.writeUInt16LE(this.bitPP, this.pos);
      this.pos += 2;
      tempBuffer.writeUInt32LE(this.compress, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.rgbSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.hr, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.vr, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.colors, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.importantColors, this.pos);
      this.pos += 4;
      var i = 0;
      var rowBytes = 3 * this.width + this.extraBytes;
      for (var y = 0; y < this.height; y++) {
        for (var x = 0; x < this.width; x++) {
          var p = this.pos + y * rowBytes + x * 3;
          i++;
          tempBuffer[p] = this.buffer[i++];
          tempBuffer[p + 1] = this.buffer[i++];
          tempBuffer[p + 2] = this.buffer[i++];
        }
        if (this.extraBytes > 0) {
          var fillOffset = this.pos + y * rowBytes + this.width * 3;
          tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
        }
      }
      return tempBuffer;
    };
    module.exports = function(imgData, quality) {
      if (typeof quality === "undefined")
        quality = 100;
      var encoder = new BmpEncoder(imgData);
      var data = encoder.encode();
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    };
  }
});

// node_modules/bmp-js/lib/decoder.js
var require_decoder2 = __commonJS({
  "node_modules/bmp-js/lib/decoder.js"(exports, module) {
    init_shims();
    function BmpDecoder(buffer, is_with_alpha) {
      this.pos = 0;
      this.buffer = buffer;
      this.is_with_alpha = !!is_with_alpha;
      this.bottom_up = true;
      this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
      if (this.flag != "BM")
        throw new Error("Invalid BMP File");
      this.parseHeader();
      this.parseRGBA();
    }
    BmpDecoder.prototype.parseHeader = function() {
      this.fileSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.reserved = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.offset = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.headerSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.width = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.height = this.buffer.readInt32LE(this.pos);
      this.pos += 4;
      this.planes = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.bitPP = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.compress = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.rawSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.hr = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.vr = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.colors = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.importantColors = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      if (this.bitPP === 16 && this.is_with_alpha) {
        this.bitPP = 15;
      }
      if (this.bitPP < 15) {
        var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
        this.palette = new Array(len);
        for (var i = 0; i < len; i++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var quad = this.buffer.readUInt8(this.pos++);
          this.palette[i] = {
            red,
            green,
            blue,
            quad
          };
        }
      }
      if (this.height < 0) {
        this.height *= -1;
        this.bottom_up = false;
      }
    };
    BmpDecoder.prototype.parseRGBA = function() {
      var bitn = "bit" + this.bitPP;
      var len = this.width * this.height * 4;
      this.data = new Buffer(len);
      this[bitn]();
    };
    BmpDecoder.prototype.bit1 = function() {
      var xlen = Math.ceil(this.width / 8);
      var mode = xlen % 4;
      var y = this.height >= 0 ? this.height - 1 : -this.height;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < xlen; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 8 * 4;
          for (var i = 0; i < 8; i++) {
            if (x * 8 + i < this.width) {
              var rgb = this.palette[b >> 7 - i & 1];
              this.data[location + i * 4] = 0;
              this.data[location + i * 4 + 1] = rgb.blue;
              this.data[location + i * 4 + 2] = rgb.green;
              this.data[location + i * 4 + 3] = rgb.red;
            } else {
              break;
            }
          }
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    };
    BmpDecoder.prototype.bit4 = function() {
      if (this.compress == 2) {
        let setPixelData2 = function(rgbIndex) {
          var rgb2 = this.palette[rgbIndex];
          this.data[location] = 0;
          this.data[location + 1] = rgb2.blue;
          this.data[location + 2] = rgb2.green;
          this.data[location + 3] = rgb2.red;
          location += 4;
        };
        var setPixelData = setPixelData2;
        this.data.fill(255);
        var location = 0;
        var lines = this.bottom_up ? this.height - 1 : 0;
        var low_nibble = false;
        while (location < this.data.length) {
          var a = this.buffer.readUInt8(this.pos++);
          var b = this.buffer.readUInt8(this.pos++);
          if (a == 0) {
            if (b == 0) {
              if (this.bottom_up) {
                lines--;
              } else {
                lines++;
              }
              location = lines * this.width * 4;
              low_nibble = false;
              continue;
            } else if (b == 1) {
              break;
            } else if (b == 2) {
              var x = this.buffer.readUInt8(this.pos++);
              var y = this.buffer.readUInt8(this.pos++);
              if (this.bottom_up) {
                lines -= y;
              } else {
                lines += y;
              }
              location += y * this.width * 4 + x * 4;
            } else {
              var c = this.buffer.readUInt8(this.pos++);
              for (var i = 0; i < b; i++) {
                if (low_nibble) {
                  setPixelData2.call(this, c & 15);
                } else {
                  setPixelData2.call(this, (c & 240) >> 4);
                }
                if (i & 1 && i + 1 < b) {
                  c = this.buffer.readUInt8(this.pos++);
                }
                low_nibble = !low_nibble;
              }
              if ((b + 1 >> 1 & 1) == 1) {
                this.pos++;
              }
            }
          } else {
            for (var i = 0; i < a; i++) {
              if (low_nibble) {
                setPixelData2.call(this, b & 15);
              } else {
                setPixelData2.call(this, (b & 240) >> 4);
              }
              low_nibble = !low_nibble;
            }
          }
        }
      } else {
        var xlen = Math.ceil(this.width / 2);
        var mode = xlen % 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < xlen; x++) {
            var b = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 2 * 4;
            var before = b >> 4;
            var after = b & 15;
            var rgb = this.palette[before];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
            if (x * 2 + 1 >= this.width)
              break;
            rgb = this.palette[after];
            this.data[location + 4] = 0;
            this.data[location + 4 + 1] = rgb.blue;
            this.data[location + 4 + 2] = rgb.green;
            this.data[location + 4 + 3] = rgb.red;
          }
          if (mode != 0) {
            this.pos += 4 - mode;
          }
        }
      }
    };
    BmpDecoder.prototype.bit8 = function() {
      if (this.compress == 1) {
        let setPixelData2 = function(rgbIndex) {
          var rgb2 = this.palette[rgbIndex];
          this.data[location] = 0;
          this.data[location + 1] = rgb2.blue;
          this.data[location + 2] = rgb2.green;
          this.data[location + 3] = rgb2.red;
          location += 4;
        };
        var setPixelData = setPixelData2;
        this.data.fill(255);
        var location = 0;
        var lines = this.bottom_up ? this.height - 1 : 0;
        while (location < this.data.length) {
          var a = this.buffer.readUInt8(this.pos++);
          var b = this.buffer.readUInt8(this.pos++);
          if (a == 0) {
            if (b == 0) {
              if (this.bottom_up) {
                lines--;
              } else {
                lines++;
              }
              location = lines * this.width * 4;
              continue;
            } else if (b == 1) {
              break;
            } else if (b == 2) {
              var x = this.buffer.readUInt8(this.pos++);
              var y = this.buffer.readUInt8(this.pos++);
              if (this.bottom_up) {
                lines -= y;
              } else {
                lines += y;
              }
              location += y * this.width * 4 + x * 4;
            } else {
              for (var i = 0; i < b; i++) {
                var c = this.buffer.readUInt8(this.pos++);
                setPixelData2.call(this, c);
              }
              if (b & true) {
                this.pos++;
              }
            }
          } else {
            for (var i = 0; i < a; i++) {
              setPixelData2.call(this, b);
            }
          }
        }
      } else {
        var mode = this.width % 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var b = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            if (b < this.palette.length) {
              var rgb = this.palette[b];
              this.data[location] = 0;
              this.data[location + 1] = rgb.blue;
              this.data[location + 2] = rgb.green;
              this.data[location + 3] = rgb.red;
            } else {
              this.data[location] = 0;
              this.data[location + 1] = 255;
              this.data[location + 2] = 255;
              this.data[location + 3] = 255;
            }
          }
          if (mode != 0) {
            this.pos += 4 - mode;
          }
        }
      }
    };
    BmpDecoder.prototype.bit15 = function() {
      var dif_w = this.width % 3;
      var _11111 = parseInt("11111", 2), _1_5 = _11111;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var B = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var blue = (B & _1_5) / _1_5 * 255 | 0;
          var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
          var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
          var alpha = B >> 15 ? 255 : 0;
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += dif_w;
      }
    };
    BmpDecoder.prototype.bit16 = function() {
      var dif_w = this.width % 2 * 2;
      this.maskRed = 31744;
      this.maskGreen = 992;
      this.maskBlue = 31;
      this.mask0 = 0;
      if (this.compress == 3) {
        this.maskRed = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskGreen = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskBlue = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.mask0 = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
      }
      var ns = [0, 0, 0];
      for (var i = 0; i < 16; i++) {
        if (this.maskRed >> i & 1)
          ns[0]++;
        if (this.maskGreen >> i & 1)
          ns[1]++;
        if (this.maskBlue >> i & 1)
          ns[2]++;
      }
      ns[1] += ns[0];
      ns[2] += ns[1];
      ns[0] = 8 - ns[0];
      ns[1] -= 8;
      ns[2] -= 8;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var B = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var blue = (B & this.maskBlue) << ns[0];
          var green = (B & this.maskGreen) >> ns[1];
          var red = (B & this.maskRed) >> ns[2];
          var location = line * this.width * 4 + x * 4;
          this.data[location] = 0;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += dif_w;
      }
    };
    BmpDecoder.prototype.bit24 = function() {
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = 0;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += this.width % 4;
      }
    };
    BmpDecoder.prototype.bit32 = function() {
      if (this.compress == 3) {
        this.maskRed = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskGreen = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskBlue = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.mask0 = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var alpha = this.buffer.readUInt8(this.pos++);
            var blue = this.buffer.readUInt8(this.pos++);
            var green = this.buffer.readUInt8(this.pos++);
            var red = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            this.data[location] = alpha;
            this.data[location + 1] = blue;
            this.data[location + 2] = green;
            this.data[location + 3] = red;
          }
        }
      } else {
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var blue = this.buffer.readUInt8(this.pos++);
            var green = this.buffer.readUInt8(this.pos++);
            var red = this.buffer.readUInt8(this.pos++);
            var alpha = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            this.data[location] = alpha;
            this.data[location + 1] = blue;
            this.data[location + 2] = green;
            this.data[location + 3] = red;
          }
        }
      }
    };
    BmpDecoder.prototype.getData = function() {
      return this.data;
    };
    module.exports = function(bmpData) {
      var decoder = new BmpDecoder(bmpData);
      return decoder;
    };
  }
});

// node_modules/bmp-js/index.js
var require_bmp_js = __commonJS({
  "node_modules/bmp-js/index.js"(exports, module) {
    init_shims();
    var encode = require_encoder2();
    var decode = require_decoder2();
    module.exports = {
      encode,
      decode
    };
  }
});

// node_modules/@jimp/bmp/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@jimp/bmp/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _bmpJs = _interopRequireDefault(require_bmp_js());
    var _utils = require_dist();
    var MIME_TYPE = "image/bmp";
    var MIME_TYPE_SECOND = "image/x-ms-bmp";
    function toAGBR(image2) {
      return (0, _utils.scan)(image2, 0, 0, image2.bitmap.width, image2.bitmap.height, function(x, y, index2) {
        var red = this.bitmap.data[index2 + 0];
        var green = this.bitmap.data[index2 + 1];
        var blue = this.bitmap.data[index2 + 2];
        var alpha = this.bitmap.data[index2 + 3];
        this.bitmap.data[index2 + 0] = alpha;
        this.bitmap.data[index2 + 1] = blue;
        this.bitmap.data[index2 + 2] = green;
        this.bitmap.data[index2 + 3] = red;
      }).bitmap;
    }
    function fromAGBR(bitmap) {
      return (0, _utils.scan)({
        bitmap
      }, 0, 0, bitmap.width, bitmap.height, function(x, y, index2) {
        var alpha = this.bitmap.data[index2 + 0];
        var blue = this.bitmap.data[index2 + 1];
        var green = this.bitmap.data[index2 + 2];
        var red = this.bitmap.data[index2 + 3];
        this.bitmap.data[index2 + 0] = red;
        this.bitmap.data[index2 + 1] = green;
        this.bitmap.data[index2 + 2] = blue;
        this.bitmap.data[index2 + 3] = bitmap.is_with_alpha ? alpha : 255;
      }).bitmap;
    }
    var decode = function decode2(data) {
      return fromAGBR(_bmpJs["default"].decode(data));
    };
    var encode = function encode2(image2) {
      return _bmpJs["default"].encode(toAGBR(image2)).data;
    };
    var _default = function _default2() {
      var _decoders, _encoders;
      return {
        mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["bmp"]),
        constants: {
          MIME_BMP: MIME_TYPE,
          MIME_X_MS_BMP: MIME_TYPE_SECOND
        },
        decoders: (_decoders = {}, (0, _defineProperty2["default"])(_decoders, MIME_TYPE, decode), (0, _defineProperty2["default"])(_decoders, MIME_TYPE_SECOND, decode), _decoders),
        encoders: (_encoders = {}, (0, _defineProperty2["default"])(_encoders, MIME_TYPE, encode), (0, _defineProperty2["default"])(_encoders, MIME_TYPE_SECOND, encode), _encoders)
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    init_shims();
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    init_shims();
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits(s2, value, length) {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    }
    function send_code(s2, c, tree) {
      send_bits(s2, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base2 = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h = s2.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s2.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n >= base2) {
          xbits = extra[n - base2];
        }
        f = tree[n * 2];
        s2.opt_len += f * (bits + xbits);
        if (has_stree) {
          s2.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s2.bl_count[bits];
        while (n !== 0) {
          m = s2.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s2, tree, k) {
      var v = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller(tree, v, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s2, tree, n);
      }
      node = elems;
      do {
        n = s2.heap[1];
        s2.heap[1] = s2.heap[s2.heap_len--];
        pqdownheap(s2, tree, 1);
        m = s2.heap[1];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n] >= s2.depth[m] ? s2.depth[n] : s2.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[1] = node++;
        pqdownheap(s2, tree, 1);
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[1];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    init_shims();
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    init_shims();
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    init_shims();
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b) {
      s2.pending_buf[s2.pending++] = b;
    }
    function putShortMSB(s2, b) {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p, n, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n = s2.hash_size;
          p = n;
          do {
            m = s2.head[--p];
            s2.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s2.prev[--p];
            s2.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    init_shims();
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    init_shims();
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    init_shims();
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options2) {
      if (!(this instanceof Deflate))
        return new Deflate(options2);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options2 || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options2) {
      var deflator = new Deflate(options2);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options2) {
      options2 = options2 || {};
      options2.raw = true;
      return deflate(input, options2);
    }
    function gzip(input, options2) {
      options2 = options2 || {};
      options2.gzip = true;
      return deflate(input, options2);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    init_shims();
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    init_shims();
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base2 = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base2 = extra = work;
        end = 19;
      } else if (type === LENS) {
        base2 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base2 = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base2[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    init_shims();
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME2 = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src2, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src2, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src2, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len);
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME2;
            case NAME2:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants3 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    init_shims();
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    init_shims();
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants3();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options2) {
      if (!(this instanceof Inflate))
        return new Inflate(options2);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options2 || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options2) {
      var inflator = new Inflate(options2);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options2) {
      options2 = options2 || {};
      options2.raw = true;
      return inflate(input, options2);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    init_shims();
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants3();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }
});

// node_modules/utif/UTIF.js
var require_UTIF = __commonJS({
  "node_modules/utif/UTIF.js"(exports, module) {
    init_shims();
    (function() {
      var UTIF = {};
      if (typeof module == "object") {
        module.exports = UTIF;
      } else {
        self.UTIF = UTIF;
      }
      var pako;
      if (typeof __require == "function") {
        pako = require_pako();
      } else {
        pako = self.pako;
      }
      function log() {
        if (typeof process == "undefined" || process.env.NODE_ENV == "development")
          console.log.apply(console, arguments);
      }
      (function(UTIF2, pako2) {
        (function() {
          var V = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol === "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, D = function() {
            function g(g2) {
              this.message = "JPEG error: " + g2;
            }
            g.prototype = Error();
            g.prototype.name = "JpegError";
            return g.constructor = g;
          }(), P = function() {
            function g(g2, D2) {
              this.message = g2;
              this.g = D2;
            }
            g.prototype = Error();
            g.prototype.name = "DNLMarkerError";
            return g.constructor = g;
          }();
          (function() {
            function g() {
              this.M = null;
              this.B = -1;
            }
            function W(a, d2) {
              for (var f = 0, e = [], b, B, k = 16; 0 < k && !a[k - 1]; )
                k--;
              e.push({ children: [], index: 0 });
              var l = e[0], r;
              for (b = 0; b < k; b++) {
                for (B = 0; B < a[b]; B++) {
                  l = e.pop();
                  for (l.children[l.index] = d2[f]; 0 < l.index; )
                    l = e.pop();
                  l.index++;
                  for (e.push(l); e.length <= b; )
                    e.push(r = { children: [], index: 0 }), l.children[l.index] = r.children, l = r;
                  f++;
                }
                b + 1 < k && (e.push(r = { children: [], index: 0 }), l.children[l.index] = r.children, l = r);
              }
              return e[0].children;
            }
            function X(a, d2, f, e, b, B, k, l, r) {
              function n() {
                if (0 < x)
                  return x--, z >> x & 1;
                z = a[d2++];
                if (z === 255) {
                  var c2 = a[d2++];
                  if (c2) {
                    if (c2 === 220 && g2) {
                      d2 += 2;
                      var b2 = a[d2++] << 8 | a[d2++];
                      if (0 < b2 && b2 !== f.g)
                        throw new P("Found DNL marker (0xFFDC) while parsing scan data", b2);
                    }
                    throw new D("unexpected marker " + (z << 8 | c2).toString(16));
                  }
                }
                x = 7;
                return z >>> 7;
              }
              function q(a2) {
                for (; ; ) {
                  a2 = a2[n()];
                  if (typeof a2 === "number")
                    return a2;
                  if ((typeof a2 === "undefined" ? "undefined" : V(a2)) !== "object")
                    throw new D("invalid huffman sequence");
                }
              }
              function h(a2) {
                for (var c2 = 0; 0 < a2; )
                  c2 = c2 << 1 | n(), a2--;
                return c2;
              }
              function c(a2) {
                if (a2 === 1)
                  return n() === 1 ? 1 : -1;
                var c2 = h(a2);
                return c2 >= 1 << a2 - 1 ? c2 : c2 + (-1 << a2) + 1;
              }
              function C(a2, b2) {
                var d3 = q(a2.D);
                d3 = d3 === 0 ? 0 : c(d3);
                a2.a[b2] = a2.m += d3;
                for (d3 = 1; 64 > d3; ) {
                  var h2 = q(a2.o), k2 = h2 & 15;
                  h2 >>= 4;
                  if (k2 === 0) {
                    if (15 > h2)
                      break;
                    d3 += 16;
                  } else
                    d3 += h2, a2.a[b2 + J[d3]] = c(k2), d3++;
                }
              }
              function w(a2, d3) {
                var b2 = q(a2.D);
                b2 = b2 === 0 ? 0 : c(b2) << r;
                a2.a[d3] = a2.m += b2;
              }
              function p(a2, c2) {
                a2.a[c2] |= n() << r;
              }
              function m(a2, b2) {
                if (0 < A)
                  A--;
                else
                  for (var d3 = B; d3 <= k; ) {
                    var e2 = q(a2.o), f2 = e2 & 15;
                    e2 >>= 4;
                    if (f2 === 0) {
                      if (15 > e2) {
                        A = h(e2) + (1 << e2) - 1;
                        break;
                      }
                      d3 += 16;
                    } else
                      d3 += e2, a2.a[b2 + J[d3]] = c(f2) * (1 << r), d3++;
                  }
              }
              function t(a2, d3) {
                for (var b2 = B, e2 = 0, f2; b2 <= k; ) {
                  f2 = d3 + J[b2];
                  var l2 = 0 > a2.a[f2] ? -1 : 1;
                  switch (E) {
                    case 0:
                      e2 = q(a2.o);
                      f2 = e2 & 15;
                      e2 >>= 4;
                      if (f2 === 0)
                        15 > e2 ? (A = h(e2) + (1 << e2), E = 4) : (e2 = 16, E = 1);
                      else {
                        if (f2 !== 1)
                          throw new D("invalid ACn encoding");
                        Q = c(f2);
                        E = e2 ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (e2--, e2 === 0 && (E = E === 2 ? 3 : 0));
                      break;
                    case 3:
                      a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (a2.a[f2] = Q << r, E = 0);
                      break;
                    case 4:
                      a2.a[f2] && (a2.a[f2] += l2 * (n() << r));
                  }
                  b2++;
                }
                E === 4 && (A--, A === 0 && (E = 0));
              }
              var g2 = 9 < arguments.length && arguments[9] !== void 0 ? arguments[9] : false, u = f.P, v = d2, z = 0, x = 0, A = 0, E = 0, Q, K = e.length, F, L, M, I;
              var R = f.S ? B === 0 ? l === 0 ? w : p : l === 0 ? m : t : C;
              var G = 0;
              var O = K === 1 ? e[0].c * e[0].l : u * f.O;
              for (var S, T; G < O; ) {
                var U = b ? Math.min(O - G, b) : O;
                for (F = 0; F < K; F++)
                  e[F].m = 0;
                A = 0;
                if (K === 1) {
                  var y = e[0];
                  for (I = 0; I < U; I++)
                    R(y, 64 * ((y.c + 1) * (G / y.c | 0) + G % y.c)), G++;
                } else
                  for (I = 0; I < U; I++) {
                    for (F = 0; F < K; F++)
                      for (y = e[F], S = y.h, T = y.j, L = 0; L < T; L++)
                        for (M = 0; M < S; M++)
                          R(y, 64 * ((y.c + 1) * ((G / u | 0) * y.j + L) + (G % u * y.h + M)));
                    G++;
                  }
                x = 0;
                (y = N(a, d2)) && y.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + y.f), d2 = y.offset);
                y = y && y.F;
                if (!y || 65280 >= y)
                  throw new D("marker was not found");
                if (65488 <= y && 65495 >= y)
                  d2 += 2;
                else
                  break;
              }
              (y = N(a, d2)) && y.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + y.f), d2 = y.offset);
              return d2 - v;
            }
            function Y(a, d2) {
              for (var f = d2.c, e = d2.l, b = new Int16Array(64), B = 0; B < e; B++)
                for (var k = 0; k < f; k++) {
                  var l = 64 * ((d2.c + 1) * B + k), r = b, n = d2.G, q = d2.a;
                  if (!n)
                    throw new D("missing required Quantization Table.");
                  for (var h = 0; 64 > h; h += 8) {
                    var c = q[l + h];
                    var C = q[l + h + 1];
                    var w = q[l + h + 2];
                    var p = q[l + h + 3];
                    var m = q[l + h + 4];
                    var t = q[l + h + 5];
                    var g2 = q[l + h + 6];
                    var u = q[l + h + 7];
                    c *= n[h];
                    if ((C | w | p | m | t | g2 | u) === 0)
                      c = 5793 * c + 512 >> 10, r[h] = c, r[h + 1] = c, r[h + 2] = c, r[h + 3] = c, r[h + 4] = c, r[h + 5] = c, r[h + 6] = c, r[h + 7] = c;
                    else {
                      C *= n[h + 1];
                      w *= n[h + 2];
                      p *= n[h + 3];
                      m *= n[h + 4];
                      t *= n[h + 5];
                      g2 *= n[h + 6];
                      u *= n[h + 7];
                      var v = 5793 * c + 128 >> 8;
                      var z = 5793 * m + 128 >> 8;
                      var x = w;
                      var A = g2;
                      m = 2896 * (C - u) + 128 >> 8;
                      u = 2896 * (C + u) + 128 >> 8;
                      p <<= 4;
                      t <<= 4;
                      v = v + z + 1 >> 1;
                      z = v - z;
                      c = 3784 * x + 1567 * A + 128 >> 8;
                      x = 1567 * x - 3784 * A + 128 >> 8;
                      A = c;
                      m = m + t + 1 >> 1;
                      t = m - t;
                      u = u + p + 1 >> 1;
                      p = u - p;
                      v = v + A + 1 >> 1;
                      A = v - A;
                      z = z + x + 1 >> 1;
                      x = z - x;
                      c = 2276 * m + 3406 * u + 2048 >> 12;
                      m = 3406 * m - 2276 * u + 2048 >> 12;
                      u = c;
                      c = 799 * p + 4017 * t + 2048 >> 12;
                      p = 4017 * p - 799 * t + 2048 >> 12;
                      t = c;
                      r[h] = v + u;
                      r[h + 7] = v - u;
                      r[h + 1] = z + t;
                      r[h + 6] = z - t;
                      r[h + 2] = x + p;
                      r[h + 5] = x - p;
                      r[h + 3] = A + m;
                      r[h + 4] = A - m;
                    }
                  }
                  for (n = 0; 8 > n; ++n)
                    c = r[n], C = r[n + 8], w = r[n + 16], p = r[n + 24], m = r[n + 32], t = r[n + 40], g2 = r[n + 48], u = r[n + 56], (C | w | p | m | t | g2 | u) === 0 ? (c = 5793 * c + 8192 >> 14, c = -2040 > c ? 0 : 2024 <= c ? 255 : c + 2056 >> 4, q[l + n] = c, q[l + n + 8] = c, q[l + n + 16] = c, q[l + n + 24] = c, q[l + n + 32] = c, q[l + n + 40] = c, q[l + n + 48] = c, q[l + n + 56] = c) : (v = 5793 * c + 2048 >> 12, z = 5793 * m + 2048 >> 12, x = w, A = g2, m = 2896 * (C - u) + 2048 >> 12, u = 2896 * (C + u) + 2048 >> 12, v = (v + z + 1 >> 1) + 4112, z = v - z, c = 3784 * x + 1567 * A + 2048 >> 12, x = 1567 * x - 3784 * A + 2048 >> 12, A = c, m = m + t + 1 >> 1, t = m - t, u = u + p + 1 >> 1, p = u - p, v = v + A + 1 >> 1, A = v - A, z = z + x + 1 >> 1, x = z - x, c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, u = c, c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, t = c, c = v + u, u = v - u, C = z + t, g2 = z - t, w = x + p, t = x - p, p = A + m, m = A - m, c = 16 > c ? 0 : 4080 <= c ? 255 : c >> 4, C = 16 > C ? 0 : 4080 <= C ? 255 : C >> 4, w = 16 > w ? 0 : 4080 <= w ? 255 : w >> 4, p = 16 > p ? 0 : 4080 <= p ? 255 : p >> 4, m = 16 > m ? 0 : 4080 <= m ? 255 : m >> 4, t = 16 > t ? 0 : 4080 <= t ? 255 : t >> 4, g2 = 16 > g2 ? 0 : 4080 <= g2 ? 255 : g2 >> 4, u = 16 > u ? 0 : 4080 <= u ? 255 : u >> 4, q[l + n] = c, q[l + n + 8] = C, q[l + n + 16] = w, q[l + n + 24] = p, q[l + n + 32] = m, q[l + n + 40] = t, q[l + n + 48] = g2, q[l + n + 56] = u);
                }
              return d2.a;
            }
            function N(a, d2) {
              var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : d2, e = a.length - 1;
              f = f < d2 ? f : d2;
              if (d2 >= e)
                return null;
              var b = a[d2] << 8 | a[d2 + 1];
              if (65472 <= b && 65534 >= b)
                return { f: null, F: b, offset: d2 };
              for (var B = a[f] << 8 | a[f + 1]; !(65472 <= B && 65534 >= B); ) {
                if (++f >= e)
                  return null;
                B = a[f] << 8 | a[f + 1];
              }
              return { f: b.toString(16), F: B, offset: f };
            }
            var J = new Uint8Array([
              0,
              1,
              8,
              16,
              9,
              2,
              3,
              10,
              17,
              24,
              32,
              25,
              18,
              11,
              4,
              5,
              12,
              19,
              26,
              33,
              40,
              48,
              41,
              34,
              27,
              20,
              13,
              6,
              7,
              14,
              21,
              28,
              35,
              42,
              49,
              56,
              57,
              50,
              43,
              36,
              29,
              22,
              15,
              23,
              30,
              37,
              44,
              51,
              58,
              59,
              52,
              45,
              38,
              31,
              39,
              46,
              53,
              60,
              61,
              54,
              47,
              55,
              62,
              63
            ]);
            g.prototype = { parse: function(a) {
              function d2() {
                var d3 = a[k] << 8 | a[k + 1];
                k += 2;
                return d3;
              }
              function f() {
                var b2 = d2();
                b2 = k + b2 - 2;
                var c2 = N(a, b2, k);
                c2 && c2.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + c2.f), b2 = c2.offset);
                b2 = a.subarray(k, b2);
                k += b2.length;
                return b2;
              }
              function e(a2) {
                for (var b2 = Math.ceil(a2.v / 8 / a2.s), c2 = Math.ceil(a2.g / 8 / a2.u), d3 = 0; d3 < a2.b.length; d3++) {
                  v = a2.b[d3];
                  var e2 = Math.ceil(Math.ceil(a2.v / 8) * v.h / a2.s), f2 = Math.ceil(Math.ceil(a2.g / 8) * v.j / a2.u);
                  v.a = new Int16Array(64 * c2 * v.j * (b2 * v.h + 1));
                  v.c = e2;
                  v.l = f2;
                }
                a2.P = b2;
                a2.O = c2;
              }
              var b = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).N, B = b === void 0 ? null : b, k = 0, l = null, r = 0;
              b = [];
              var n = [], q = [], h = d2();
              if (h !== 65496)
                throw new D("SOI not found");
              for (h = d2(); h !== 65497; ) {
                switch (h) {
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var c = f();
                    h === 65518 && c[0] === 65 && c[1] === 100 && c[2] === 111 && c[3] === 98 && c[4] === 101 && (l = { version: c[5] << 8 | c[6], Y: c[7] << 8 | c[8], Z: c[9] << 8 | c[10], W: c[11] });
                    break;
                  case 65499:
                    h = d2() + k - 2;
                    for (var g2; k < h; ) {
                      var w = a[k++], p = new Uint16Array(64);
                      if (w >> 4 === 0)
                        for (c = 0; 64 > c; c++)
                          g2 = J[c], p[g2] = a[k++];
                      else if (w >> 4 === 1)
                        for (c = 0; 64 > c; c++)
                          g2 = J[c], p[g2] = d2();
                      else
                        throw new D("DQT - invalid table spec");
                      b[w & 15] = p;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    if (m)
                      throw new D("Only single frame JPEGs supported");
                    d2();
                    var m = {};
                    m.X = h === 65473;
                    m.S = h === 65474;
                    m.precision = a[k++];
                    h = d2();
                    m.g = B || h;
                    m.v = d2();
                    m.b = [];
                    m.C = {};
                    c = a[k++];
                    for (h = p = w = 0; h < c; h++) {
                      g2 = a[k];
                      var t = a[k + 1] >> 4;
                      var H = a[k + 1] & 15;
                      w < t && (w = t);
                      p < H && (p = H);
                      t = m.b.push({ h: t, j: H, T: a[k + 2], G: null });
                      m.C[g2] = t - 1;
                      k += 3;
                    }
                    m.s = w;
                    m.u = p;
                    e(m);
                    break;
                  case 65476:
                    g2 = d2();
                    for (h = 2; h < g2; ) {
                      w = a[k++];
                      p = new Uint8Array(16);
                      for (c = t = 0; 16 > c; c++, k++)
                        t += p[c] = a[k];
                      H = new Uint8Array(t);
                      for (c = 0; c < t; c++, k++)
                        H[c] = a[k];
                      h += 17 + t;
                      (w >> 4 === 0 ? q : n)[w & 15] = W(p, H);
                    }
                    break;
                  case 65501:
                    d2();
                    var u = d2();
                    break;
                  case 65498:
                    c = ++r === 1 && !B;
                    d2();
                    w = a[k++];
                    g2 = [];
                    for (h = 0; h < w; h++) {
                      p = m.C[a[k++]];
                      var v = m.b[p];
                      p = a[k++];
                      v.D = q[p >> 4];
                      v.o = n[p & 15];
                      g2.push(v);
                    }
                    h = a[k++];
                    w = a[k++];
                    p = a[k++];
                    try {
                      var z = X(a, k, m, g2, u, h, w, p >> 4, p & 15, c);
                      k += z;
                    } catch (x) {
                      if (x instanceof P)
                        return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(a, { N: x.g });
                      throw x;
                    }
                    break;
                  case 65500:
                    k += 4;
                    break;
                  case 65535:
                    a[k] !== 255 && k--;
                    break;
                  default:
                    if (a[k - 3] === 255 && 192 <= a[k - 2] && 254 >= a[k - 2])
                      k -= 3;
                    else if ((c = N(a, k - 2)) && c.f)
                      (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + c.f), k = c.offset;
                    else
                      throw new D("unknown marker " + h.toString(16));
                }
                h = d2();
              }
              this.width = m.v;
              this.height = m.g;
              this.A = l;
              this.b = [];
              for (h = 0; h < m.b.length; h++) {
                v = m.b[h];
                if (u = b[v.T])
                  v.G = u;
                this.b.push({ R: Y(m, v), U: v.h / m.s, V: v.j / m.u, c: v.c, l: v.l });
              }
              this.i = this.b.length;
            }, L: function(a, d2) {
              var f = this.width / a, e = this.height / d2, b, g2, k = this.b.length, l = a * d2 * k, r = new Uint8ClampedArray(l), n = new Uint32Array(a);
              for (g2 = 0; g2 < k; g2++) {
                var q = this.b[g2];
                var h = q.U * f;
                var c = q.V * e;
                var C = g2;
                var w = q.R;
                var p = q.c + 1 << 3;
                for (b = 0; b < a; b++)
                  q = 0 | b * h, n[b] = (q & 4294967288) << 3 | q & 7;
                for (h = 0; h < d2; h++)
                  for (q = 0 | h * c, q = p * (q & 4294967288) | (q & 7) << 3, b = 0; b < a; b++)
                    r[C] = w[q + n[b]], C += k;
              }
              if (e = this.M)
                for (g2 = 0; g2 < l; )
                  for (f = q = 0; q < k; q++, g2++, f += 2)
                    r[g2] = (r[g2] * e[f] >> 8) + e[f + 1];
              return r;
            }, w: function() {
              return this.A ? !!this.A.W : this.i === 3 ? this.B === 0 ? false : true : this.B === 1 ? true : false;
            }, I: function(a) {
              for (var d2, f, e, b = 0, g2 = a.length; b < g2; b += 3)
                d2 = a[b], f = a[b + 1], e = a[b + 2], a[b] = d2 - 179.456 + 1.402 * e, a[b + 1] = d2 + 135.459 - 0.344 * f - 0.714 * e, a[b + 2] = d2 - 226.816 + 1.772 * f;
              return a;
            }, K: function(a) {
              for (var d2, f, e, b, g2 = 0, k = 0, l = a.length; k < l; k += 4)
                d2 = a[k], f = a[k + 1], e = a[k + 2], b = a[k + 3], a[g2++] = -122.67195406894 + f * (-660635669420364e-19 * f + 437130475926232e-18 * e - 54080610064599e-18 * d2 + 48449797120281e-17 * b - 0.154362151871126) + e * (-957964378445773e-18 * e + 817076911346625e-18 * d2 - 0.00477271405408747 * b + 1.53380253221734) + d2 * (961250184130688e-18 * d2 - 0.00266257332283933 * b + 0.48357088451265) + b * (-336197177618394e-18 * b + 0.484791561490776), a[g2++] = 107.268039397724 + f * (219927104525741e-19 * f - 640992018297945e-18 * e + 659397001245577e-18 * d2 + 426105652938837e-18 * b - 0.176491792462875) + e * (-778269941513683e-18 * e + 0.00130872261408275 * d2 + 770482631801132e-18 * b - 0.151051492775562) + d2 * (0.00126935368114843 * d2 - 0.00265090189010898 * b + 0.25802910206845) + b * (-318913117588328e-18 * b - 0.213742400323665), a[g2++] = -20.810012546947 + f * (-570115196973677e-18 * f - 263409051004589e-19 * e + 0.0020741088115012 * d2 - 0.00288260236853442 * b + 0.814272968359295) + e * (-153496057440975e-19 * e - 132689043961446e-18 * d2 + 560833691242812e-18 * b - 0.195152027534049) + d2 * (0.00174418132927582 * d2 - 0.00255243321439347 * b + 0.116935020465145) + b * (-343531996510555e-18 * b + 0.24165260232407);
              return a.subarray(0, g2);
            }, J: function(a) {
              for (var d2, f, e, b = 0, g2 = a.length; b < g2; b += 4)
                d2 = a[b], f = a[b + 1], e = a[b + 2], a[b] = 434.456 - d2 - 1.402 * e, a[b + 1] = 119.541 - d2 + 0.344 * f + 0.714 * e, a[b + 2] = 481.816 - d2 - 1.772 * f;
              return a;
            }, H: function(a) {
              for (var d2, f, e, b, g2 = 0, k = 1 / 255, l = 0, r = a.length; l < r; l += 4)
                d2 = a[l] * k, f = a[l + 1] * k, e = a[l + 2] * k, b = a[l + 3] * k, a[g2++] = 255 + d2 * (-4.387332384609988 * d2 + 54.48615194189176 * f + 18.82290502165302 * e + 212.25662451639585 * b - 285.2331026137004) + f * (1.7149763477362134 * f - 5.6096736904047315 * e - 17.873870861415444 * b - 5.497006427196366) + e * (-2.5217340131683033 * e - 21.248923337353073 * b + 17.5119270841813) - b * (21.86122147463605 * b + 189.48180835922747), a[g2++] = 255 + d2 * (8.841041422036149 * d2 + 60.118027045597366 * f + 6.871425592049007 * e + 31.159100130055922 * b - 79.2970844816548) + f * (-15.310361306967817 * f + 17.575251261109482 * e + 131.35250912493976 * b - 190.9453302588951) + e * (4.444339102852739 * e + 9.8632861493405 * b - 24.86741582555878) - b * (20.737325471181034 * b + 187.80453709719578), a[g2++] = 255 + d2 * (0.8842522430003296 * d2 + 8.078677503112928 * f + 30.89978309703729 * e - 0.23883238689178934 * b - 14.183576799673286) + f * (10.49593273432072 * f + 63.02378494754052 * e + 50.606957656360734 * b - 112.23884253719248) + e * (0.03296041114873217 * e + 115.60384449646641 * b - 193.58209356861505) - b * (22.33816807309886 * b + 180.12613974708367);
              return a.subarray(0, g2);
            }, getData: function(a, d2, f) {
              if (4 < this.i)
                throw new D("Unsupported color mode");
              a = this.L(a, d2);
              if (this.i === 1 && f) {
                f = a.length;
                d2 = new Uint8ClampedArray(3 * f);
                for (var e = 0, b = 0; b < f; b++) {
                  var g2 = a[b];
                  d2[e++] = g2;
                  d2[e++] = g2;
                  d2[e++] = g2;
                }
                return d2;
              }
              if (this.i === 3 && this.w())
                return this.I(a);
              if (this.i === 4) {
                if (this.w())
                  return f ? this.K(a) : this.J(a);
                if (f)
                  return this.H(a);
              }
              return a;
            } };
            UTIF2.JpegDecoder = g;
          })();
        })();
        UTIF2.encodeImage = function(rgba, w, h, metadata) {
          var idf = {
            "t256": [w],
            "t257": [h],
            "t258": [8, 8, 8, 8],
            "t259": [1],
            "t262": [2],
            "t273": [1e3],
            "t277": [4],
            "t278": [h],
            "t279": [w * h * 4],
            "t282": [1],
            "t283": [1],
            "t284": [1],
            "t286": [0],
            "t287": [0],
            "t296": [1],
            "t305": ["Photopea (UTIF.js)"],
            "t338": [1]
          };
          if (metadata)
            for (var i in metadata)
              idf[i] = metadata[i];
          var prfx = new Uint8Array(UTIF2.encode([idf]));
          var img = new Uint8Array(rgba);
          var data = new Uint8Array(1e3 + w * h * 4);
          for (var i = 0; i < prfx.length; i++)
            data[i] = prfx[i];
          for (var i = 0; i < img.length; i++)
            data[1e3 + i] = img[i];
          return data.buffer;
        };
        UTIF2.encode = function(ifds) {
          var data = new Uint8Array(2e4), offset = 4, bin = UTIF2._binBE;
          data[0] = 77;
          data[1] = 77;
          data[3] = 42;
          var ifdo = 8;
          bin.writeUint(data, offset, ifdo);
          offset += 4;
          for (var i = 0; i < ifds.length; i++) {
            var noffs = UTIF2._writeIFD(bin, data, ifdo, ifds[i]);
            ifdo = noffs[1];
            if (i < ifds.length - 1)
              bin.writeUint(data, noffs[0], ifdo);
          }
          return data.slice(0, ifdo).buffer;
        };
        UTIF2.decode = function(buff) {
          UTIF2.decode._decodeG3.allow2D = null;
          var data = new Uint8Array(buff), offset = 0;
          var id = UTIF2._binBE.readASCII(data, offset, 2);
          offset += 2;
          var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
          var num = bin.readUshort(data, offset);
          offset += 2;
          var ifdo = bin.readUint(data, offset);
          offset += 4;
          var ifds = [];
          while (true) {
            var noff = UTIF2._readIFD(bin, data, ifdo, ifds);
            ifdo = bin.readUint(data, noff);
            if (ifdo == 0)
              break;
          }
          return ifds;
        };
        UTIF2.decodeImages = function(buff, ifds) {
          var data = new Uint8Array(buff);
          var id = UTIF2._binBE.readASCII(data, 0, 2);
          for (var ii = 0; ii < ifds.length; ii++) {
            var img = ifds[ii];
            if (img["t256"] == null)
              continue;
            img.isLE = id == "II";
            img.width = img["t256"][0];
            img.height = img["t257"][0];
            var cmpr = img["t259"] ? img["t259"][0] : 1;
            var fo = img["t266"] ? img["t266"][0] : 1;
            if (img["t284"] && img["t284"][0] == 2)
              log("PlanarConfiguration 2 should not be used!");
            var bipp = (img["t258"] ? Math.min(32, img["t258"][0]) : 1) * (img["t277"] ? img["t277"][0] : 1);
            var bipl = Math.ceil(img.width * bipp / 8) * 8;
            var soff = img["t273"];
            if (soff == null)
              soff = img["t324"];
            var bcnt = img["t279"];
            if (cmpr == 1 && soff.length == 1)
              bcnt = [img.height * (bipl >>> 3)];
            if (bcnt == null)
              bcnt = img["t325"];
            var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
            if (img["t322"] != null) {
              var tw = img["t322"][0], th = img["t323"][0];
              var tx = Math.floor((img.width + tw - 1) / tw);
              var ty = Math.floor((img.height + th - 1) / th);
              var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
              for (var y = 0; y < ty; y++)
                for (var x = 0; x < tx; x++) {
                  var i = y * tx + x;
                  for (var j = 0; j < tbuff.length; j++)
                    tbuff[j] = 0;
                  UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo);
                  if (cmpr == 6)
                    bytes = tbuff;
                  else
                    UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
                }
              bilen = bytes.length * 8;
            } else {
              var rps = img["t278"] ? img["t278"][0] : img.height;
              rps = Math.min(rps, img.height);
              for (var i = 0; i < soff.length; i++) {
                UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo);
                bilen += bipl * rps;
              }
              bilen = Math.min(bilen, bytes.length * 8);
            }
            img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
          }
        };
        UTIF2.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo) {
          if (false) {
          } else if (cmpr == 1)
            for (var j = 0; j < len; j++)
              tgt[toff + j] = data[off + j];
          else if (cmpr == 3)
            UTIF2.decode._decodeG3(data, off, len, tgt, toff, img.width, fo);
          else if (cmpr == 4)
            UTIF2.decode._decodeG4(data, off, len, tgt, toff, img.width, fo);
          else if (cmpr == 5)
            UTIF2.decode._decodeLZW(data, off, tgt, toff);
          else if (cmpr == 6)
            UTIF2.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
          else if (cmpr == 7)
            UTIF2.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
          else if (cmpr == 8) {
            var src2 = new Uint8Array(data.buffer, off, len);
            var bin = pako2["inflate"](src2);
            for (var i = 0; i < bin.length; i++)
              tgt[toff + i] = bin[i];
          } else if (cmpr == 32773)
            UTIF2.decode._decodePackBits(data, off, len, tgt, toff);
          else if (cmpr == 32809)
            UTIF2.decode._decodeThunder(data, off, len, tgt, toff);
          else
            log("Unknown compression", cmpr);
          if (img["t317"] && img["t317"][0] == 2) {
            var noc = img["t277"] ? img["t277"][0] : 1, h = img["t278"] ? img["t278"][0] : img.height, bpr = img.width * noc;
            for (var y = 0; y < h; y++) {
              var ntoff = toff + y * bpr;
              if (noc == 3)
                for (var j = 3; j < bpr; j += 3) {
                  tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                  tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                  tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
                }
              else
                for (var j = noc; j < bpr; j++)
                  tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - noc] & 255;
            }
          }
        };
        UTIF2.decode._decodeNikon = function(data, off, len, tgt, toff) {
          var nikon_tree = [
            [
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              5,
              4,
              3,
              6,
              2,
              7,
              1,
              0,
              8,
              9,
              11,
              10,
              12
            ],
            [
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              57,
              90,
              56,
              39,
              22,
              5,
              4,
              3,
              2,
              1,
              0,
              11,
              12,
              12
            ],
            [
              0,
              1,
              4,
              2,
              3,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              5,
              4,
              6,
              3,
              7,
              2,
              8,
              1,
              9,
              0,
              10,
              11,
              12
            ],
            [
              0,
              1,
              4,
              3,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              5,
              6,
              4,
              7,
              8,
              3,
              9,
              2,
              1,
              0,
              10,
              11,
              12,
              13,
              14
            ],
            [
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              8,
              92,
              75,
              58,
              41,
              7,
              6,
              5,
              4,
              3,
              2,
              1,
              0,
              13,
              14
            ],
            [
              0,
              1,
              4,
              2,
              2,
              3,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              7,
              6,
              8,
              5,
              9,
              4,
              10,
              3,
              11,
              12,
              2,
              0,
              1,
              13,
              14
            ]
          ];
          var ver0, ver1, vpred, hpred, csize;
          var i, min, max, step = 0, huff = 0, split = 0, row, col, len, shl, diff;
          log(data.slice(off, off + 100));
          ver0 = data[off];
          off++;
          ver1 = data[off];
          off++;
          log(ver0.toString(16), ver1.toString(16), len);
        };
        UTIF2.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
          var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
          if (tables) {
            var SOI = 216, EOI2 = 217, boff = 0;
            for (var i = 0; i < tlen - 1; i++) {
              if (tables[i] == 255 && tables[i + 1] == EOI2)
                break;
              buff[boff++] = tables[i];
            }
            var byte1 = data[off], byte2 = data[off + 1];
            if (byte1 != 255 || byte2 != SOI) {
              buff[boff++] = byte1;
              buff[boff++] = byte2;
            }
            for (var i = 2; i < len; i++)
              buff[boff++] = data[off + i];
          } else
            for (var i = 0; i < len; i++)
              buff[i] = data[off + i];
          if (img["t262"] == 32803) {
            var bps = img["t258"][0], dcdr = new LosslessJpegDecoder();
            var out = dcdr.decode(buff), olen = out.length;
            if (false) {
            } else if (bps == 16)
              for (var i = 0; i < olen; i++) {
                tgt[toff++] = out[i] & 255;
                tgt[toff++] = out[i] >>> 8;
              }
            else if (bps == 12)
              for (var i = 0; i < olen; i += 2) {
                tgt[toff++] = out[i] >>> 4;
                tgt[toff++] = (out[i] << 4 | out[i + 1] >>> 8) & 255;
                tgt[toff++] = out[i + 1] & 255;
              }
            else
              throw new Error("unsupported bit depth " + bps);
          } else {
            var parser = new UTIF2.JpegDecoder();
            parser.parse(buff);
            var decoded = parser.getData(parser.width, parser.height);
            for (var i = 0; i < decoded.length; i++)
              tgt[toff + i] = decoded[i];
          }
          if (img["t262"][0] == 6)
            img["t262"][0] = 2;
        };
        UTIF2.decode._decodeOldJPEGInit = function(img, data, off, len) {
          var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
          var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i, j, k;
          var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
          var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
          var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
          var ycbcrss = img["t530"], ssx = 0, ssy = 0;
          var spp = img["t277"] ? img["t277"][0] : 1;
          var jpgresint = img["t515"];
          if (soffTag) {
            soff = soffTag[0];
            isTiled = soffTag.length > 1;
          }
          if (!isTiled) {
            if (data[off] == 255 && data[off + 1] == SOI)
              return { jpegOffset: off };
            if (jpgIchgFmt != null) {
              if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI)
                joff = off + jifoff;
              else
                log("JPEGInterchangeFormat does not point to SOI");
              if (jpgIchgFmtLen == null)
                log("JPEGInterchangeFormatLength field is missing");
              else if (jifoff >= soff || jifoff + jiflen <= soff)
                log("JPEGInterchangeFormatLength field value is invalid");
              if (joff != null)
                return { jpegOffset: joff };
            }
          }
          if (ycbcrss != null) {
            ssx = ycbcrss[0];
            ssy = ycbcrss[1];
          }
          if (jpgIchgFmt != null) {
            if (jpgIchgFmtLen != null)
              if (jiflen >= 2 && jifoff + jiflen <= soff) {
                if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI)
                  tables = new Uint8Array(jiflen - 2);
                else
                  tables = new Uint8Array(jiflen);
                for (i = 0; i < tables.length; i++)
                  tables[i] = data[off + jifoff + i];
                log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
              } else
                log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
          }
          if (tables == null) {
            var ooff = 0, out = [];
            out[ooff++] = 255;
            out[ooff++] = SOI;
            var qtables = img["t519"];
            if (qtables == null)
              throw new Error("JPEGQTables tag is missing");
            for (i = 0; i < qtables.length; i++) {
              out[ooff++] = 255;
              out[ooff++] = DQT;
              out[ooff++] = 0;
              out[ooff++] = 67;
              out[ooff++] = i;
              for (j = 0; j < 64; j++)
                out[ooff++] = data[off + qtables[i] + j];
            }
            for (k = 0; k < 2; k++) {
              var htables = img[k == 0 ? "t520" : "t521"];
              if (htables == null)
                throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
              for (i = 0; i < htables.length; i++) {
                out[ooff++] = 255;
                out[ooff++] = DHT;
                var nc = 19;
                for (j = 0; j < 16; j++)
                  nc += data[off + htables[i] + j];
                out[ooff++] = nc >>> 8;
                out[ooff++] = nc & 255;
                out[ooff++] = i | k << 4;
                for (j = 0; j < 16; j++)
                  out[ooff++] = data[off + htables[i] + j];
                for (j = 0; j < nc; j++)
                  out[ooff++] = data[off + htables[i] + 16 + j];
              }
            }
            out[ooff++] = 255;
            out[ooff++] = SOF0;
            out[ooff++] = 0;
            out[ooff++] = 8 + 3 * spp;
            out[ooff++] = 8;
            out[ooff++] = img.height >>> 8 & 255;
            out[ooff++] = img.height & 255;
            out[ooff++] = img.width >>> 8 & 255;
            out[ooff++] = img.width & 255;
            out[ooff++] = spp;
            if (spp == 1) {
              out[ooff++] = 1;
              out[ooff++] = 17;
              out[ooff++] = 0;
            } else
              for (i = 0; i < 3; i++) {
                out[ooff++] = i + 1;
                out[ooff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                out[ooff++] = i;
              }
            if (jpgresint != null && jpgresint[0] != 0) {
              out[ooff++] = 255;
              out[ooff++] = DRI;
              out[ooff++] = 0;
              out[ooff++] = 4;
              out[ooff++] = jpgresint[0] >>> 8 & 255;
              out[ooff++] = jpgresint[0] & 255;
            }
            tables = new Uint8Array(out);
          }
          var sofpos = -1;
          i = 0;
          while (i < tables.length - 1) {
            if (tables[i] == 255 && tables[i + 1] == SOF0) {
              sofpos = i;
              break;
            }
            i++;
          }
          if (sofpos == -1) {
            var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
            tmptab.set(tables);
            var tmpoff = tables.length;
            sofpos = tables.length;
            tables = tmptab;
            tables[tmpoff++] = 255;
            tables[tmpoff++] = SOF0;
            tables[tmpoff++] = 0;
            tables[tmpoff++] = 8 + 3 * spp;
            tables[tmpoff++] = 8;
            tables[tmpoff++] = img.height >>> 8 & 255;
            tables[tmpoff++] = img.height & 255;
            tables[tmpoff++] = img.width >>> 8 & 255;
            tables[tmpoff++] = img.width & 255;
            tables[tmpoff++] = spp;
            if (spp == 1) {
              tables[tmpoff++] = 1;
              tables[tmpoff++] = 17;
              tables[tmpoff++] = 0;
            } else
              for (i = 0; i < 3; i++) {
                tables[tmpoff++] = i + 1;
                tables[tmpoff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                tables[tmpoff++] = i;
              }
          }
          if (data[soff] == 255 && data[soff + 1] == SOS2) {
            var soslen = data[soff + 2] << 8 | data[soff + 3];
            sosMarker2 = new Uint8Array(soslen + 2);
            sosMarker2[0] = data[soff];
            sosMarker2[1] = data[soff + 1];
            sosMarker2[2] = data[soff + 2];
            sosMarker2[3] = data[soff + 3];
            for (i = 0; i < soslen - 2; i++)
              sosMarker2[i + 4] = data[soff + i + 4];
          } else {
            sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
            var sosoff = 0;
            sosMarker2[sosoff++] = 255;
            sosMarker2[sosoff++] = SOS2;
            sosMarker2[sosoff++] = 0;
            sosMarker2[sosoff++] = 6 + 2 * spp;
            sosMarker2[sosoff++] = spp;
            if (spp == 1) {
              sosMarker2[sosoff++] = 1;
              sosMarker2[sosoff++] = 0;
            } else
              for (i = 0; i < 3; i++) {
                sosMarker2[sosoff++] = i + 1;
                sosMarker2[sosoff++] = i << 4 | i;
              }
            sosMarker2[sosoff++] = 0;
            sosMarker2[sosoff++] = 63;
            sosMarker2[sosoff++] = 0;
          }
          return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
        };
        UTIF2.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
          var i, dlen, tlen, buff, buffoff;
          var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data, off, len);
          if (jpegData.jpegOffset != null) {
            dlen = off + len - jpegData.jpegOffset;
            buff = new Uint8Array(dlen);
            for (i = 0; i < dlen; i++)
              buff[i] = data[jpegData.jpegOffset + i];
          } else {
            tlen = jpegData.tables.length;
            buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
            buff.set(jpegData.tables);
            buffoff = tlen;
            buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
            buff[jpegData.sofPosition + 6] = img.height & 255;
            buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
            buff[jpegData.sofPosition + 8] = img.width & 255;
            if (data[off] != 255 || data[off + 1] != SOS) {
              buff.set(jpegData.sosMarker, bufoff);
              bufoff += sosMarker.length;
            }
            for (i = 0; i < len; i++)
              buff[bufoff++] = data[off + i];
            buff[bufoff++] = 255;
            buff[bufoff++] = EOI;
          }
          var parser = new UTIF2.JpegDecoder();
          parser.parse(buff);
          var decoded = parser.getData(parser.width, parser.height);
          for (var i = 0; i < decoded.length; i++)
            tgt[toff + i] = decoded[i];
          if (img["t262"][0] == 6)
            img["t262"][0] = 2;
        };
        UTIF2.decode._decodePackBits = function(data, off, len, tgt, toff) {
          var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
          while (off < lim) {
            var n = sa[off];
            off++;
            if (n >= 0 && n < 128)
              for (var i = 0; i < n + 1; i++) {
                ta[toff] = sa[off];
                toff++;
                off++;
              }
            if (n >= -127 && n < 0) {
              for (var i = 0; i < -n + 1; i++) {
                ta[toff] = sa[off];
                toff++;
              }
              off++;
            }
          }
        };
        UTIF2.decode._decodeThunder = function(data, off, len, tgt, toff) {
          var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
          var lim = off + len, qoff = toff * 2, px = 0;
          while (off < lim) {
            var b = data[off], msk = b >>> 6, n = b & 63;
            off++;
            if (msk == 3) {
              px = n & 15;
              tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
              qoff++;
            }
            if (msk == 0)
              for (var i = 0; i < n; i++) {
                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                qoff++;
              }
            if (msk == 2)
              for (var i = 0; i < 2; i++) {
                var d4 = n >>> 3 * (1 - i) & 7;
                if (d4 != 4) {
                  px += d3[d4];
                  tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                  qoff++;
                }
              }
            if (msk == 1)
              for (var i = 0; i < 3; i++) {
                var d4 = n >>> 2 * (2 - i) & 3;
                if (d4 != 2) {
                  px += d2[d4];
                  tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                  qoff++;
                }
              }
          }
        };
        UTIF2.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
        UTIF2.decode._lens = function() {
          var addKeys = function(lens, arr, i0, inc) {
            for (var i = 0; i < arr.length; i++)
              lens[arr[i]] = i0 + i * inc;
          };
          var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
          var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
          var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
          var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
          var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
          termW = termW.split(",");
          termB = termB.split(",");
          makeW = makeW.split(",");
          makeB = makeB.split(",");
          makeA = makeA.split(",");
          var lensW = {}, lensB = {};
          addKeys(lensW, termW, 0, 1);
          addKeys(lensW, makeW, 64, 64);
          addKeys(lensW, makeA, 1792, 64);
          addKeys(lensB, termB, 0, 1);
          addKeys(lensB, makeB, 64, 64);
          addKeys(lensB, makeA, 1792, 64);
          return [lensW, lensB];
        }();
        UTIF2.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
          var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
          var line = [], pline = [];
          for (var i = 0; i < w; i++)
            pline.push(0);
          pline = U._makeDiff(pline);
          var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
          var y = 0, mode = "", toRead = 0;
          var bipl = Math.ceil(w / 8) * 8;
          while (boff >>> 3 < off + slen) {
            b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
            var bit = 0;
            if (fo == 1)
              bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
            if (fo == 2)
              bit = data[boff >>> 3] >>> (boff & 7) & 1;
            boff++;
            wrd += bit;
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0)
                    mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
            if (line.length == w && mode == "") {
              U._writeBits(line, tgt, toff * 8 + y * bipl);
              clr = 0;
              y++;
              a0 = 0;
              pline = U._makeDiff(line);
              line = [];
            }
          }
        };
        UTIF2.decode._findDiff = function(line, x, clr) {
          for (var i = 0; i < line.length; i += 2)
            if (line[i] >= x && line[i + 1] == clr)
              return line[i];
        };
        UTIF2.decode._makeDiff = function(line) {
          var out = [];
          if (line[0] == 1)
            out.push(0, 1);
          for (var i = 1; i < line.length; i++)
            if (line[i - 1] != line[i])
              out.push(i, line[i]);
          out.push(line.length, 0, line.length, 1);
          return out;
        };
        UTIF2.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo) {
          var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
          var line = [], pline = [];
          for (var i = 0; i < w; i++)
            line.push(0);
          var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
          var y = -1, mode = "", toRead = 0, is1D = false;
          var bipl = Math.ceil(w / 8) * 8;
          while (boff >>> 3 < off + slen) {
            b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
            var bit = 0;
            if (fo == 1)
              bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
            if (fo == 2)
              bit = data[boff >>> 3] >>> (boff & 7) & 1;
            boff++;
            wrd += bit;
            if (is1D) {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  clr = 1 - clr;
                  len = 0;
                }
              }
            } else {
              if (mode == "H") {
                if (U._lens[clr][wrd] != null) {
                  var dl = U._lens[clr][wrd];
                  wrd = "";
                  len += dl;
                  if (dl < 64) {
                    U._addNtimes(line, len, clr);
                    a0 += len;
                    clr = 1 - clr;
                    len = 0;
                    toRead--;
                    if (toRead == 0)
                      mode = "";
                  }
                }
              } else {
                if (wrd == "0001") {
                  wrd = "";
                  U._addNtimes(line, b2 - a0, clr);
                  a0 = b2;
                }
                if (wrd == "001") {
                  wrd = "";
                  mode = "H";
                  toRead = 2;
                }
                if (U._dmap[wrd] != null) {
                  a1 = b1 + U._dmap[wrd];
                  U._addNtimes(line, a1 - a0, clr);
                  a0 = a1;
                  wrd = "";
                  clr = 1 - clr;
                }
              }
            }
            if (wrd.endsWith("000000000001")) {
              if (y >= 0)
                U._writeBits(line, tgt, toff * 8 + y * bipl);
              if (fo == 1)
                is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
              if (fo == 2)
                is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
              boff++;
              if (U._decodeG3.allow2D == null)
                U._decodeG3.allow2D = is1D;
              if (!U._decodeG3.allow2D) {
                is1D = true;
                boff--;
              }
              wrd = "";
              clr = 0;
              y++;
              a0 = 0;
              pline = U._makeDiff(line);
              line = [];
            }
          }
          if (line.length == w)
            U._writeBits(line, tgt, toff * 8 + y * bipl);
        };
        UTIF2.decode._addNtimes = function(arr, n, val) {
          for (var i = 0; i < n; i++)
            arr.push(val);
        };
        UTIF2.decode._writeBits = function(bits, tgt, boff) {
          for (var i = 0; i < bits.length; i++)
            tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
        };
        UTIF2.decode._decodeLZW = function(data, off, tgt, toff) {
          if (UTIF2.decode._lzwTab == null) {
            var tb = new Uint32Array(65535), tn = new Uint16Array(65535), chr = new Uint8Array(2e6);
            for (var i = 0; i < 256; i++) {
              chr[i << 2] = i;
              tb[i] = i << 2;
              tn[i] = 1;
            }
            UTIF2.decode._lzwTab = [tb, tn, chr];
          }
          var copy = UTIF2.decode._copyData;
          var tab = UTIF2.decode._lzwTab[0], tln = UTIF2.decode._lzwTab[1], chr = UTIF2.decode._lzwTab[2], totl = 258, chrl = 258 << 2;
          var bits = 9, boff = off << 3;
          var ClearCode = 256, EoiCode = 257;
          var v = 0, Code = 0, OldCode = 0;
          while (true) {
            v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
            Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
            boff += bits;
            if (Code == EoiCode)
              break;
            if (Code == ClearCode) {
              bits = 9;
              totl = 258;
              chrl = 258 << 2;
              v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
              Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
              boff += bits;
              if (Code == EoiCode)
                break;
              tgt[toff] = Code;
              toff++;
            } else if (Code < totl) {
              var cd = tab[Code], cl = tln[Code];
              copy(chr, cd, tgt, toff, cl);
              toff += cl;
              if (OldCode >= totl) {
                tab[totl] = chrl;
                chr[tab[totl]] = cd[0];
                tln[totl] = 1;
                chrl = chrl + 1 + 3 & ~3;
                totl++;
              } else {
                tab[totl] = chrl;
                var nit = tab[OldCode], nil = tln[OldCode];
                copy(chr, nit, chr, chrl, nil);
                chr[chrl + nil] = chr[cd];
                nil++;
                tln[totl] = nil;
                totl++;
                chrl = chrl + nil + 3 & ~3;
              }
              if (totl + 1 == 1 << bits)
                bits++;
            } else {
              if (OldCode >= totl) {
                tab[totl] = chrl;
                tln[totl] = 0;
                totl++;
              } else {
                tab[totl] = chrl;
                var nit = tab[OldCode], nil = tln[OldCode];
                copy(chr, nit, chr, chrl, nil);
                chr[chrl + nil] = chr[chrl];
                nil++;
                tln[totl] = nil;
                totl++;
                copy(chr, chrl, tgt, toff, nil);
                toff += nil;
                chrl = chrl + nil + 3 & ~3;
              }
              if (totl + 1 == 1 << bits)
                bits++;
            }
            OldCode = Code;
          }
        };
        UTIF2.decode._copyData = function(s2, so, t, to, l) {
          for (var i = 0; i < l; i += 4) {
            t[to + i] = s2[so + i];
            t[to + i + 1] = s2[so + i + 1];
            t[to + i + 2] = s2[so + i + 2];
            t[to + i + 3] = s2[so + i + 3];
          }
        };
        UTIF2.tags = {
          254: "NewSubfileType",
          255: "SubfileType",
          256: "ImageWidth",
          257: "ImageLength",
          258: "BitsPerSample",
          259: "Compression",
          262: "PhotometricInterpretation",
          266: "FillOrder",
          269: "DocumentName",
          270: "ImageDescription",
          271: "Make",
          272: "Model",
          273: "StripOffset",
          274: "Orientation",
          277: "SamplesPerPixel",
          278: "RowsPerStrip",
          279: "StripByteCounts",
          280: "MinSampleValue",
          281: "MaxSampleValue",
          282: "XResolution",
          283: "YResolution",
          284: "PlanarConfiguration",
          285: "PageName",
          286: "XPosition",
          287: "YPosition",
          292: "T4Options",
          296: "ResolutionUnit",
          297: "PageNumber",
          305: "Software",
          306: "DateTime",
          315: "Artist",
          316: "HostComputer",
          317: "Predictor",
          318: "WhitePoint",
          319: "PrimaryChromaticities",
          320: "ColorMap",
          321: "HalftoneHints",
          322: "TileWidth",
          323: "TileLength",
          324: "TileOffset",
          325: "TileByteCounts",
          330: "SubIFDs",
          336: "DotRange",
          338: "ExtraSample",
          339: "SampleFormat",
          347: "JPEGTables",
          512: "JPEGProc",
          513: "JPEGInterchangeFormat",
          514: "JPEGInterchangeFormatLength",
          519: "JPEGQTables",
          520: "JPEGDCTables",
          521: "JPEGACTables",
          529: "YCbCrCoefficients",
          530: "YCbCrSubSampling",
          531: "YCbCrPositioning",
          532: "ReferenceBlackWhite",
          700: "XMP",
          33421: "CFARepeatPatternDim",
          33422: "CFAPattern",
          33432: "Copyright",
          33434: "ExposureTime",
          33437: "FNumber",
          33723: "IPTC/NAA",
          34377: "Photoshop",
          34665: "ExifIFD",
          34675: "ICC Profile",
          34850: "ExposureProgram",
          34853: "GPSInfo",
          34855: "ISOSpeedRatings",
          34858: "TimeZoneOffset",
          34859: "SelfTimeMode",
          36867: "DateTimeOriginal",
          36868: "DateTimeDigitized",
          37377: "ShutterSpeedValue",
          37378: "ApertureValue",
          37380: "ExposureBiasValue",
          37383: "MeteringMode",
          37385: "Flash",
          37386: "FocalLength",
          37390: "FocalPlaneXResolution",
          37391: "FocalPlaneYResolution",
          37392: "FocalPlaneResolutionUnit",
          37393: "ImageNumber",
          37398: "TIFF/EPStandardID",
          37399: "SensingMethod",
          37500: "MakerNote",
          37510: "UserComment",
          37724: "ImageSourceData",
          40092: "XPComment",
          40094: "XPKeywords",
          40961: "ColorSpace",
          40962: "PixelXDimension",
          40963: "PixelXDimension",
          41486: "FocalPlaneXResolution",
          41487: "FocalPlaneYResolution",
          41488: "FocalPlaneResolutionUnit",
          41985: "CustomRendered",
          41986: "ExposureMode",
          41987: "WhiteBalance",
          41990: "SceneCaptureType",
          50706: "DNGVersion",
          50707: "DNGBackwardVersion",
          50708: "UniqueCameraModel",
          50709: "LocalizedCameraModel",
          50710: "CFAPlaneColor",
          50711: "CFALayout",
          50712: "LinearizationTable",
          50713: "BlackLevelRepeatDim",
          50714: "BlackLevel",
          50716: "BlackLevelDeltaV",
          50717: "WhiteLevel",
          50718: "DefaultScale",
          50719: "DefaultCropOrigin",
          50720: "DefaultCropSize",
          50733: "BayerGreenSplit",
          50738: "AntiAliasStrength",
          50721: "ColorMatrix1",
          50722: "ColorMatrix2",
          50723: "CameraCalibration1",
          50724: "CameraCalibration2",
          50727: "AnalogBalance",
          50728: "AsShotNeutral",
          50730: "BaselineExposure",
          50731: "BaselineNoise",
          50732: "BaselineSharpness",
          50734: "LinearResponseLimit",
          50735: "CameraSerialNumber",
          50736: "LensInfo",
          50739: "ShadowScale",
          50740: "DNGPrivateData",
          50741: "MakerNoteSafety",
          50778: "CalibrationIlluminant1",
          50779: "CalibrationIlluminant2",
          50780: "BestQualityScale",
          50781: "RawDataUniqueID",
          50827: "OriginalRawFileName",
          50829: "ActiveArea",
          50830: "MaskedAreas",
          50931: "CameraCalibrationSignature",
          50932: "ProfileCalibrationSignature",
          50935: "NoiseReductionApplied",
          50936: "ProfileName",
          50937: "ProfileHueSatMapDims",
          50938: "ProfileHueSatMapData1",
          50939: "ProfileHueSatMapData2",
          50940: "ProfileToneCurve",
          50941: "ProfileEmbedPolicy",
          50942: "ProfileCopyright",
          50964: "ForwardMatrix1",
          50965: "ForwardMatrix2",
          50966: "PreviewApplicationName",
          50967: "PreviewApplicationVersion",
          50969: "PreviewSettingsDigest",
          50970: "PreviewColorSpace",
          50971: "PreviewDateTime",
          50972: "RawImageDigest",
          51008: "OpcodeList1",
          51009: "OpcodeList2",
          51022: "OpcodeList3",
          51041: "NoiseProfile",
          51089: "OriginalDefaultFinalSize",
          51090: "OriginalBestQualityFinalSize",
          51091: "OriginalDefaultCropSize",
          51125: "DefaultUserCrop"
        };
        UTIF2.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 };
        UTIF2._readIFD = function(bin, data, offset, ifds) {
          var cnt = bin.readUshort(data, offset);
          offset += 2;
          var ifd = {};
          ifds.push(ifd);
          for (var i = 0; i < cnt; i++) {
            var tag = bin.readUshort(data, offset);
            offset += 2;
            var type = bin.readUshort(data, offset);
            offset += 2;
            var num = bin.readUint(data, offset);
            offset += 4;
            var voff = bin.readUint(data, offset);
            offset += 4;
            var arr = [];
            ifd["t" + tag] = arr;
            if (type == 1 || type == 7) {
              for (var j = 0; j < num; j++)
                arr.push(data[(num < 5 ? offset - 4 : voff) + j]);
            }
            if (type == 2) {
              arr.push(bin.readASCII(data, num < 5 ? offset - 4 : voff, num - 1));
            }
            if (type == 3) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
            }
            if (type == 4) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
            }
            if (type == 5) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readUint(data, voff + j * 8) / bin.readUint(data, voff + j * 8 + 4));
            }
            if (type == 8) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
            }
            if (type == 9) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
            }
            if (type == 10) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readInt(data, voff + j * 8) / bin.readInt(data, voff + j * 8 + 4));
            }
            if (type == 11) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readFloat(data, voff + j * 4));
            }
            if (type == 12) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readDouble(data, voff + j * 8));
            }
            if (num != 0 && arr.length == 0)
              log("unknown TIFF tag type: ", type, "num:", num);
            if (tag == 330)
              for (var j = 0; j < num; j++)
                UTIF2._readIFD(bin, data, arr[j], ifds);
          }
          return offset;
        };
        UTIF2._writeIFD = function(bin, data, offset, ifd) {
          var keys = Object.keys(ifd);
          bin.writeUshort(data, offset, keys.length);
          offset += 2;
          var eoff = offset + keys.length * 12 + 4;
          for (var ki = 0; ki < keys.length; ki++) {
            var key = keys[ki];
            var tag = parseInt(key.slice(1)), type = UTIF2.ttypes[tag];
            if (type == null)
              throw new Error("unknown type of tag: " + tag);
            var val = ifd[key];
            if (type == 2)
              val = val[0] + "\0";
            var num = val.length;
            bin.writeUshort(data, offset, tag);
            offset += 2;
            bin.writeUshort(data, offset, type);
            offset += 2;
            bin.writeUint(data, offset, num);
            offset += 4;
            var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][type] * num;
            var toff = offset;
            if (dlen > 4) {
              bin.writeUint(data, offset, eoff);
              toff = eoff;
            }
            if (type == 2) {
              bin.writeASCII(data, toff, val);
            }
            if (type == 3) {
              for (var i = 0; i < num; i++)
                bin.writeUshort(data, toff + 2 * i, val[i]);
            }
            if (type == 4) {
              for (var i = 0; i < num; i++)
                bin.writeUint(data, toff + 4 * i, val[i]);
            }
            if (type == 5) {
              for (var i = 0; i < num; i++) {
                bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 1e4));
                bin.writeUint(data, toff + 8 * i + 4, 1e4);
              }
            }
            if (type == 12) {
              for (var i = 0; i < num; i++)
                bin.writeDouble(data, toff + 8 * i, val[i]);
            }
            if (dlen > 4) {
              dlen += dlen & 1;
              eoff += dlen;
            }
            offset += 4;
          }
          return [offset, eoff];
        };
        UTIF2.toRGBA8 = function(out) {
          var w = out.width, h = out.height, area = w * h, qarea = area * 4, data = out.data;
          var img = new Uint8Array(area * 4);
          var intp = out["t262"][0], bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1, isLE = out.isLE ? 1 : 0;
          if (false) {
          } else if (intp == 0) {
            var bpl = Math.ceil(bps * w / 8);
            for (var y = 0; y < h; y++) {
              var off = y * bpl, io = y * w;
              if (bps == 1)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                  img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;
                  img[qi + 3] = 255;
                }
              if (bps == 4)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (i & 1) & 15;
                  img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;
                  img[qi + 3] = 255;
                }
              if (bps == 8)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + i];
                  img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;
                  img[qi + 3] = 255;
                }
            }
          } else if (intp == 1) {
            var bpl = Math.ceil(bps * w / 8);
            for (var y = 0; y < h; y++) {
              var off = y * bpl, io = y * w;
              if (bps == 1)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                  img[qi] = img[qi + 1] = img[qi + 2] = px * 255;
                  img[qi + 3] = 255;
                }
              if (bps == 2)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (i & 3) & 3;
                  img[qi] = img[qi + 1] = img[qi + 2] = px * 85;
                  img[qi + 3] = 255;
                }
              if (bps == 8)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + i];
                  img[qi] = img[qi + 1] = img[qi + 2] = px;
                  img[qi + 3] = 255;
                }
              if (bps == 16)
                for (var i = 0; i < w; i++) {
                  var qi = io + i << 2, px = data[off + (2 * i + isLE)];
                  img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, px);
                  img[qi + 3] = 255;
                }
            }
          } else if (intp == 2) {
            if (bps == 8) {
              if (out["t338"]) {
                if (out["t338"][0] > 0)
                  for (var i = 0; i < qarea; i++)
                    img[i] = data[i];
                else
                  for (var i = 0; i < qarea; i += 4) {
                    img[i] = data[i];
                    img[i + 1] = data[i + 1];
                    img[i + 2] = data[i + 2];
                    img[i + 3] = 255;
                  }
              } else {
                var smpls = out["t258"] ? out["t258"].length : 3;
                if (smpls == 4)
                  for (var i = 0; i < qarea; i++)
                    img[i] = data[i];
                if (smpls == 3)
                  for (var i = 0; i < area; i++) {
                    var qi = i << 2, ti = i * 3;
                    img[qi] = data[ti];
                    img[qi + 1] = data[ti + 1];
                    img[qi + 2] = data[ti + 2];
                    img[qi + 3] = 255;
                  }
              }
            } else
              for (var i = 0; i < area; i++) {
                var qi = i << 2, ti = i * 6;
                img[qi] = data[ti];
                img[qi + 1] = data[ti + 2];
                img[qi + 2] = data[ti + 4];
                img[qi + 3] = 255;
              }
          } else if (intp == 3) {
            var map = out["t320"];
            for (var i = 0; i < area; i++) {
              var qi = i << 2, mi = data[i];
              img[qi] = map[mi] >> 8;
              img[qi + 1] = map[256 + mi] >> 8;
              img[qi + 2] = map[512 + mi] >> 8;
              img[qi + 3] = 255;
            }
          } else if (intp == 5) {
            var smpls = out["t258"] ? out["t258"].length : 4;
            var gotAlpha = smpls > 4 ? 1 : 0;
            for (var i = 0; i < area; i++) {
              var qi = i << 2, si = i * smpls;
              var C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
              img[qi] = ~~(C * K + 0.5);
              img[qi + 1] = ~~(M * K + 0.5);
              img[qi + 2] = ~~(Y * K + 0.5);
              img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
            }
          } else
            log("Unknown Photometric interpretation: " + intp);
          return img;
        };
        UTIF2.replaceIMG = function() {
          var imgs = document.getElementsByTagName("img");
          for (var i = 0; i < imgs.length; i++) {
            var img = imgs[i], src2 = img.getAttribute("src");
            if (src2 == null)
              continue;
            var suff = src2.split(".").pop().toLowerCase();
            if (suff != "tif" && suff != "tiff")
              continue;
            var xhr = new XMLHttpRequest();
            UTIF2._xhrs.push(xhr);
            UTIF2._imgs.push(img);
            xhr.open("GET", src2);
            xhr.responseType = "arraybuffer";
            xhr.onload = UTIF2._imgLoaded;
            xhr.send();
          }
        };
        UTIF2._xhrs = [];
        UTIF2._imgs = [];
        UTIF2._imgLoaded = function(e) {
          var buff = e.target.response;
          var ifds = UTIF2.decode(buff), page2 = ifds[0];
          UTIF2.decodeImages(buff, ifds);
          var rgba = UTIF2.toRGBA8(page2), w = page2.width, h = page2.height;
          var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
          UTIF2._xhrs.splice(ind, 1);
          UTIF2._imgs.splice(ind, 1);
          var cnv = document.createElement("canvas");
          cnv.width = w;
          cnv.height = h;
          var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w, h);
          for (var i = 0; i < rgba.length; i++)
            imgd.data[i] = rgba[i];
          ctx.putImageData(imgd, 0, 0);
          var attr = ["style", "class", "id"];
          for (var i = 0; i < attr.length; i++)
            cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
          img.parentNode.replaceChild(cnv, img);
        };
        UTIF2._binBE = {
          nextZero: function(data, o) {
            while (data[o] != 0)
              o++;
            return o;
          },
          readUshort: function(buff, p) {
            return buff[p] << 8 | buff[p + 1];
          },
          readShort: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 1];
            a[1] = buff[p + 0];
            return UTIF2._binBE.i16[0];
          },
          readInt: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 3];
            a[1] = buff[p + 2];
            a[2] = buff[p + 1];
            a[3] = buff[p + 0];
            return UTIF2._binBE.i32[0];
          },
          readUint: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 3];
            a[1] = buff[p + 2];
            a[2] = buff[p + 1];
            a[3] = buff[p + 0];
            return UTIF2._binBE.ui32[0];
          },
          readASCII: function(buff, p, l) {
            var s2 = "";
            for (var i = 0; i < l; i++)
              s2 += String.fromCharCode(buff[p + i]);
            return s2;
          },
          readFloat: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i = 0; i < 4; i++)
              a[i] = buff[p + 3 - i];
            return UTIF2._binBE.fl32[0];
          },
          readDouble: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i = 0; i < 8; i++)
              a[i] = buff[p + 7 - i];
            return UTIF2._binBE.fl64[0];
          },
          writeUshort: function(buff, p, n) {
            buff[p] = n >> 8 & 255;
            buff[p + 1] = n & 255;
          },
          writeUint: function(buff, p, n) {
            buff[p] = n >> 24 & 255;
            buff[p + 1] = n >> 16 & 255;
            buff[p + 2] = n >> 8 & 255;
            buff[p + 3] = n >> 0 & 255;
          },
          writeASCII: function(buff, p, s2) {
            for (var i = 0; i < s2.length; i++)
              buff[p + i] = s2.charCodeAt(i);
          },
          writeDouble: function(buff, p, n) {
            UTIF2._binBE.fl64[0] = n;
            for (var i = 0; i < 8; i++)
              buff[p + i] = UTIF2._binBE.ui8[7 - i];
          }
        };
        UTIF2._binBE.ui8 = new Uint8Array(8);
        UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binLE = {
          nextZero: UTIF2._binBE.nextZero,
          readUshort: function(buff, p) {
            return buff[p + 1] << 8 | buff[p];
          },
          readShort: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            return UTIF2._binBE.i16[0];
          },
          readInt: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            a[2] = buff[p + 2];
            a[3] = buff[p + 3];
            return UTIF2._binBE.i32[0];
          },
          readUint: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            a[2] = buff[p + 2];
            a[3] = buff[p + 3];
            return UTIF2._binBE.ui32[0];
          },
          readASCII: UTIF2._binBE.readASCII,
          readFloat: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i = 0; i < 4; i++)
              a[i] = buff[p + i];
            return UTIF2._binBE.fl32[0];
          },
          readDouble: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i = 0; i < 8; i++)
              a[i] = buff[p + i];
            return UTIF2._binBE.fl64[0];
          }
        };
        UTIF2._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
          var xlim = Math.min(tw, w - xoff);
          var ylim = Math.min(th, h - yoff);
          for (var y = 0; y < ylim; y++) {
            var tof = (yoff + y) * w + xoff;
            var sof = y * tw;
            for (var x = 0; x < xlim; x++)
              b[tof + x] = tb[sof + x];
          }
        };
      })(UTIF, pako);
    })();
  }
});

// node_modules/@jimp/tiff/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@jimp/tiff/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _utif = _interopRequireDefault(require_UTIF());
    var MIME_TYPE = "image/tiff";
    var _default = function _default2() {
      return {
        mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["tiff", "tif"]),
        constants: {
          MIME_TIFF: MIME_TYPE
        },
        decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
          var ifds = _utif["default"].decode(data);
          var page2 = ifds[0];
          _utif["default"].decodeImages(data, ifds);
          var rgba = _utif["default"].toRGBA8(page2);
          return {
            data: Buffer.from(rgba),
            width: page2.t256[0],
            height: page2.t257[0]
          };
        }),
        encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image2) {
          var tiff = _utif["default"].encodeImage(image2.bitmap.data, image2.bitmap.width, image2.bitmap.height);
          return Buffer.from(tiff);
        })
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS({
  "node_modules/omggif/omggif.js"(exports) {
    init_shims();
    "use strict";
    function GifWriter(buf, width, height, gopts) {
      var p = 0;
      var gopts = gopts === void 0 ? {} : gopts;
      var loop_count = gopts.loop === void 0 ? null : gopts.loop;
      var global_palette = gopts.palette === void 0 ? null : gopts.palette;
      if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
        throw new Error("Width/Height invalid.");
      function check_palette_and_num_colors(palette) {
        var num_colors = palette.length;
        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
          throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
        }
        return num_colors;
      }
      buf[p++] = 71;
      buf[p++] = 73;
      buf[p++] = 70;
      buf[p++] = 56;
      buf[p++] = 57;
      buf[p++] = 97;
      var gp_num_colors_pow2 = 0;
      var background = 0;
      if (global_palette !== null) {
        var gp_num_colors = check_palette_and_num_colors(global_palette);
        while (gp_num_colors >>= 1)
          ++gp_num_colors_pow2;
        gp_num_colors = 1 << gp_num_colors_pow2;
        --gp_num_colors_pow2;
        if (gopts.background !== void 0) {
          background = gopts.background;
          if (background >= gp_num_colors)
            throw new Error("Background index out of range.");
          if (background === 0)
            throw new Error("Background index explicitly passed as 0.");
        }
      }
      buf[p++] = width & 255;
      buf[p++] = width >> 8 & 255;
      buf[p++] = height & 255;
      buf[p++] = height >> 8 & 255;
      buf[p++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
      buf[p++] = background;
      buf[p++] = 0;
      if (global_palette !== null) {
        for (var i = 0, il = global_palette.length; i < il; ++i) {
          var rgb = global_palette[i];
          buf[p++] = rgb >> 16 & 255;
          buf[p++] = rgb >> 8 & 255;
          buf[p++] = rgb & 255;
        }
      }
      if (loop_count !== null) {
        if (loop_count < 0 || loop_count > 65535)
          throw new Error("Loop count invalid.");
        buf[p++] = 33;
        buf[p++] = 255;
        buf[p++] = 11;
        buf[p++] = 78;
        buf[p++] = 69;
        buf[p++] = 84;
        buf[p++] = 83;
        buf[p++] = 67;
        buf[p++] = 65;
        buf[p++] = 80;
        buf[p++] = 69;
        buf[p++] = 50;
        buf[p++] = 46;
        buf[p++] = 48;
        buf[p++] = 3;
        buf[p++] = 1;
        buf[p++] = loop_count & 255;
        buf[p++] = loop_count >> 8 & 255;
        buf[p++] = 0;
      }
      var ended = false;
      this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
        if (ended === true) {
          --p;
          ended = false;
        }
        opts = opts === void 0 ? {} : opts;
        if (x < 0 || y < 0 || x > 65535 || y > 65535)
          throw new Error("x/y invalid.");
        if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
          throw new Error("Width/Height invalid.");
        if (indexed_pixels.length < w * h)
          throw new Error("Not enough pixels for the frame size.");
        var using_local_palette = true;
        var palette = opts.palette;
        if (palette === void 0 || palette === null) {
          using_local_palette = false;
          palette = global_palette;
        }
        if (palette === void 0 || palette === null)
          throw new Error("Must supply either a local or global palette.");
        var num_colors = check_palette_and_num_colors(palette);
        var min_code_size = 0;
        while (num_colors >>= 1)
          ++min_code_size;
        num_colors = 1 << min_code_size;
        var delay = opts.delay === void 0 ? 0 : opts.delay;
        var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
        if (disposal < 0 || disposal > 3)
          throw new Error("Disposal out of range.");
        var use_transparency = false;
        var transparent_index = 0;
        if (opts.transparent !== void 0 && opts.transparent !== null) {
          use_transparency = true;
          transparent_index = opts.transparent;
          if (transparent_index < 0 || transparent_index >= num_colors)
            throw new Error("Transparent color index.");
        }
        if (disposal !== 0 || use_transparency || delay !== 0) {
          buf[p++] = 33;
          buf[p++] = 249;
          buf[p++] = 4;
          buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
          buf[p++] = delay & 255;
          buf[p++] = delay >> 8 & 255;
          buf[p++] = transparent_index;
          buf[p++] = 0;
        }
        buf[p++] = 44;
        buf[p++] = x & 255;
        buf[p++] = x >> 8 & 255;
        buf[p++] = y & 255;
        buf[p++] = y >> 8 & 255;
        buf[p++] = w & 255;
        buf[p++] = w >> 8 & 255;
        buf[p++] = h & 255;
        buf[p++] = h >> 8 & 255;
        buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
        if (using_local_palette === true) {
          for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
            var rgb2 = palette[i2];
            buf[p++] = rgb2 >> 16 & 255;
            buf[p++] = rgb2 >> 8 & 255;
            buf[p++] = rgb2 & 255;
          }
        }
        p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
        return p;
      };
      this.end = function() {
        if (ended === false) {
          buf[p++] = 59;
          ended = true;
        }
        return p;
      };
      this.getOutputBuffer = function() {
        return buf;
      };
      this.setOutputBuffer = function(v) {
        buf = v;
      };
      this.getOutputBufferPosition = function() {
        return p;
      };
      this.setOutputBufferPosition = function(v) {
        p = v;
      };
    }
    function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
      buf[p++] = min_code_size;
      var cur_subblock = p++;
      var clear_code = 1 << min_code_size;
      var code_mask = clear_code - 1;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var cur_shift = 0;
      var cur = 0;
      function emit_bytes_to_buffer(bit_block_size) {
        while (cur_shift >= bit_block_size) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
      }
      function emit_code(c) {
        cur |= c << cur_shift;
        cur_shift += cur_code_size;
        emit_bytes_to_buffer(8);
      }
      var ib_code = index_stream[0] & code_mask;
      var code_table = {};
      emit_code(clear_code);
      for (var i = 1, il = index_stream.length; i < il; ++i) {
        var k = index_stream[i] & code_mask;
        var cur_key = ib_code << 8 | k;
        var cur_code = code_table[cur_key];
        if (cur_code === void 0) {
          cur |= ib_code << cur_shift;
          cur_shift += cur_code_size;
          while (cur_shift >= 8) {
            buf[p++] = cur & 255;
            cur >>= 8;
            cur_shift -= 8;
            if (p === cur_subblock + 256) {
              buf[cur_subblock] = 255;
              cur_subblock = p++;
            }
          }
          if (next_code === 4096) {
            emit_code(clear_code);
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_table = {};
          } else {
            if (next_code >= 1 << cur_code_size)
              ++cur_code_size;
            code_table[cur_key] = next_code++;
          }
          ib_code = k;
        } else {
          ib_code = cur_code;
        }
      }
      emit_code(ib_code);
      emit_code(eoi_code);
      emit_bytes_to_buffer(1);
      if (cur_subblock + 1 === p) {
        buf[cur_subblock] = 0;
      } else {
        buf[cur_subblock] = p - cur_subblock - 1;
        buf[p++] = 0;
      }
      return p;
    }
    function GifReader(buf) {
      var p = 0;
      if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
        throw new Error("Invalid GIF 87a/89a header.");
      }
      var width = buf[p++] | buf[p++] << 8;
      var height = buf[p++] | buf[p++] << 8;
      var pf0 = buf[p++];
      var global_palette_flag = pf0 >> 7;
      var num_global_colors_pow2 = pf0 & 7;
      var num_global_colors = 1 << num_global_colors_pow2 + 1;
      var background = buf[p++];
      buf[p++];
      var global_palette_offset = null;
      var global_palette_size = null;
      if (global_palette_flag) {
        global_palette_offset = p;
        global_palette_size = num_global_colors;
        p += num_global_colors * 3;
      }
      var no_eof = true;
      var frames = [];
      var delay = 0;
      var transparent_index = null;
      var disposal = 0;
      var loop_count = null;
      this.width = width;
      this.height = height;
      while (no_eof && p < buf.length) {
        switch (buf[p++]) {
          case 33:
            switch (buf[p++]) {
              case 255:
                if (buf[p] !== 11 || buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                  p += 14;
                  loop_count = buf[p++] | buf[p++] << 8;
                  p++;
                } else {
                  p += 12;
                  while (true) {
                    var block_size = buf[p++];
                    if (!(block_size >= 0))
                      throw Error("Invalid block size");
                    if (block_size === 0)
                      break;
                    p += block_size;
                  }
                }
                break;
              case 249:
                if (buf[p++] !== 4 || buf[p + 4] !== 0)
                  throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8;
                transparent_index = buf[p++];
                if ((pf1 & 1) === 0)
                  transparent_index = null;
                disposal = pf1 >> 2 & 7;
                p++;
                break;
              case 254:
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
                break;
              default:
                throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
            }
            break;
          case 44:
            var x = buf[p++] | buf[p++] << 8;
            var y = buf[p++] | buf[p++] << 8;
            var w = buf[p++] | buf[p++] << 8;
            var h = buf[p++] | buf[p++] << 8;
            var pf2 = buf[p++];
            var local_palette_flag = pf2 >> 7;
            var interlace_flag = pf2 >> 6 & 1;
            var num_local_colors_pow2 = pf2 & 7;
            var num_local_colors = 1 << num_local_colors_pow2 + 1;
            var palette_offset = global_palette_offset;
            var palette_size = global_palette_size;
            var has_local_palette = false;
            if (local_palette_flag) {
              var has_local_palette = true;
              palette_offset = p;
              palette_size = num_local_colors;
              p += num_local_colors * 3;
            }
            var data_offset = p;
            p++;
            while (true) {
              var block_size = buf[p++];
              if (!(block_size >= 0))
                throw Error("Invalid block size");
              if (block_size === 0)
                break;
              p += block_size;
            }
            frames.push({
              x,
              y,
              width: w,
              height: h,
              has_local_palette,
              palette_offset,
              palette_size,
              data_offset,
              data_length: p - data_offset,
              transparent_index,
              interlaced: !!interlace_flag,
              delay,
              disposal
            });
            break;
          case 59:
            no_eof = false;
            break;
          default:
            throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
            break;
        }
      }
      this.numFrames = function() {
        return frames.length;
      };
      this.loopCount = function() {
        return loop_count;
      };
      this.frameInfo = function(frame_num) {
        if (frame_num < 0 || frame_num >= frames.length)
          throw new Error("Frame index out of range.");
        return frames[frame_num];
      };
      this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index2 = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index2 === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index2 * 3];
            var g = buf[palette_offset2 + index2 * 3 + 1];
            var b = buf[palette_offset2 + index2 * 3 + 2];
            pixels[op++] = b;
            pixels[op++] = g;
            pixels[op++] = r;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
      this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index2 = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index2 === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index2 * 3];
            var g = buf[palette_offset2 + index2 * 3 + 1];
            var b = buf[palette_offset2 + index2 * 3 + 2];
            pixels[op++] = r;
            pixels[op++] = g;
            pixels[op++] = b;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
    }
    function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
      var min_code_size = code_stream[p++];
      var clear_code = 1 << min_code_size;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var code_mask = (1 << cur_code_size) - 1;
      var cur_shift = 0;
      var cur = 0;
      var op = 0;
      var subblock_size = code_stream[p++];
      var code_table = new Int32Array(4096);
      var prev_code = null;
      while (true) {
        while (cur_shift < 16) {
          if (subblock_size === 0)
            break;
          cur |= code_stream[p++] << cur_shift;
          cur_shift += 8;
          if (subblock_size === 1) {
            subblock_size = code_stream[p++];
          } else {
            --subblock_size;
          }
        }
        if (cur_shift < cur_code_size)
          break;
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
        if (code === clear_code) {
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_mask = (1 << cur_code_size) - 1;
          prev_code = null;
          continue;
        } else if (code === eoi_code) {
          break;
        }
        var chase_code = code < next_code ? code : prev_code;
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
          chase = code_table[chase] >> 8;
          ++chase_length;
        }
        var k = chase;
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
          console.log("Warning, gif stream longer than expected.");
          return;
        }
        output[op++] = k;
        op += chase_length;
        var b = op;
        if (chase_code !== code)
          output[op++] = k;
        chase = chase_code;
        while (chase_length--) {
          chase = code_table[chase];
          output[--b] = chase & 255;
          chase >>= 8;
        }
        if (prev_code !== null && next_code < 4096) {
          code_table[next_code++] = prev_code << 8 | k;
          if (next_code >= code_mask + 1 && cur_code_size < 12) {
            ++cur_code_size;
            code_mask = code_mask << 1 | 1;
          }
        }
        prev_code = code;
      }
      if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
      }
      return output;
    }
    try {
      exports.GifWriter = GifWriter;
      exports.GifReader = GifReader;
    } catch (e) {
    }
  }
});

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS({
  "node_modules/gifwrap/src/bitmapimage.js"(exports, module) {
    init_shims();
    "use strict";
    var BitmapImage = class {
      constructor(...args) {
        if (args.length === 0) {
          throw new Error("constructor requires parameters");
        }
        const firstArg = args[0];
        if (firstArg !== null && typeof firstArg === "object") {
          if (firstArg instanceof BitmapImage) {
            const sourceBitmap = firstArg.bitmap;
            this.bitmap = {
              width: sourceBitmap.width,
              height: sourceBitmap.height,
              data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
            };
            sourceBitmap.data.copy(this.bitmap.data);
          } else if (firstArg.width && firstArg.height && firstArg.data) {
            this.bitmap = firstArg;
          } else {
            throw new Error("unrecognized constructor parameters");
          }
        } else if (typeof firstArg === "number" && typeof args[1] === "number") {
          const width = firstArg;
          const height = args[1];
          const thirdArg = args[2];
          this.bitmap = { width, height };
          if (Buffer.isBuffer(thirdArg)) {
            this.bitmap.data = thirdArg;
          } else {
            this.bitmap.data = new Buffer(width * height * 4);
            if (typeof thirdArg === "number") {
              this.fillRGBA(thirdArg);
            }
          }
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      }
      blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
        if (fromX + fromWidth > this.bitmap.width) {
          throw new Error("copy exceeds width of source bitmap");
        }
        if (toX + fromWidth > toImage.bitmap.width) {
          throw new Error("copy exceeds width of target bitmap");
        }
        if (fromY + fromHeight > this.bitmap.height) {
          throw new Error("copy exceeds height of source bitmap");
        }
        if (toY + fromHeight > toImage.bitmap.height) {
          throw new Erro("copy exceeds height of target bitmap");
        }
        const sourceBuf = this.bitmap.data;
        const targetBuf = toImage.bitmap.data;
        const sourceByteWidth = this.bitmap.width * 4;
        const targetByteWidth = toImage.bitmap.width * 4;
        const copyByteWidth = fromWidth * 4;
        let si = fromY * sourceByteWidth + fromX * 4;
        let ti = toY * targetByteWidth + toX * 4;
        while (--fromHeight >= 0) {
          sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
          si += sourceByteWidth;
          ti += targetByteWidth;
        }
        return this;
      }
      fillRGBA(rgba) {
        const buf = this.bitmap.data;
        const bufByteWidth = this.bitmap.height * 4;
        let bi = 0;
        while (bi < bufByteWidth) {
          buf.writeUInt32BE(rgba, bi);
          bi += 4;
        }
        while (bi < buf.length) {
          buf.copy(buf, bi, 0, bufByteWidth);
          bi += bufByteWidth;
        }
        return this;
      }
      getRGBA(x, y) {
        const bi = (y * this.bitmap.width + x) * 4;
        return this.bitmap.data.readUInt32BE(bi);
      }
      getRGBASet() {
        const rgbaSet = new Set();
        const buf = this.bitmap.data;
        for (let bi = 0; bi < buf.length; bi += 4) {
          rgbaSet.add(buf.readUInt32BE(bi, true));
        }
        return rgbaSet;
      }
      greyscale() {
        const buf = this.bitmap.data;
        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
          const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
          buf[idx] = grey;
          buf[idx + 1] = grey;
          buf[idx + 2] = grey;
        });
        return this;
      }
      reframe(xOffset, yOffset, width, height, fillRGBA) {
        const cropX = xOffset < 0 ? 0 : xOffset;
        const cropY = yOffset < 0 ? 0 : yOffset;
        const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
        const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
        const newX = xOffset < 0 ? -xOffset : 0;
        const newY = yOffset < 0 ? -yOffset : 0;
        let image2;
        if (fillRGBA === void 0) {
          if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
            throw new GifError(`fillRGBA required for this reframing`);
          }
          image2 = new BitmapImage(width, height);
        } else {
          image2 = new BitmapImage(width, height, fillRGBA);
        }
        this.blit(image2, newX, newY, cropX, cropY, cropWidth, cropHeight);
        this.bitmap = image2.bitmap;
        return this;
      }
      scale(factor) {
        if (factor === 1) {
          return;
        }
        if (!Number.isInteger(factor) || factor < 1) {
          throw new Error("the scale must be an integer >= 1");
        }
        const sourceWidth = this.bitmap.width;
        const sourceHeight = this.bitmap.height;
        const destByteWidth = sourceWidth * factor * 4;
        const sourceBuf = this.bitmap.data;
        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
        let sourceIndex = 0;
        let priorDestRowIndex;
        let destIndex = 0;
        for (let y = 0; y < sourceHeight; ++y) {
          priorDestRowIndex = destIndex;
          for (let x = 0; x < sourceWidth; ++x) {
            const color = sourceBuf.readUInt32BE(sourceIndex, true);
            for (let cx = 0; cx < factor; ++cx) {
              destBuf.writeUInt32BE(color, destIndex);
              destIndex += 4;
            }
            sourceIndex += 4;
          }
          for (let cy = 1; cy < factor; ++cy) {
            destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
            destIndex += destByteWidth;
            priorDestRowIndex += destByteWidth;
          }
        }
        this.bitmap = {
          width: sourceWidth * factor,
          height: sourceHeight * factor,
          data: destBuf
        };
        return this;
      }
      scanAllCoords(scanHandler) {
        const width = this.bitmap.width;
        const bufferLength = this.bitmap.data.length;
        let x = 0;
        let y = 0;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(x, y, bi);
          if (++x === width) {
            x = 0;
            ++y;
          }
        }
      }
      scanAllIndexes(scanHandler) {
        const bufferLength = this.bitmap.data.length;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(bi);
        }
      }
    };
    module.exports = BitmapImage;
  }
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS({
  "node_modules/gifwrap/src/gif.js"(exports) {
    init_shims();
    "use strict";
    var Gif = class {
      constructor(buffer, frames, spec) {
        this.width = spec.width;
        this.height = spec.height;
        this.loops = spec.loops;
        this.usesTransparency = spec.usesTransparency;
        this.colorScope = spec.colorScope;
        this.frames = frames;
        this.buffer = buffer;
      }
    };
    Gif.GlobalColorsPreferred = 0;
    Gif.GlobalColorsOnly = 1;
    Gif.LocalColorsOnly = 2;
    var GifError2 = class extends Error {
      constructor(messageOrError) {
        super(messageOrError);
        if (messageOrError instanceof Error) {
          this.stack = "Gif" + messageOrError.stack;
        }
      }
    };
    exports.Gif = Gif;
    exports.GifError = GifError2;
  }
});

// node_modules/image-q/dist/iq.js
var require_iq = __commonJS({
  "node_modules/image-q/dist/iq.js"(exports, module) {
    init_shims();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("iq", [], factory);
      else if (typeof exports === "object")
        exports["iq"] = factory();
      else
        root["iq"] = factory();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var constants = __webpack_require__(1);
          exports2.constants = constants;
          var conversion = __webpack_require__(3);
          exports2.conversion = conversion;
          var distance = __webpack_require__(12);
          exports2.distance = distance;
          var palette = __webpack_require__(20);
          exports2.palette = palette;
          var image2 = __webpack_require__(30);
          exports2.image = image2;
          var quality = __webpack_require__(35);
          exports2.quality = quality;
          var utils = __webpack_require__(37);
          exports2.utils = utils;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709 = __webpack_require__(2);
          exports2.bt709 = bt709;
        },
        function(module2, exports2) {
          "use strict";
          var Y;
          (function(Y2) {
            Y2[Y2["RED"] = 0.2126] = "RED";
            Y2[Y2["GREEN"] = 0.7152] = "GREEN";
            Y2[Y2["BLUE"] = 0.0722] = "BLUE";
            Y2[Y2["WHITE"] = 1] = "WHITE";
          })(Y || (Y = {}));
          exports2.Y = Y;
          var x;
          (function(x2) {
            x2[x2["RED"] = 0.64] = "RED";
            x2[x2["GREEN"] = 0.3] = "GREEN";
            x2[x2["BLUE"] = 0.15] = "BLUE";
            x2[x2["WHITE"] = 0.3127] = "WHITE";
          })(x || (x = {}));
          exports2.x = x;
          var y;
          (function(y2) {
            y2[y2["RED"] = 0.33] = "RED";
            y2[y2["GREEN"] = 0.6] = "GREEN";
            y2[y2["BLUE"] = 0.06] = "BLUE";
            y2[y2["WHITE"] = 0.329] = "WHITE";
          })(y || (y = {}));
          exports2.y = y;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2xyz_1 = __webpack_require__(4);
          exports2.rgb2xyz = rgb2xyz_1.rgb2xyz;
          var rgb2hsl_1 = __webpack_require__(5);
          exports2.rgb2hsl = rgb2hsl_1.rgb2hsl;
          var rgb2lab_1 = __webpack_require__(7);
          exports2.rgb2lab = rgb2lab_1.rgb2lab;
          var lab2xyz_1 = __webpack_require__(9);
          exports2.lab2xyz = lab2xyz_1.lab2xyz;
          var lab2rgb_1 = __webpack_require__(10);
          exports2.lab2rgb = lab2rgb_1.lab2rgb;
          var xyz2lab_1 = __webpack_require__(8);
          exports2.xyz2lab = xyz2lab_1.xyz2lab;
          var xyz2rgb_1 = __webpack_require__(11);
          exports2.xyz2rgb = xyz2rgb_1.xyz2rgb;
        },
        function(module2, exports2) {
          "use strict";
          function correctGamma(n) {
            return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
          }
          function rgb2xyz(r, g, b) {
            r = correctGamma(r / 255);
            g = correctGamma(g / 255);
            b = correctGamma(b / 255);
            return {
              x: r * 0.4124 + g * 0.3576 + b * 0.1805,
              y: r * 0.2126 + g * 0.7152 + b * 0.0722,
              z: r * 0.0193 + g * 0.1192 + b * 0.9505
            };
          }
          exports2.rgb2xyz = rgb2xyz;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic_1 = __webpack_require__(6);
          function rgb2hsl(r, g, b) {
            var min = arithmetic_1.min3(r, g, b), max = arithmetic_1.max3(r, g, b), delta = max - min, l = (min + max) / 510;
            var s2 = 0;
            if (l > 0 && l < 1)
              s2 = delta / (l < 0.5 ? max + min : 510 - max - min);
            var h = 0;
            if (delta > 0) {
              if (max === r) {
                h = (g - b) / delta;
              } else if (max === g) {
                h = 2 + (b - r) / delta;
              } else {
                h = 4 + (r - g) / delta;
              }
              h *= 60;
              if (h < 0)
                h += 360;
            }
            return { h, s: s2, l };
          }
          exports2.rgb2hsl = rgb2hsl;
        },
        function(module2, exports2) {
          "use strict";
          function degrees2radians(n) {
            return n * (Math.PI / 180);
          }
          exports2.degrees2radians = degrees2radians;
          function max3(a, b, c) {
            var m = a;
            m < b && (m = b);
            m < c && (m = c);
            return m;
          }
          exports2.max3 = max3;
          function min3(a, b, c) {
            var m = a;
            m > b && (m = b);
            m > c && (m = c);
            return m;
          }
          exports2.min3 = min3;
          function intInRange(value, low, high) {
            if (value > high)
              value = high;
            if (value < low)
              value = low;
            return value | 0;
          }
          exports2.intInRange = intInRange;
          function inRange0to255Rounded(n) {
            n = Math.round(n);
            if (n > 255)
              n = 255;
            else if (n < 0)
              n = 0;
            return n;
          }
          exports2.inRange0to255Rounded = inRange0to255Rounded;
          function inRange0to255(n) {
            if (n > 255)
              n = 255;
            else if (n < 0)
              n = 0;
            return n;
          }
          exports2.inRange0to255 = inRange0to255;
          function stableSort(arrayToSort, callback) {
            var type = typeof arrayToSort[0];
            var sorted;
            if (type === "number" || type === "string") {
              var ord_1 = Object.create(null);
              for (var i = 0, l = arrayToSort.length; i < l; i++) {
                var val = arrayToSort[i];
                if (ord_1[val] || ord_1[val] === 0)
                  continue;
                ord_1[val] = i;
              }
              sorted = arrayToSort.sort(function(a, b) {
                return callback(a, b) || ord_1[a] - ord_1[b];
              });
            } else {
              var ord2_1 = arrayToSort.slice(0);
              sorted = arrayToSort.sort(function(a, b) {
                return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);
              });
            }
            return sorted;
          }
          exports2.stableSort = stableSort;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2xyz_1 = __webpack_require__(4);
          var xyz2lab_1 = __webpack_require__(8);
          function rgb2lab(r, g, b) {
            var xyz = rgb2xyz_1.rgb2xyz(r, g, b);
            return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);
          }
          exports2.rgb2lab = rgb2lab;
        },
        function(module2, exports2) {
          "use strict";
          var refX = 0.95047, refY = 1, refZ = 1.08883;
          function pivot(n) {
            return n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
          }
          function xyz2lab(x, y, z) {
            x = pivot(x / refX);
            y = pivot(y / refY);
            z = pivot(z / refZ);
            if (116 * y - 16 < 0)
              throw new Error("xxx");
            return {
              L: Math.max(0, 116 * y - 16),
              a: 500 * (x - y),
              b: 200 * (y - z)
            };
          }
          exports2.xyz2lab = xyz2lab;
        },
        function(module2, exports2) {
          "use strict";
          var refX = 0.95047, refY = 1, refZ = 1.08883;
          function pivot(n) {
            return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
          }
          function lab2xyz(L, a, b) {
            var y = (L + 16) / 116, x = a / 500 + y, z = y - b / 200;
            return {
              x: refX * pivot(x),
              y: refY * pivot(y),
              z: refZ * pivot(z)
            };
          }
          exports2.lab2xyz = lab2xyz;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var lab2xyz_1 = __webpack_require__(9);
          var xyz2rgb_1 = __webpack_require__(11);
          function lab2rgb(L, a, b) {
            var xyz = lab2xyz_1.lab2xyz(L, a, b);
            return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);
          }
          exports2.lab2rgb = lab2rgb;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic_1 = __webpack_require__(6);
          function correctGamma(n) {
            return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
          }
          function xyz2rgb(x, y, z) {
            var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986), g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415), b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);
            return {
              r: arithmetic_1.inRange0to255Rounded(r * 255),
              g: arithmetic_1.inRange0to255Rounded(g * 255),
              b: arithmetic_1.inRange0to255Rounded(b * 255)
            };
          }
          exports2.xyz2rgb = xyz2rgb;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          exports2.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;
          var cie94_1 = __webpack_require__(14);
          exports2.CIE94Textiles = cie94_1.CIE94Textiles;
          exports2.CIE94GraphicArts = cie94_1.CIE94GraphicArts;
          var ciede2000_1 = __webpack_require__(15);
          exports2.CIEDE2000 = ciede2000_1.CIEDE2000;
          var cmetric_1 = __webpack_require__(16);
          exports2.CMETRIC = cmetric_1.CMETRIC;
          var euclidean_1 = __webpack_require__(17);
          exports2.AbstractEuclidean = euclidean_1.AbstractEuclidean;
          exports2.Euclidean = euclidean_1.Euclidean;
          exports2.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha;
          exports2.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;
          var manhattan_1 = __webpack_require__(18);
          exports2.AbstractManhattan = manhattan_1.AbstractManhattan;
          exports2.Manhattan = manhattan_1.Manhattan;
          exports2.ManhattanSRGB = manhattan_1.ManhattanSRGB;
          exports2.ManhattanNommyde = manhattan_1.ManhattanNommyde;
          var pngQuant_1 = __webpack_require__(19);
          exports2.PNGQUANT = pngQuant_1.PNGQUANT;
        },
        function(module2, exports2) {
          "use strict";
          var AbstractDistanceCalculator = function() {
            function AbstractDistanceCalculator2() {
              this._setDefaults();
              this.setWhitePoint(255, 255, 255, 255);
            }
            AbstractDistanceCalculator2.prototype.setWhitePoint = function(r, g, b, a) {
              this._whitePoint = {
                r: r > 0 ? 255 / r : 0,
                g: g > 0 ? 255 / g : 0,
                b: b > 0 ? 255 / b : 0,
                a: a > 0 ? 255 / a : 0
              };
              this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
            };
            AbstractDistanceCalculator2.prototype.calculateNormalized = function(colorA, colorB) {
              return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
            };
            AbstractDistanceCalculator2.prototype._setDefaults = function() {
            };
            return AbstractDistanceCalculator2;
          }();
          exports2.AbstractDistanceCalculator = AbstractDistanceCalculator;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var rgb2lab_1 = __webpack_require__(7);
          var arithmetic_1 = __webpack_require__(6);
          var AbstractCIE94 = function(_super) {
            __extends(AbstractCIE942, _super);
            function AbstractCIE942() {
              _super.apply(this, arguments);
            }
            AbstractCIE942.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b));
              var dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b), dC = c1 - c2;
              var deltaH = dA * dA + dB * dB - dC * dC;
              deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
              var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
              return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1 + this._K1 * c1), 2) + Math.pow(deltaH / (1 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));
            };
            return AbstractCIE942;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractCIE94 = AbstractCIE94;
          var CIE94Textiles = function(_super) {
            __extends(CIE94Textiles2, _super);
            function CIE94Textiles2() {
              _super.apply(this, arguments);
            }
            CIE94Textiles2.prototype._setDefaults = function() {
              this._Kl = 2;
              this._K1 = 0.048;
              this._K2 = 0.014;
              this._kA = 0.25 * 50 / 255;
            };
            return CIE94Textiles2;
          }(AbstractCIE94);
          exports2.CIE94Textiles = CIE94Textiles;
          var CIE94GraphicArts = function(_super) {
            __extends(CIE94GraphicArts2, _super);
            function CIE94GraphicArts2() {
              _super.apply(this, arguments);
            }
            CIE94GraphicArts2.prototype._setDefaults = function() {
              this._Kl = 1;
              this._K1 = 0.045;
              this._K2 = 0.015;
              this._kA = 0.25 * 100 / 255;
            };
            return CIE94GraphicArts2;
          }(AbstractCIE94);
          exports2.CIE94GraphicArts = CIE94GraphicArts;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var rgb2lab_1 = __webpack_require__(7);
          var arithmetic_1 = __webpack_require__(6);
          var CIEDE2000 = function(_super) {
            __extends(CIEDE20002, _super);
            function CIEDE20002() {
              _super.apply(this, arguments);
            }
            CIEDE20002.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * CIEDE20002._kA, dE2 = this.calculateRawInLab(lab1, lab2);
              return Math.sqrt(dE2 + dA * dA);
            };
            CIEDE20002.prototype.calculateRawInLab = function(Lab1, Lab2) {
              var L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b;
              var L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b;
              var C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2, 7), G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE20002._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = CIEDE20002._calculatehp(b1, a1p), h2p = CIEDE20002._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = CIEDE20002._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = CIEDE20002._calculate_ahp(C1pC2p, h_bar, h1p, h2p), T = CIEDE20002._calculateT(ahp), aCp = (C1p + C2p) / 2, aLp_minus_50_square = Math.pow((L1 + L2) / 2 - 50, 2), S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square), S_C = 1 + 0.045 * aCp, S_H = 1 + 0.015 * T * aCp, R_T = CIEDE20002._calculateRT(ahp, aCp), dLpSL = dLp / S_L, dCpSC = dCp / S_C, dHpSH = dHp / S_H;
              return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
            };
            CIEDE20002._calculatehp = function(b, ap) {
              var hp = Math.atan2(b, ap);
              if (hp >= 0)
                return hp;
              return hp + CIEDE20002._deg360InRad;
            };
            CIEDE20002._calculateRT = function(ahp, aCp) {
              var aCp_to_7 = Math.pow(aCp, 7), R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE20002._pow25to7)), delta_theta = CIEDE20002._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE20002._deg275InRad) / CIEDE20002._deg25InRad, 2));
              return -Math.sin(2 * delta_theta) * R_C;
            };
            CIEDE20002._calculateT = function(ahp) {
              return 1 - 0.17 * Math.cos(ahp - CIEDE20002._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + CIEDE20002._deg6InRad) - 0.2 * Math.cos(ahp * 4 - CIEDE20002._deg63InRad);
            };
            CIEDE20002._calculate_ahp = function(C1pC2p, h_bar, h1p, h2p) {
              var hpSum = h1p + h2p;
              if (C1pC2p == 0)
                return hpSum;
              if (h_bar <= CIEDE20002._deg180InRad)
                return hpSum / 2;
              if (hpSum < CIEDE20002._deg360InRad)
                return (hpSum + CIEDE20002._deg360InRad) / 2;
              return (hpSum - CIEDE20002._deg360InRad) / 2;
            };
            CIEDE20002._calculate_dHp = function(C1pC2p, h_bar, h2p, h1p) {
              var dhp;
              if (C1pC2p == 0) {
                dhp = 0;
              } else if (h_bar <= CIEDE20002._deg180InRad) {
                dhp = h2p - h1p;
              } else if (h2p <= h1p) {
                dhp = h2p - h1p + CIEDE20002._deg360InRad;
              } else {
                dhp = h2p - h1p - CIEDE20002._deg360InRad;
              }
              return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
            };
            CIEDE20002._kA = 0.25 * 100 / 255;
            CIEDE20002._pow25to7 = Math.pow(25, 7);
            CIEDE20002._deg360InRad = arithmetic_1.degrees2radians(360);
            CIEDE20002._deg180InRad = arithmetic_1.degrees2radians(180);
            CIEDE20002._deg30InRad = arithmetic_1.degrees2radians(30);
            CIEDE20002._deg6InRad = arithmetic_1.degrees2radians(6);
            CIEDE20002._deg63InRad = arithmetic_1.degrees2radians(63);
            CIEDE20002._deg275InRad = arithmetic_1.degrees2radians(275);
            CIEDE20002._deg25InRad = arithmetic_1.degrees2radians(25);
            return CIEDE20002;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.CIEDE2000 = CIEDE2000;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var CMETRIC = function(_super) {
            __extends(CMETRIC2, _super);
            function CMETRIC2() {
              _super.apply(this, arguments);
            }
            CMETRIC2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
              return Math.sqrt(dE + dA * dA);
            };
            return CMETRIC2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.CMETRIC = CMETRIC;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var bt709_1 = __webpack_require__(2);
          var AbstractEuclidean = function(_super) {
            __extends(AbstractEuclidean2, _super);
            function AbstractEuclidean2() {
              _super.apply(this, arguments);
            }
            AbstractEuclidean2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
              return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
            };
            return AbstractEuclidean2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractEuclidean = AbstractEuclidean;
          var Euclidean = function(_super) {
            __extends(Euclidean2, _super);
            function Euclidean2() {
              _super.apply(this, arguments);
            }
            Euclidean2.prototype._setDefaults = function() {
              this._kR = 1;
              this._kG = 1;
              this._kB = 1;
              this._kA = 1;
            };
            return Euclidean2;
          }(AbstractEuclidean);
          exports2.Euclidean = Euclidean;
          var EuclideanRgbQuantWithAlpha = function(_super) {
            __extends(EuclideanRgbQuantWithAlpha2, _super);
            function EuclideanRgbQuantWithAlpha2() {
              _super.apply(this, arguments);
            }
            EuclideanRgbQuantWithAlpha2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 1;
            };
            return EuclideanRgbQuantWithAlpha2;
          }(AbstractEuclidean);
          exports2.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;
          var EuclideanRgbQuantWOAlpha = function(_super) {
            __extends(EuclideanRgbQuantWOAlpha2, _super);
            function EuclideanRgbQuantWOAlpha2() {
              _super.apply(this, arguments);
            }
            EuclideanRgbQuantWOAlpha2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 0;
            };
            return EuclideanRgbQuantWOAlpha2;
          }(AbstractEuclidean);
          exports2.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var bt709_1 = __webpack_require__(2);
          var AbstractManhattan = function(_super) {
            __extends(AbstractManhattan2, _super);
            function AbstractManhattan2() {
              _super.apply(this, arguments);
            }
            AbstractManhattan2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
              if (dR < 0)
                dR = 0 - dR;
              if (dG < 0)
                dG = 0 - dG;
              if (dB < 0)
                dB = 0 - dB;
              if (dA < 0)
                dA = 0 - dA;
              return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
            };
            return AbstractManhattan2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractManhattan = AbstractManhattan;
          var Manhattan = function(_super) {
            __extends(Manhattan2, _super);
            function Manhattan2() {
              _super.apply(this, arguments);
            }
            Manhattan2.prototype._setDefaults = function() {
              this._kR = 1;
              this._kG = 1;
              this._kB = 1;
              this._kA = 1;
            };
            return Manhattan2;
          }(AbstractManhattan);
          exports2.Manhattan = Manhattan;
          var ManhattanNommyde = function(_super) {
            __extends(ManhattanNommyde2, _super);
            function ManhattanNommyde2() {
              _super.apply(this, arguments);
            }
            ManhattanNommyde2.prototype._setDefaults = function() {
              this._kR = 0.4984;
              this._kG = 0.8625;
              this._kB = 0.2979;
              this._kA = 1;
            };
            return ManhattanNommyde2;
          }(AbstractManhattan);
          exports2.ManhattanNommyde = ManhattanNommyde;
          var ManhattanSRGB = function(_super) {
            __extends(ManhattanSRGB2, _super);
            function ManhattanSRGB2() {
              _super.apply(this, arguments);
            }
            ManhattanSRGB2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 1;
            };
            return ManhattanSRGB2;
          }(AbstractManhattan);
          exports2.ManhattanSRGB = ManhattanSRGB;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d2, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d2[p] = b[p];
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var PNGQUANT = function(_super) {
            __extends(PNGQUANT2, _super);
            function PNGQUANT2() {
              _super.apply(this, arguments);
            }
            PNGQUANT2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var alphas = (a2 - a1) * this._whitePoint.a;
              return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
            };
            PNGQUANT2.prototype._colordifference_ch = function(x, y, alphas) {
              var black = x - y, white = black + alphas;
              return black * black + white * white;
            };
            return PNGQUANT2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.PNGQUANT = PNGQUANT;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var neuquant_1 = __webpack_require__(21);
          exports2.NeuQuant = neuquant_1.NeuQuant;
          var neuquantFloat_1 = __webpack_require__(25);
          exports2.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;
          var rgbquant_1 = __webpack_require__(26);
          exports2.RGBQuant = rgbquant_1.RGBQuant;
          var colorHistogram_1 = __webpack_require__(27);
          exports2.ColorHistogram = colorHistogram_1.ColorHistogram;
          var wuQuant_1 = __webpack_require__(29);
          exports2.WuQuant = wuQuant_1.WuQuant;
          exports2.WuColorCube = wuQuant_1.WuColorCube;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var networkBiasShift = 3;
          var Neuron = function() {
            function Neuron2(defaultValue) {
              this.r = this.g = this.b = this.a = defaultValue;
            }
            Neuron2.prototype.toPoint = function() {
              return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
            };
            Neuron2.prototype.subtract = function(r, g, b, a) {
              this.r -= r | 0;
              this.g -= g | 0;
              this.b -= b | 0;
              this.a -= a | 0;
            };
            return Neuron2;
          }();
          var NeuQuant = function() {
            function NeuQuant2(colorDistanceCalculator, colors) {
              if (colors === void 0) {
                colors = 256;
              }
              this._distance = colorDistanceCalculator;
              this._pointArray = [];
              this._sampleFactor = 1;
              this._networkSize = colors;
              this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
            }
            NeuQuant2.prototype.sample = function(pointBuffer) {
              this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
            };
            NeuQuant2.prototype.quantize = function() {
              this._init();
              this._learn();
              return this._buildPalette();
            };
            NeuQuant2.prototype._init = function() {
              this._freq = [];
              this._bias = [];
              this._radPower = [];
              this._network = [];
              for (var i = 0; i < this._networkSize; i++) {
                this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
                this._freq[i] = NeuQuant2._initialBias / this._networkSize | 0;
                this._bias[i] = 0;
              }
            };
            NeuQuant2.prototype._learn = function() {
              var sampleFactor = this._sampleFactor;
              var pointsNumber = this._pointArray.length;
              if (pointsNumber < NeuQuant2._minpicturebytes)
                sampleFactor = 1;
              var alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
              var delta = pointsToSample / NeuQuant2._nCycles | 0, alpha = NeuQuant2._initAlpha, radius = (this._networkSize >> 3) * NeuQuant2._radiusBias;
              var rad = radius >> NeuQuant2._radiusBiasShift;
              if (rad <= 1)
                rad = 0;
              for (var i = 0; i < rad; i++) {
                this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant2._radBias / (rad * rad)) >>> 0;
              }
              var step;
              if (pointsNumber < NeuQuant2._minpicturebytes) {
                step = 1;
              } else if (pointsNumber % NeuQuant2._prime1 != 0) {
                step = NeuQuant2._prime1;
              } else if (pointsNumber % NeuQuant2._prime2 != 0) {
                step = NeuQuant2._prime2;
              } else if (pointsNumber % NeuQuant2._prime3 != 0) {
                step = NeuQuant2._prime3;
              } else {
                step = NeuQuant2._prime4;
              }
              for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                this._alterSingle(alpha, neuronIndex, b, g, r, a);
                if (rad !== 0)
                  this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                pointIndex += step;
                if (pointIndex >= pointsNumber)
                  pointIndex -= pointsNumber;
                i++;
                if (delta === 0)
                  delta = 1;
                if (i % delta === 0) {
                  alpha -= alpha / alphadec | 0;
                  radius -= radius / NeuQuant2._radiusDecrease | 0;
                  rad = radius >> NeuQuant2._radiusBiasShift;
                  if (rad <= 1)
                    rad = 0;
                  for (var j = 0; j < rad; j++)
                    this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant2._radBias / (rad * rad)) >>> 0;
                }
              }
            };
            NeuQuant2.prototype._buildPalette = function() {
              var palette = new palette_1.Palette();
              this._network.forEach(function(neuron) {
                palette.add(neuron.toPoint());
              });
              palette.sort();
              return palette;
            };
            NeuQuant2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
              var lo = i - rad;
              if (lo < -1)
                lo = -1;
              var hi = i + rad;
              if (hi > this._networkSize)
                hi = this._networkSize;
              var j = i + 1, k = i - 1, m = 1;
              while (j < hi || k > lo) {
                var a = this._radPower[m++] / NeuQuant2._alphaRadBias;
                if (j < hi) {
                  var p = this._network[j++];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
                if (k > lo) {
                  var p = this._network[k--];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
              }
            };
            NeuQuant2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
              alpha /= NeuQuant2._initAlpha;
              var n = this._network[i];
              n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
            };
            NeuQuant2.prototype._contest = function(b, g, r, a) {
              var multiplier = 255 * 4 << networkBiasShift;
              var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
              for (var i = 0; i < this._networkSize; i++) {
                var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
                if (dist < bestd) {
                  bestd = dist;
                  bestpos = i;
                }
                var biasdist = dist - (this._bias[i] >> NeuQuant2._initialBiasShift - networkBiasShift);
                if (biasdist < bestbiasd) {
                  bestbiasd = biasdist;
                  bestbiaspos = i;
                }
                var betafreq = this._freq[i] >> NeuQuant2._betaShift;
                this._freq[i] -= betafreq;
                this._bias[i] += betafreq << NeuQuant2._gammaShift;
              }
              this._freq[bestpos] += NeuQuant2._beta;
              this._bias[bestpos] -= NeuQuant2._betaGamma;
              return bestbiaspos;
            };
            NeuQuant2._prime1 = 499;
            NeuQuant2._prime2 = 491;
            NeuQuant2._prime3 = 487;
            NeuQuant2._prime4 = 503;
            NeuQuant2._minpicturebytes = NeuQuant2._prime4;
            NeuQuant2._nCycles = 100;
            NeuQuant2._initialBiasShift = 16;
            NeuQuant2._initialBias = 1 << NeuQuant2._initialBiasShift;
            NeuQuant2._gammaShift = 10;
            NeuQuant2._betaShift = 10;
            NeuQuant2._beta = NeuQuant2._initialBias >> NeuQuant2._betaShift;
            NeuQuant2._betaGamma = NeuQuant2._initialBias << NeuQuant2._gammaShift - NeuQuant2._betaShift;
            NeuQuant2._radiusBiasShift = 6;
            NeuQuant2._radiusBias = 1 << NeuQuant2._radiusBiasShift;
            NeuQuant2._radiusDecrease = 30;
            NeuQuant2._alphaBiasShift = 10;
            NeuQuant2._initAlpha = 1 << NeuQuant2._alphaBiasShift;
            NeuQuant2._radBiasShift = 8;
            NeuQuant2._radBias = 1 << NeuQuant2._radBiasShift;
            NeuQuant2._alphaRadBiasShift = NeuQuant2._alphaBiasShift + NeuQuant2._radBiasShift;
            NeuQuant2._alphaRadBias = 1 << NeuQuant2._alphaRadBiasShift;
            return NeuQuant2;
          }();
          exports2.NeuQuant = NeuQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var pointContainer_1 = __webpack_require__(23);
          var rgb2hsl_1 = __webpack_require__(5);
          var hueGroups = 10;
          function hueGroup(hue, segmentsNumber) {
            var maxHue = 360, seg = maxHue / segmentsNumber, half = seg / 2;
            for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
              if (hue >= mid && hue < mid + seg)
                return i;
            }
            return 0;
          }
          exports2.hueGroup = hueGroup;
          var Palette = function() {
            function Palette2() {
              this._pointArray = [];
              this._i32idx = {};
              this._pointContainer = new pointContainer_1.PointContainer();
              this._pointContainer.setHeight(1);
              this._pointArray = this._pointContainer.getPointArray();
            }
            Palette2.prototype.add = function(color) {
              this._pointArray.push(color);
              this._pointContainer.setWidth(this._pointArray.length);
            };
            Palette2.prototype.has = function(color) {
              for (var i = this._pointArray.length - 1; i >= 0; i--) {
                if (color.uint32 === this._pointArray[i].uint32)
                  return true;
              }
              return false;
            };
            Palette2.prototype.getNearestColor = function(colorDistanceCalculator, color) {
              return this._pointArray[this.getNearestIndex(colorDistanceCalculator, color) | 0];
            };
            Palette2.prototype.getPointContainer = function() {
              return this._pointContainer;
            };
            Palette2.prototype._nearestPointFromCache = function(key) {
              return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
            };
            Palette2.prototype.getNearestIndex = function(colorDistanceCalculator, point) {
              var idx = this._nearestPointFromCache("" + point.uint32);
              if (idx >= 0)
                return idx;
              var minimalDistance = Number.MAX_VALUE;
              idx = 0;
              for (var i = 0, l = this._pointArray.length; i < l; i++) {
                var p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
                if (distance < minimalDistance) {
                  minimalDistance = distance;
                  idx = i;
                }
              }
              this._i32idx[point.uint32] = idx;
              return idx;
            };
            Palette2.prototype.sort = function() {
              this._i32idx = {};
              this._pointArray.sort(function(a, b) {
                var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b), hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);
                var hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups), hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
                var hueDiff = hueB - hueA;
                if (hueDiff)
                  return -hueDiff;
                var lA = a.getLuminosity(true), lB = b.getLuminosity(true);
                if (lB - lA !== 0)
                  return lB - lA;
                var satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
                if (satDiff)
                  return -satDiff;
                return 0;
              });
            };
            return Palette2;
          }();
          exports2.Palette = Palette;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var point_1 = __webpack_require__(24);
          var PointContainer = function() {
            function PointContainer2() {
              this._width = 0;
              this._height = 0;
              this._pointArray = [];
            }
            PointContainer2.prototype.getWidth = function() {
              return this._width;
            };
            PointContainer2.prototype.getHeight = function() {
              return this._height;
            };
            PointContainer2.prototype.setWidth = function(width) {
              this._width = width;
            };
            PointContainer2.prototype.setHeight = function(height) {
              this._height = height;
            };
            PointContainer2.prototype.getPointArray = function() {
              return this._pointArray;
            };
            PointContainer2.prototype.clone = function() {
              var clone2 = new PointContainer2();
              clone2._width = this._width;
              clone2._height = this._height;
              for (var i = 0, l = this._pointArray.length; i < l; i++) {
                clone2._pointArray[i] = point_1.Point.createByUint32(this._pointArray[i].uint32 | 0);
              }
              return clone2;
            };
            PointContainer2.prototype.toUint32Array = function() {
              var l = this._pointArray.length, uint32Array = new Uint32Array(l);
              for (var i = 0; i < l; i++) {
                uint32Array[i] = this._pointArray[i].uint32;
              }
              return uint32Array;
            };
            PointContainer2.prototype.toUint8Array = function() {
              return new Uint8Array(this.toUint32Array().buffer);
            };
            PointContainer2.fromHTMLImageElement = function(img) {
              var width = img.naturalWidth, height = img.naturalHeight;
              var canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              var ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
              return PointContainer2.fromHTMLCanvasElement(canvas);
            };
            PointContainer2.fromHTMLCanvasElement = function(canvas) {
              var width = canvas.width, height = canvas.height;
              var ctx = canvas.getContext("2d"), imgData = ctx.getImageData(0, 0, width, height);
              return PointContainer2.fromImageData(imgData);
            };
            PointContainer2.fromNodeCanvas = function(canvas) {
              return PointContainer2.fromHTMLCanvasElement(canvas);
            };
            PointContainer2.fromImageData = function(imageData) {
              var width = imageData.width, height = imageData.height;
              return PointContainer2.fromCanvasPixelArray(imageData.data, width, height);
            };
            PointContainer2.fromArray = function(byteArray, width, height) {
              var uint8array = new Uint8Array(byteArray);
              return PointContainer2.fromUint8Array(uint8array, width, height);
            };
            PointContainer2.fromCanvasPixelArray = function(data, width, height) {
              return PointContainer2.fromArray(data, width, height);
            };
            PointContainer2.fromUint8Array = function(uint8array, width, height) {
              return PointContainer2.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);
            };
            PointContainer2.fromUint32Array = function(uint32array, width, height) {
              var container = new PointContainer2();
              container._width = width;
              container._height = height;
              for (var i = 0, l = uint32array.length; i < l; i++) {
                container._pointArray[i] = point_1.Point.createByUint32(uint32array[i] | 0);
              }
              return container;
            };
            return PointContainer2;
          }();
          exports2.PointContainer = PointContainer;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709_1 = __webpack_require__(2);
          var Point = function() {
            function Point2() {
              this.uint32 = -1 >>> 0;
              this.r = this.g = this.b = this.a = 0;
              this.rgba = new Array(4);
              this.rgba[0] = 0;
              this.rgba[1] = 0;
              this.rgba[2] = 0;
              this.rgba[3] = 0;
            }
            Point2.createByQuadruplet = function(quadruplet) {
              var point = new Point2();
              point.r = quadruplet[0] | 0;
              point.g = quadruplet[1] | 0;
              point.b = quadruplet[2] | 0;
              point.a = quadruplet[3] | 0;
              point._loadUINT32();
              point._loadQuadruplet();
              return point;
            };
            Point2.createByRGBA = function(red, green, blue, alpha) {
              var point = new Point2();
              point.r = red | 0;
              point.g = green | 0;
              point.b = blue | 0;
              point.a = alpha | 0;
              point._loadUINT32();
              point._loadQuadruplet();
              return point;
            };
            Point2.createByUint32 = function(uint32) {
              var point = new Point2();
              point.uint32 = uint32 >>> 0;
              point._loadRGBA();
              point._loadQuadruplet();
              return point;
            };
            Point2.prototype.from = function(point) {
              this.r = point.r;
              this.g = point.g;
              this.b = point.b;
              this.a = point.a;
              this.uint32 = point.uint32;
              this.rgba[0] = point.r;
              this.rgba[1] = point.g;
              this.rgba[2] = point.b;
              this.rgba[3] = point.a;
            };
            Point2.prototype.getLuminosity = function(useAlphaChannel) {
              var r = this.r, g = this.g, b = this.b;
              if (useAlphaChannel) {
                r = Math.min(255, 255 - this.a + this.a * r / 255);
                g = Math.min(255, 255 - this.a + this.a * g / 255);
                b = Math.min(255, 255 - this.a + this.a * b / 255);
              }
              return r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;
            };
            Point2.prototype._loadUINT32 = function() {
              this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
            };
            Point2.prototype._loadRGBA = function() {
              this.r = this.uint32 & 255;
              this.g = this.uint32 >>> 8 & 255;
              this.b = this.uint32 >>> 16 & 255;
              this.a = this.uint32 >>> 24 & 255;
            };
            Point2.prototype._loadQuadruplet = function() {
              this.rgba[0] = this.r;
              this.rgba[1] = this.g;
              this.rgba[2] = this.b;
              this.rgba[3] = this.a;
            };
            return Point2;
          }();
          exports2.Point = Point;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var networkBiasShift = 3;
          var NeuronFloat = function() {
            function NeuronFloat2(defaultValue) {
              this.r = this.g = this.b = this.a = defaultValue;
            }
            NeuronFloat2.prototype.toPoint = function() {
              return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
            };
            NeuronFloat2.prototype.subtract = function(r, g, b, a) {
              this.r -= r;
              this.g -= g;
              this.b -= b;
              this.a -= a;
            };
            return NeuronFloat2;
          }();
          var NeuQuantFloat = function() {
            function NeuQuantFloat2(colorDistanceCalculator, colors) {
              if (colors === void 0) {
                colors = 256;
              }
              this._distance = colorDistanceCalculator;
              this._pointArray = [];
              this._sampleFactor = 1;
              this._networkSize = colors;
              this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
            }
            NeuQuantFloat2.prototype.sample = function(pointBuffer) {
              this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
            };
            NeuQuantFloat2.prototype.quantize = function() {
              this._init();
              this._learn();
              return this._buildPalette();
            };
            NeuQuantFloat2.prototype._init = function() {
              this._freq = [];
              this._bias = [];
              this._radPower = [];
              this._network = [];
              for (var i = 0; i < this._networkSize; i++) {
                this._network[i] = new NeuronFloat((i << networkBiasShift + 8) / this._networkSize);
                this._freq[i] = NeuQuantFloat2._initialBias / this._networkSize;
                this._bias[i] = 0;
              }
            };
            NeuQuantFloat2.prototype._learn = function() {
              var sampleFactor = this._sampleFactor;
              var pointsNumber = this._pointArray.length;
              if (pointsNumber < NeuQuantFloat2._minpicturebytes)
                sampleFactor = 1;
              var alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
              var delta = pointsToSample / NeuQuantFloat2._nCycles | 0, alpha = NeuQuantFloat2._initAlpha, radius = (this._networkSize >> 3) * NeuQuantFloat2._radiusBias;
              var rad = radius >> NeuQuantFloat2._radiusBiasShift;
              if (rad <= 1)
                rad = 0;
              for (var i = 0; i < rad; i++) {
                this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat2._radBias / (rad * rad));
              }
              var step;
              if (pointsNumber < NeuQuantFloat2._minpicturebytes) {
                step = 1;
              } else if (pointsNumber % NeuQuantFloat2._prime1 != 0) {
                step = NeuQuantFloat2._prime1;
              } else if (pointsNumber % NeuQuantFloat2._prime2 != 0) {
                step = NeuQuantFloat2._prime2;
              } else if (pointsNumber % NeuQuantFloat2._prime3 != 0) {
                step = NeuQuantFloat2._prime3;
              } else {
                step = NeuQuantFloat2._prime4;
              }
              for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                this._alterSingle(alpha, neuronIndex, b, g, r, a);
                if (rad != 0)
                  this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                pointIndex += step;
                if (pointIndex >= pointsNumber)
                  pointIndex -= pointsNumber;
                i++;
                if (delta == 0)
                  delta = 1;
                if (i % delta == 0) {
                  alpha -= alpha / alphadec;
                  radius -= radius / NeuQuantFloat2._radiusDecrease;
                  rad = radius >> NeuQuantFloat2._radiusBiasShift;
                  if (rad <= 1)
                    rad = 0;
                  for (var j = 0; j < rad; j++)
                    this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat2._radBias / (rad * rad));
                }
              }
            };
            NeuQuantFloat2.prototype._buildPalette = function() {
              var palette = new palette_1.Palette();
              this._network.forEach(function(neuron) {
                palette.add(neuron.toPoint());
              });
              palette.sort();
              return palette;
            };
            NeuQuantFloat2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
              var lo = i - rad;
              if (lo < -1)
                lo = -1;
              var hi = i + rad;
              if (hi > this._networkSize)
                hi = this._networkSize;
              var j = i + 1, k = i - 1, m = 1;
              while (j < hi || k > lo) {
                var a = this._radPower[m++] / NeuQuantFloat2._alphaRadBias;
                if (j < hi) {
                  var p = this._network[j++];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
                if (k > lo) {
                  var p = this._network[k--];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
              }
            };
            NeuQuantFloat2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
              alpha /= NeuQuantFloat2._initAlpha;
              var n = this._network[i];
              n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
            };
            NeuQuantFloat2.prototype._contest = function(b, g, r, al) {
              var multiplier = 255 * 4 << networkBiasShift;
              var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
              for (var i = 0; i < this._networkSize; i++) {
                var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
                if (dist < bestd) {
                  bestd = dist;
                  bestpos = i;
                }
                var biasdist = dist - (this._bias[i] >> NeuQuantFloat2._initialBiasShift - networkBiasShift);
                if (biasdist < bestbiasd) {
                  bestbiasd = biasdist;
                  bestbiaspos = i;
                }
                var betafreq = this._freq[i] >> NeuQuantFloat2._betaShift;
                this._freq[i] -= betafreq;
                this._bias[i] += betafreq << NeuQuantFloat2._gammaShift;
              }
              this._freq[bestpos] += NeuQuantFloat2._beta;
              this._bias[bestpos] -= NeuQuantFloat2._betaGamma;
              return bestbiaspos;
            };
            NeuQuantFloat2._prime1 = 499;
            NeuQuantFloat2._prime2 = 491;
            NeuQuantFloat2._prime3 = 487;
            NeuQuantFloat2._prime4 = 503;
            NeuQuantFloat2._minpicturebytes = NeuQuantFloat2._prime4;
            NeuQuantFloat2._nCycles = 100;
            NeuQuantFloat2._initialBiasShift = 16;
            NeuQuantFloat2._initialBias = 1 << NeuQuantFloat2._initialBiasShift;
            NeuQuantFloat2._gammaShift = 10;
            NeuQuantFloat2._betaShift = 10;
            NeuQuantFloat2._beta = NeuQuantFloat2._initialBias >> NeuQuantFloat2._betaShift;
            NeuQuantFloat2._betaGamma = NeuQuantFloat2._initialBias << NeuQuantFloat2._gammaShift - NeuQuantFloat2._betaShift;
            NeuQuantFloat2._radiusBiasShift = 6;
            NeuQuantFloat2._radiusBias = 1 << NeuQuantFloat2._radiusBiasShift;
            NeuQuantFloat2._radiusDecrease = 30;
            NeuQuantFloat2._alphaBiasShift = 10;
            NeuQuantFloat2._initAlpha = 1 << NeuQuantFloat2._alphaBiasShift;
            NeuQuantFloat2._radBiasShift = 8;
            NeuQuantFloat2._radBias = 1 << NeuQuantFloat2._radBiasShift;
            NeuQuantFloat2._alphaRadBiasShift = NeuQuantFloat2._alphaBiasShift + NeuQuantFloat2._radBiasShift;
            NeuQuantFloat2._alphaRadBias = 1 << NeuQuantFloat2._alphaRadBiasShift;
            return NeuQuantFloat2;
          }();
          exports2.NeuQuantFloat = NeuQuantFloat;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var colorHistogram_1 = __webpack_require__(27);
          var arithmetic_1 = __webpack_require__(6);
          var RemovedColor = function() {
            function RemovedColor2(index2, color, distance) {
              this.index = index2;
              this.color = color;
              this.distance = distance;
            }
            return RemovedColor2;
          }();
          var RGBQuant = function() {
            function RGBQuant2(colorDistanceCalculator, colors, method) {
              if (colors === void 0) {
                colors = 256;
              }
              if (method === void 0) {
                method = 2;
              }
              this._distance = colorDistanceCalculator;
              this._colors = colors;
              this._histogram = new colorHistogram_1.ColorHistogram(method, colors);
              this._initialDistance = 0.01;
              this._distanceIncrement = 5e-3;
            }
            RGBQuant2.prototype.sample = function(image2) {
              this._histogram.sample(image2);
            };
            RGBQuant2.prototype.quantize = function() {
              var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
              if (idxi32.length === 0) {
                throw new Error("No colors in image");
              }
              var palette = this._buildPalette(idxi32);
              palette.sort();
              return palette;
            };
            RGBQuant2.prototype._buildPalette = function(idxi32) {
              var palette = new palette_1.Palette(), colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
              for (var i = 0; i < idxi32.length; i++) {
                colorArray.push(point_1.Point.createByUint32(idxi32[i]));
                usageArray[i] = 1;
              }
              var len = colorArray.length, memDist = [];
              var palLen = len, thold = this._initialDistance;
              while (palLen > this._colors) {
                memDist.length = 0;
                for (var i = 0; i < len; i++) {
                  if (usageArray[i] === 0)
                    continue;
                  var pxi = colorArray[i];
                  for (var j = i + 1; j < len; j++) {
                    if (usageArray[j] === 0)
                      continue;
                    var pxj = colorArray[j];
                    var dist = this._distance.calculateNormalized(pxi, pxj);
                    if (dist < thold) {
                      memDist.push(new RemovedColor(j, pxj, dist));
                      usageArray[j] = 0;
                      palLen--;
                    }
                  }
                }
                thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
              }
              if (palLen < this._colors) {
                arithmetic_1.stableSort(memDist, function(a, b) {
                  return b.distance - a.distance;
                });
                var k = 0;
                while (palLen < this._colors && k < memDist.length) {
                  var removedColor = memDist[k];
                  usageArray[removedColor.index] = 1;
                  palLen++;
                  k++;
                }
              }
              var colors = colorArray.length;
              for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
                if (usageArray[colorIndex] === 0) {
                  if (colorIndex !== colors - 1) {
                    colorArray[colorIndex] = colorArray[colors - 1];
                  }
                  --colors;
                }
              }
              colorArray.length = colors;
              return palette;
            };
            return RGBQuant2;
          }();
          exports2.RGBQuant = RGBQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var hueStatistics_1 = __webpack_require__(28);
          var arithmetic_1 = __webpack_require__(6);
          var ColorHistogram = function() {
            function ColorHistogram2(method, colors) {
              this._method = method;
              this._minHueCols = colors << 2;
              this._initColors = colors << 2;
              this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram2._hueGroups, this._minHueCols);
              this._histogram = Object.create(null);
            }
            ColorHistogram2.prototype.sample = function(pointBuffer) {
              switch (this._method) {
                case 1:
                  this._colorStats1D(pointBuffer);
                  break;
                case 2:
                  this._colorStats2D(pointBuffer);
                  break;
              }
            };
            ColorHistogram2.prototype.getImportanceSortedColorsIDXI32 = function() {
              var _this = this;
              var sorted = arithmetic_1.stableSort(Object.keys(this._histogram), function(a, b) {
                return _this._histogram[b] - _this._histogram[a];
              });
              if (sorted.length === 0) {
                return [];
              }
              var idxi32;
              switch (this._method) {
                case 1:
                  var initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
                  idxi32 = sorted.slice(0, initialColorsLimit);
                  var pos = initialColorsLimit, len = sorted.length;
                  while (pos < len && this._histogram[sorted[pos]] == freq)
                    idxi32.push(sorted[pos++]);
                  this._hueStats.injectIntoArray(idxi32);
                  break;
                case 2:
                  idxi32 = sorted;
                  break;
                default:
                  throw new Error("Incorrect method");
              }
              return idxi32.map(function(v) {
                return +v;
              });
            };
            ColorHistogram2.prototype._colorStats1D = function(pointBuffer) {
              var histG = this._histogram, pointArray = pointBuffer.getPointArray(), len = pointArray.length;
              for (var i = 0; i < len; i++) {
                var col = pointArray[i].uint32;
                this._hueStats.check(col);
                if (col in histG)
                  histG[col]++;
                else
                  histG[col] = 1;
              }
            };
            ColorHistogram2.prototype._colorStats2D = function(pointBuffer) {
              var _this = this;
              var width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), pointArray = pointBuffer.getPointArray();
              var boxW = ColorHistogram2._boxSize[0], boxH = ColorHistogram2._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
              boxes.forEach(function(box) {
                var effc = Math.round(box.w * box.h / area) * ColorHistogram2._boxPixels;
                if (effc < 2)
                  effc = 2;
                var histL = {};
                _this._iterateBox(box, width, function(i) {
                  var col = pointArray[i].uint32;
                  _this._hueStats.check(col);
                  if (col in histG)
                    histG[col]++;
                  else if (col in histL) {
                    if (++histL[col] >= effc)
                      histG[col] = histL[col];
                  } else
                    histL[col] = 1;
                });
              });
              this._hueStats.injectIntoDictionary(histG);
            };
            ColorHistogram2.prototype._iterateBox = function(bbox, wid, fn) {
              var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
              var cnt = 0, i = i0;
              do {
                fn.call(this, i);
                i += ++cnt % b.w == 0 ? incr : 1;
              } while (i <= i1);
            };
            ColorHistogram2.prototype._makeBoxes = function(width, height, stepX, stepY) {
              var wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
              for (var y = 0; y < height; y += stepY)
                for (var x = 0; x < width; x += stepX)
                  boxesArray.push({ x, y, w: x == xend ? wrem : stepX, h: y == yend ? hrem : stepY });
              return boxesArray;
            };
            ColorHistogram2._boxSize = [64, 64];
            ColorHistogram2._boxPixels = 2;
            ColorHistogram2._hueGroups = 10;
            return ColorHistogram2;
          }();
          exports2.ColorHistogram = ColorHistogram;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2hsl_1 = __webpack_require__(5);
          var palette_1 = __webpack_require__(22);
          var HueGroup = function() {
            function HueGroup2() {
              this.num = 0;
              this.cols = [];
            }
            return HueGroup2;
          }();
          var HueStatistics = function() {
            function HueStatistics2(numGroups, minCols) {
              this._numGroups = numGroups;
              this._minCols = minCols;
              this._stats = [];
              for (var i = 0; i <= numGroups; i++) {
                this._stats[i] = new HueGroup();
              }
              this._groupsFull = 0;
            }
            HueStatistics2.prototype.check = function(i32) {
              if (this._groupsFull == this._numGroups + 1) {
                this.check = function() {
                };
              }
              var r = i32 & 255, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
              gr.num++;
              if (gr.num > min)
                return;
              if (gr.num == min)
                this._groupsFull++;
              if (gr.num <= min)
                this._stats[hg].cols.push(i32);
            };
            HueStatistics2.prototype.injectIntoDictionary = function(histG) {
              for (var i = 0; i <= this._numGroups; i++) {
                if (this._stats[i].num <= this._minCols) {
                  this._stats[i].cols.forEach(function(col) {
                    if (!histG[col])
                      histG[col] = 1;
                    else
                      histG[col]++;
                  });
                }
              }
            };
            HueStatistics2.prototype.injectIntoArray = function(histG) {
              for (var i = 0; i <= this._numGroups; i++) {
                if (this._stats[i].num <= this._minCols) {
                  this._stats[i].cols.forEach(function(col) {
                    if (histG.indexOf(col) == -1)
                      histG.push(col);
                  });
                }
              }
            };
            return HueStatistics2;
          }();
          exports2.HueStatistics = HueStatistics;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          function createArray1D(dimension1) {
            var a = [];
            for (var k = 0; k < dimension1; k++) {
              a[k] = 0;
            }
            return a;
          }
          function createArray4D(dimension1, dimension2, dimension3, dimension4) {
            var a = new Array(dimension1);
            for (var i = 0; i < dimension1; i++) {
              a[i] = new Array(dimension2);
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = new Array(dimension3);
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = new Array(dimension4);
                  for (var l = 0; l < dimension4; l++) {
                    a[i][j][k][l] = 0;
                  }
                }
              }
            }
            return a;
          }
          function createArray3D(dimension1, dimension2, dimension3) {
            var a = new Array(dimension1);
            for (var i = 0; i < dimension1; i++) {
              a[i] = new Array(dimension2);
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = new Array(dimension3);
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = 0;
                }
              }
            }
            return a;
          }
          function fillArray3D(a, dimension1, dimension2, dimension3, value) {
            for (var i = 0; i < dimension1; i++) {
              a[i] = [];
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = [];
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = value;
                }
              }
            }
          }
          function fillArray1D(a, dimension1, value) {
            for (var i = 0; i < dimension1; i++) {
              a[i] = value;
            }
          }
          var WuColorCube = function() {
            function WuColorCube2() {
            }
            return WuColorCube2;
          }();
          exports2.WuColorCube = WuColorCube;
          var WuQuant = function() {
            function WuQuant2(colorDistanceCalculator, colors, significantBitsPerChannel) {
              if (colors === void 0) {
                colors = 256;
              }
              if (significantBitsPerChannel === void 0) {
                significantBitsPerChannel = 5;
              }
              this._distance = colorDistanceCalculator;
              this._setQuality(significantBitsPerChannel);
              this._initialize(colors);
            }
            WuQuant2.prototype.sample = function(image2) {
              var pointArray = image2.getPointArray();
              for (var i = 0, l = pointArray.length; i < l; i++) {
                this._addColor(pointArray[i]);
              }
              this._pixels = this._pixels.concat(pointArray);
            };
            WuQuant2.prototype.quantize = function() {
              this._preparePalette();
              var palette = new palette_1.Palette();
              for (var paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
                if (this._sums[paletteIndex] > 0) {
                  var sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum;
                  var color = point_1.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
                  palette.add(color);
                }
              }
              palette.sort();
              return palette;
            };
            WuQuant2.prototype._preparePalette = function() {
              this._calculateMoments();
              var next = 0, volumeVariance = createArray1D(this._colors);
              for (var cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
                if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
                  volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
                  volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
                } else {
                  volumeVariance[next] = 0;
                  cubeIndex--;
                }
                next = 0;
                var temp = volumeVariance[0];
                for (var index2 = 1; index2 <= cubeIndex; ++index2) {
                  if (volumeVariance[index2] > temp) {
                    temp = volumeVariance[index2];
                    next = index2;
                  }
                }
                if (temp <= 0) {
                  this._colors = cubeIndex + 1;
                  break;
                }
              }
              var lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
              for (var k = 0; k < this._colors; ++k) {
                var weight = WuQuant2._volume(this._cubes[k], this._weights);
                if (weight > 0) {
                  lookupRed[k] = WuQuant2._volume(this._cubes[k], this._momentsRed) / weight | 0;
                  lookupGreen[k] = WuQuant2._volume(this._cubes[k], this._momentsGreen) / weight | 0;
                  lookupBlue[k] = WuQuant2._volume(this._cubes[k], this._momentsBlue) / weight | 0;
                  lookupAlpha[k] = WuQuant2._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
                } else {
                  lookupRed[k] = 0;
                  lookupGreen[k] = 0;
                  lookupBlue[k] = 0;
                  lookupAlpha[k] = 0;
                }
              }
              this._reds = createArray1D(this._colors + 1);
              this._greens = createArray1D(this._colors + 1);
              this._blues = createArray1D(this._colors + 1);
              this._alphas = createArray1D(this._colors + 1);
              this._sums = createArray1D(this._colors + 1);
              for (var index2 = 0, l = this._pixels.length; index2 < l; index2++) {
                var color = this._pixels[index2];
                var match = -1;
                var bestMatch = match, bestDistance = Number.MAX_VALUE;
                for (var lookup = 0; lookup < this._colors; lookup++) {
                  var foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup];
                  var distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                  if (distance < bestDistance) {
                    bestDistance = distance;
                    bestMatch = lookup;
                  }
                }
                this._reds[bestMatch] += color.r;
                this._greens[bestMatch] += color.g;
                this._blues[bestMatch] += color.b;
                this._alphas[bestMatch] += color.a;
                this._sums[bestMatch]++;
              }
            };
            WuQuant2.prototype._addColor = function(color) {
              var bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = (color.r >> bitsToRemove) + 1, indexGreen = (color.g >> bitsToRemove) + 1, indexBlue = (color.b >> bitsToRemove) + 1, indexAlpha = (color.a >> bitsToRemove) + 1;
              this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
              this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
              this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
              this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
              this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
              this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
            };
            WuQuant2.prototype._calculateMoments = function() {
              var area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [];
              var xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
              for (var alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
                fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
                for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {
                  fillArray1D(area, this._sideSize, 0);
                  fillArray1D(areaRed, this._sideSize, 0);
                  fillArray1D(areaGreen, this._sideSize, 0);
                  fillArray1D(areaBlue, this._sideSize, 0);
                  fillArray1D(areaAlpha, this._sideSize, 0);
                  fillArray1D(area2, this._sideSize, 0);
                  for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                    var line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                    for (var blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                      line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                      line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                      area[blueIndex] += line;
                      areaRed[blueIndex] += lineRed;
                      areaGreen[blueIndex] += lineGreen;
                      areaBlue[blueIndex] += lineBlue;
                      areaAlpha[blueIndex] += lineAlpha;
                      area2[blueIndex] += line2;
                      xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                      xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                      xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                      xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                      xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                      xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                      this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                      this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                      this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                      this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                      this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                      this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                    }
                  }
                }
              }
            };
            WuQuant2._volumeFloat = function(cube, moment) {
              return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            };
            WuQuant2._volume = function(cube, moment) {
              return WuQuant2._volumeFloat(cube, moment) | 0;
            };
            WuQuant2._top = function(cube, direction, position, moment) {
              var result;
              switch (direction) {
                case WuQuant2.alpha:
                  result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                  break;
                case WuQuant2.red:
                  result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                  break;
                case WuQuant2.green:
                  result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                  break;
                case WuQuant2.blue:
                  result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                  break;
                default:
                  throw new Error("impossible");
              }
              return result | 0;
            };
            WuQuant2._bottom = function(cube, direction, moment) {
              switch (direction) {
                case WuQuant2.alpha:
                  return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.red:
                  return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.green:
                  return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.blue:
                  return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                default:
                  return 0;
              }
            };
            WuQuant2.prototype._calculateVariance = function(cube) {
              var volumeRed = WuQuant2._volume(cube, this._momentsRed), volumeGreen = WuQuant2._volume(cube, this._momentsGreen), volumeBlue = WuQuant2._volume(cube, this._momentsBlue), volumeAlpha = WuQuant2._volume(cube, this._momentsAlpha), volumeMoment = WuQuant2._volumeFloat(cube, this._moments), volumeWeight = WuQuant2._volume(cube, this._weights), distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
              return volumeMoment - distance / volumeWeight;
            };
            WuQuant2.prototype._maximize = function(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
              var bottomRed = WuQuant2._bottom(cube, direction, this._momentsRed) | 0, bottomGreen = WuQuant2._bottom(cube, direction, this._momentsGreen) | 0, bottomBlue = WuQuant2._bottom(cube, direction, this._momentsBlue) | 0, bottomAlpha = WuQuant2._bottom(cube, direction, this._momentsAlpha) | 0, bottomWeight = WuQuant2._bottom(cube, direction, this._weights) | 0;
              var result = 0, cutPosition = -1;
              for (var position = first; position < last; ++position) {
                var halfRed = bottomRed + WuQuant2._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + WuQuant2._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + WuQuant2._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + WuQuant2._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + WuQuant2._top(cube, direction, position, this._weights);
                if (halfWeight != 0) {
                  var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                  halfRed = wholeRed - halfRed;
                  halfGreen = wholeGreen - halfGreen;
                  halfBlue = wholeBlue - halfBlue;
                  halfAlpha = wholeAlpha - halfAlpha;
                  halfWeight = wholeWeight - halfWeight;
                  if (halfWeight != 0) {
                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                    temp += halfDistance / halfWeight;
                    if (temp > result) {
                      result = temp;
                      cutPosition = position;
                    }
                  }
                }
              }
              return { max: result, position: cutPosition };
            };
            WuQuant2.prototype._cut = function(first, second) {
              var direction;
              var wholeRed = WuQuant2._volume(first, this._momentsRed), wholeGreen = WuQuant2._volume(first, this._momentsGreen), wholeBlue = WuQuant2._volume(first, this._momentsBlue), wholeAlpha = WuQuant2._volume(first, this._momentsAlpha), wholeWeight = WuQuant2._volume(first, this._weights), red = this._maximize(first, WuQuant2.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, WuQuant2.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, WuQuant2.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, WuQuant2.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
              if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
                direction = WuQuant2.alpha;
                if (alpha.position < 0)
                  return false;
              } else {
                if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
                  direction = WuQuant2.red;
                } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
                  direction = WuQuant2.green;
                } else {
                  direction = WuQuant2.blue;
                }
              }
              second.redMaximum = first.redMaximum;
              second.greenMaximum = first.greenMaximum;
              second.blueMaximum = first.blueMaximum;
              second.alphaMaximum = first.alphaMaximum;
              switch (direction) {
                case WuQuant2.red:
                  second.redMinimum = first.redMaximum = red.position;
                  second.greenMinimum = first.greenMinimum;
                  second.blueMinimum = first.blueMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.green:
                  second.greenMinimum = first.greenMaximum = green.position;
                  second.redMinimum = first.redMinimum;
                  second.blueMinimum = first.blueMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.blue:
                  second.blueMinimum = first.blueMaximum = blue.position;
                  second.redMinimum = first.redMinimum;
                  second.greenMinimum = first.greenMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.alpha:
                  second.alphaMinimum = first.alphaMaximum = alpha.position;
                  second.blueMinimum = first.blueMinimum;
                  second.redMinimum = first.redMinimum;
                  second.greenMinimum = first.greenMinimum;
                  break;
              }
              first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
              second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
              return true;
            };
            WuQuant2.prototype._initialize = function(colors) {
              this._colors = colors;
              this._cubes = [];
              for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
                this._cubes[cubeIndex] = new WuColorCube();
              }
              this._cubes[0].redMinimum = 0;
              this._cubes[0].greenMinimum = 0;
              this._cubes[0].blueMinimum = 0;
              this._cubes[0].alphaMinimum = 0;
              this._cubes[0].redMaximum = this._maxSideIndex;
              this._cubes[0].greenMaximum = this._maxSideIndex;
              this._cubes[0].blueMaximum = this._maxSideIndex;
              this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
              this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._table = [];
              for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {
                this._table[tableIndex] = tableIndex * tableIndex;
              }
              this._pixels = [];
            };
            WuQuant2.prototype._setQuality = function(significantBitsPerChannel) {
              if (significantBitsPerChannel === void 0) {
                significantBitsPerChannel = 5;
              }
              this._significantBitsPerChannel = significantBitsPerChannel;
              this._maxSideIndex = 1 << this._significantBitsPerChannel;
              this._alphaMaxSideIndex = this._maxSideIndex;
              this._sideSize = this._maxSideIndex + 1;
              this._alphaSideSize = this._alphaMaxSideIndex + 1;
            };
            WuQuant2.alpha = 3;
            WuQuant2.red = 2;
            WuQuant2.green = 1;
            WuQuant2.blue = 0;
            return WuQuant2;
          }();
          exports2.WuQuant = WuQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var nearestColor_1 = __webpack_require__(31);
          exports2.NearestColor = nearestColor_1.NearestColor;
          var array_1 = __webpack_require__(32);
          exports2.ErrorDiffusionArray = array_1.ErrorDiffusionArray;
          exports2.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;
          var riemersma_1 = __webpack_require__(33);
          exports2.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;
        },
        function(module2, exports2) {
          "use strict";
          var NearestColor = function() {
            function NearestColor2(colorDistanceCalculator) {
              this._distance = colorDistanceCalculator;
            }
            NearestColor2.prototype.quantize = function(pointBuffer, palette) {
              var pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight();
              for (var y = 0; y < height; y++) {
                for (var x = 0, idx = y * width; x < width; x++, idx++) {
                  var point = pointArray[idx];
                  point.from(palette.getNearestColor(this._distance, point));
                }
              }
              return pointBuffer;
            };
            return NearestColor2;
          }();
          exports2.NearestColor = NearestColor;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var point_1 = __webpack_require__(24);
          var arithmetic_1 = __webpack_require__(6);
          (function(ErrorDiffusionArrayKernel2) {
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
          })(exports2.ErrorDiffusionArrayKernel || (exports2.ErrorDiffusionArrayKernel = {}));
          var ErrorDiffusionArrayKernel = exports2.ErrorDiffusionArrayKernel;
          var ErrorDiffusionArray = function() {
            function ErrorDiffusionArray2(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {
              if (serpentine === void 0) {
                serpentine = true;
              }
              if (minimumColorDistanceToDither === void 0) {
                minimumColorDistanceToDither = 0;
              }
              if (calculateErrorLikeGIMP === void 0) {
                calculateErrorLikeGIMP = false;
              }
              this._setKernel(kernel);
              this._distance = colorDistanceCalculator;
              this._minColorDistance = minimumColorDistanceToDither;
              this._serpentine = serpentine;
              this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
            }
            ErrorDiffusionArray2.prototype.quantize = function(pointBuffer, palette) {
              var pointArray = pointBuffer.getPointArray(), originalPoint = new point_1.Point(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorLines = [];
              var dir = 1, maxErrorLines = 1;
              for (var i = 0; i < this._kernel.length; i++) {
                var kernelErrorLines = this._kernel[i][2] + 1;
                if (maxErrorLines < kernelErrorLines)
                  maxErrorLines = kernelErrorLines;
              }
              for (var i = 0; i < maxErrorLines; i++) {
                this._fillErrorLine(errorLines[i] = [], width);
              }
              for (var y = 0; y < height; y++) {
                if (this._serpentine)
                  dir = dir * -1;
                var lni = y * width, xStart = dir == 1 ? 0 : width - 1, xEnd = dir == 1 ? width : -1;
                this._fillErrorLine(errorLines[0], width);
                errorLines.push(errorLines.shift());
                var errorLine = errorLines[0];
                for (var x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {
                  var point = pointArray[idx], error2 = errorLine[x];
                  originalPoint.from(point);
                  var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error2[0]), arithmetic_1.inRange0to255Rounded(point.g + error2[1]), arithmetic_1.inRange0to255Rounded(point.b + error2[2]), arithmetic_1.inRange0to255Rounded(point.a + error2[3]));
                  var palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                  point.from(palettePoint);
                  if (this._minColorDistance) {
                    var dist = this._distance.calculateNormalized(point, palettePoint);
                    if (dist < this._minColorDistance)
                      continue;
                  }
                  var er = void 0, eg = void 0, eb = void 0, ea = void 0;
                  if (this._calculateErrorLikeGIMP) {
                    er = correctedPoint.r - palettePoint.r;
                    eg = correctedPoint.g - palettePoint.g;
                    eb = correctedPoint.b - palettePoint.b;
                    ea = correctedPoint.a - palettePoint.a;
                  } else {
                    er = originalPoint.r - palettePoint.r;
                    eg = originalPoint.g - palettePoint.g;
                    eb = originalPoint.b - palettePoint.b;
                    ea = originalPoint.a - palettePoint.a;
                  }
                  var dStart = dir == 1 ? 0 : this._kernel.length - 1, dEnd = dir == 1 ? this._kernel.length : -1;
                  for (var i = dStart; i !== dEnd; i += dir) {
                    var x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                      var d2 = this._kernel[i][0], e = errorLines[y1][x1 + x];
                      e[0] = e[0] + er * d2;
                      e[1] = e[1] + eg * d2;
                      e[2] = e[2] + eb * d2;
                      e[3] = e[3] + ea * d2;
                    }
                  }
                }
              }
              return pointBuffer;
            };
            ErrorDiffusionArray2.prototype._fillErrorLine = function(errorLine, width) {
              if (errorLine.length > width) {
                errorLine.length = width;
              }
              var l = errorLine.length;
              for (var i = 0; i < l; i++) {
                var error2 = errorLine[i];
                error2[0] = error2[1] = error2[2] = error2[3] = 0;
              }
              for (var i = l; i < width; i++) {
                errorLine[i] = [0, 0, 0, 0];
              }
            };
            ErrorDiffusionArray2.prototype._setKernel = function(kernel) {
              switch (kernel) {
                case ErrorDiffusionArrayKernel.FloydSteinberg:
                  this._kernel = [
                    [7 / 16, 1, 0],
                    [3 / 16, -1, 1],
                    [5 / 16, 0, 1],
                    [1 / 16, 1, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                  this._kernel = [
                    [3 / 8, 1, 0],
                    [3 / 8, 0, 1],
                    [2 / 8, 1, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Stucki:
                  this._kernel = [
                    [8 / 42, 1, 0],
                    [4 / 42, 2, 0],
                    [2 / 42, -2, 1],
                    [4 / 42, -1, 1],
                    [8 / 42, 0, 1],
                    [4 / 42, 1, 1],
                    [2 / 42, 2, 1],
                    [1 / 42, -2, 2],
                    [2 / 42, -1, 2],
                    [4 / 42, 0, 2],
                    [2 / 42, 1, 2],
                    [1 / 42, 2, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Atkinson:
                  this._kernel = [
                    [1 / 8, 1, 0],
                    [1 / 8, 2, 0],
                    [1 / 8, -1, 1],
                    [1 / 8, 0, 1],
                    [1 / 8, 1, 1],
                    [1 / 8, 0, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Jarvis:
                  this._kernel = [
                    [7 / 48, 1, 0],
                    [5 / 48, 2, 0],
                    [3 / 48, -2, 1],
                    [5 / 48, -1, 1],
                    [7 / 48, 0, 1],
                    [5 / 48, 1, 1],
                    [3 / 48, 2, 1],
                    [1 / 48, -2, 2],
                    [3 / 48, -1, 2],
                    [5 / 48, 0, 2],
                    [3 / 48, 1, 2],
                    [1 / 48, 2, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Burkes:
                  this._kernel = [
                    [8 / 32, 1, 0],
                    [4 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [8 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Sierra:
                  this._kernel = [
                    [5 / 32, 1, 0],
                    [3 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [5 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1],
                    [2 / 32, -1, 2],
                    [3 / 32, 0, 2],
                    [2 / 32, 1, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.TwoSierra:
                  this._kernel = [
                    [4 / 16, 1, 0],
                    [3 / 16, 2, 0],
                    [1 / 16, -2, 1],
                    [2 / 16, -1, 1],
                    [3 / 16, 0, 1],
                    [2 / 16, 1, 1],
                    [1 / 16, 2, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.SierraLite:
                  this._kernel = [
                    [2 / 4, 1, 0],
                    [1 / 4, -1, 1],
                    [1 / 4, 0, 1]
                  ];
                  break;
                default:
                  throw new Error("ErrorDiffusionArray: unknown kernel = " + kernel);
              }
            };
            return ErrorDiffusionArray2;
          }();
          exports2.ErrorDiffusionArray = ErrorDiffusionArray;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var hilbertCurve_1 = __webpack_require__(34);
          var point_1 = __webpack_require__(24);
          var arithmetic_1 = __webpack_require__(6);
          var ErrorDiffusionRiemersma = function() {
            function ErrorDiffusionRiemersma2(colorDistanceCalculator, errorQueueSize, errorPropagation) {
              if (errorQueueSize === void 0) {
                errorQueueSize = 16;
              }
              if (errorPropagation === void 0) {
                errorPropagation = 1;
              }
              this._distance = colorDistanceCalculator;
              this._errorPropagation = errorPropagation;
              this._errorQueueSize = errorQueueSize;
              this._max = this._errorQueueSize;
              this._createWeights();
            }
            ErrorDiffusionRiemersma2.prototype.quantize = function(pointBuffer, palette) {
              var _this = this;
              var curve = new hilbertCurve_1.HilbertCurveBase(), pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorQueue = [];
              var head = 0;
              for (var i = 0; i < this._errorQueueSize; i++) {
                errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
              }
              curve.walk(width, height, function(x, y) {
                var p = pointArray[x + y * width];
                var r = p.r, g = p.g, b = p.b, a = p.a;
                for (var i2 = 0; i2 < _this._errorQueueSize; i2++) {
                  var weight = _this._weights[i2], e = errorQueue[(i2 + head) % _this._errorQueueSize];
                  r += e.r * weight;
                  g += e.g * weight;
                  b += e.b * weight;
                  a += e.a * weight;
                }
                var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a));
                var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);
                head = (head + 1) % _this._errorQueueSize;
                var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;
                errorQueue[tail].r = p.r - quantizedPoint.r;
                errorQueue[tail].g = p.g - quantizedPoint.g;
                errorQueue[tail].b = p.b - quantizedPoint.b;
                errorQueue[tail].a = p.a - quantizedPoint.a;
                p.from(quantizedPoint);
              });
              return pointBuffer;
            };
            ErrorDiffusionRiemersma2.prototype._createWeights = function() {
              this._weights = [];
              var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));
              for (var i = 0, next = 1; i < this._errorQueueSize; i++) {
                this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation;
                next *= multiplier;
              }
            };
            return ErrorDiffusionRiemersma2;
          }();
          exports2.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;
        },
        function(module2, exports2) {
          "use strict";
          var Direction;
          (function(Direction2) {
            Direction2[Direction2["NONE"] = 0] = "NONE";
            Direction2[Direction2["UP"] = 1] = "UP";
            Direction2[Direction2["LEFT"] = 2] = "LEFT";
            Direction2[Direction2["RIGHT"] = 3] = "RIGHT";
            Direction2[Direction2["DOWN"] = 4] = "DOWN";
          })(Direction || (Direction = {}));
          var HilbertCurveBase = function() {
            function HilbertCurveBase2() {
            }
            HilbertCurveBase2.prototype.walk = function(width, height, visitorCallback) {
              this._x = 0;
              this._y = 0;
              this._d = 0;
              this._width = width;
              this._height = height;
              this._callback = visitorCallback;
              var maxBound = Math.max(width, height);
              this._level = Math.log(maxBound) / Math.log(2) + 1 | 0;
              this._walkHilbert(Direction.UP);
              this._visit(Direction.NONE);
            };
            HilbertCurveBase2.prototype._walkHilbert = function(direction) {
              if (this._level < 1)
                return;
              this._level--;
              switch (direction) {
                case Direction.LEFT:
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.DOWN);
                  break;
                case Direction.RIGHT:
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.UP);
                  break;
                case Direction.UP:
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.RIGHT);
                  break;
                case Direction.DOWN:
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.LEFT);
                  break;
                default:
                  break;
              }
              this._level++;
            };
            HilbertCurveBase2.prototype._visit = function(direction) {
              if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {
                this._callback(this._x, this._y, this._d);
                this._d++;
              }
              switch (direction) {
                case Direction.LEFT:
                  this._x--;
                  break;
                case Direction.RIGHT:
                  this._x++;
                  break;
                case Direction.UP:
                  this._y--;
                  break;
                case Direction.DOWN:
                  this._y++;
                  break;
              }
            };
            return HilbertCurveBase2;
          }();
          exports2.HilbertCurveBase = HilbertCurveBase;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var ssim_1 = __webpack_require__(36);
          exports2.SSIM = ssim_1.SSIM;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709_1 = __webpack_require__(2);
          var K1 = 0.01, K2 = 0.03;
          var SSIM = function() {
            function SSIM2() {
            }
            SSIM2.prototype.compare = function(image1, image2) {
              if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
                throw new Error("Images have different sizes!");
              }
              var bitsPerComponent = 8, L = (1 << bitsPerComponent) - 1, c1 = Math.pow(K1 * L, 2), c2 = Math.pow(K2 * L, 2);
              var numWindows = 0, mssim = 0;
              this._iterate(image1, image2, function(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
                var sigxy = 0, sigsqx = 0, sigsqy = 0;
                for (var i = 0; i < lumaValues1.length; i++) {
                  sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2);
                  sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2);
                  sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
                }
                var numPixelsInWin = lumaValues1.length - 1;
                sigsqx /= numPixelsInWin;
                sigsqy /= numPixelsInWin;
                sigxy /= numPixelsInWin;
                var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2), denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2), ssim = numerator / denominator;
                mssim += ssim;
                numWindows++;
              });
              return mssim / numWindows;
            };
            SSIM2.prototype._iterate = function(image1, image2, callback) {
              var windowSize = 8, width = image1.getWidth(), height = image1.getHeight();
              for (var y = 0; y < height; y += windowSize) {
                for (var x = 0; x < width; x += windowSize) {
                  var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                  var lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight), lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight), averageLuma1 = this._calculateAverageLuma(lumaValues1), averageLuma2 = this._calculateAverageLuma(lumaValues2);
                  callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
                }
              }
            };
            SSIM2.prototype._calculateLumaValuesForWindow = function(image2, x, y, width, height) {
              var pointArray = image2.getPointArray(), lumaValues = [];
              var counter = 0;
              for (var j = y; j < y + height; j++) {
                var offset = j * image2.getWidth();
                for (var i = x; i < x + width; i++) {
                  var point = pointArray[offset + i];
                  lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE;
                  counter++;
                }
              }
              return lumaValues;
            };
            SSIM2.prototype._calculateAverageLuma = function(lumaValues) {
              var sumLuma = 0;
              for (var i = 0; i < lumaValues.length; i++) {
                sumLuma += lumaValues[i];
              }
              return sumLuma / lumaValues.length;
            };
            return SSIM2;
          }();
          exports2.SSIM = SSIM;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic = __webpack_require__(6);
          exports2.arithmetic = arithmetic;
          var hueStatistics_1 = __webpack_require__(28);
          exports2.HueStatistics = hueStatistics_1.HueStatistics;
          var palette_1 = __webpack_require__(22);
          exports2.Palette = palette_1.Palette;
          var point_1 = __webpack_require__(24);
          exports2.Point = point_1.Point;
          var pointContainer_1 = __webpack_require__(23);
          exports2.PointContainer = pointContainer_1.PointContainer;
        }
      ]);
    });
  }
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS({
  "node_modules/gifwrap/src/gifframe.js"(exports) {
    init_shims();
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { GifError: GifError2 } = require_gif();
    var GifFrame = class extends BitmapImage {
      constructor(...args) {
        super(...args);
        if (args[0] instanceof GifFrame) {
          const source = args[0];
          this.xOffset = source.xOffset;
          this.yOffset = source.yOffset;
          this.disposalMethod = source.disposalMethod;
          this.delayCentisecs = source.delayCentisecs;
          this.interlaced = source.interlaced;
        } else {
          const lastArg = args[args.length - 1];
          let options2 = {};
          if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
            options2 = lastArg;
          }
          this.xOffset = options2.xOffset || 0;
          this.yOffset = options2.yOffset || 0;
          this.disposalMethod = options2.disposalMethod !== void 0 ? options2.disposalMethod : GifFrame.DisposeToBackgroundColor;
          this.delayCentisecs = options2.delayCentisecs || 8;
          this.interlaced = options2.interlaced || false;
        }
      }
      getPalette() {
        const colorSet = new Set();
        const buf = this.bitmap.data;
        let i = 0;
        let usesTransparency = false;
        while (i < buf.length) {
          if (buf[i + 3] === 0) {
            usesTransparency = true;
          } else {
            const color = buf.readUInt32BE(i, true) >> 8 & 16777215;
            colorSet.add(color);
          }
          i += 4;
        }
        const colors = new Array(colorSet.size);
        const iter = colorSet.values();
        for (i = 0; i < colors.length; ++i) {
          colors[i] = iter.next().value;
        }
        colors.sort((a, b) => a - b);
        let indexCount = colors.length;
        if (usesTransparency) {
          ++indexCount;
        }
        return { colors, usesTransparency, indexCount };
      }
    };
    GifFrame.DisposeToAnything = 0;
    GifFrame.DisposeNothing = 1;
    GifFrame.DisposeToBackgroundColor = 2;
    GifFrame.DisposeToPrevious = 3;
    exports.GifFrame = GifFrame;
  }
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS({
  "node_modules/gifwrap/src/gifutil.js"(exports) {
    init_shims();
    "use strict";
    var fs3 = __require("fs");
    var ImageQ = require_iq();
    var BitmapImage = require_bitmapimage();
    var { GifFrame } = require_gifframe();
    var { GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
    var defaultCodec = new GifCodec();
    exports.cloneFrames = function(frames) {
      let clones = [];
      frames.forEach((frame) => {
        clones.push(new GifFrame(frame));
      });
      return clones;
    };
    exports.getColorInfo = function(frames, maxGlobalIndex) {
      let usesTransparency = false;
      const palettes = [];
      for (let i = 0; i < frames.length; ++i) {
        let palette = frames[i].getPalette();
        if (palette.usesTransparency) {
          usesTransparency = true;
        }
        if (palette.indexCount > 256) {
          throw new GifError2(`Frame ${i} uses more than 256 color indexes`);
        }
        palettes.push(palette);
      }
      if (maxGlobalIndex === 0) {
        return { usesTransparency, palettes };
      }
      const globalColorSet = new Set();
      palettes.forEach((palette) => {
        palette.colors.forEach((color) => {
          globalColorSet.add(color);
        });
      });
      let indexCount = globalColorSet.size;
      if (usesTransparency) {
        ++indexCount;
      }
      if (maxGlobalIndex && indexCount > maxGlobalIndex) {
        return { usesTransparency, palettes };
      }
      const colors = new Array(globalColorSet.size);
      const iter = globalColorSet.values();
      for (let i = 0; i < colors.length; ++i) {
        colors[i] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      return { colors, indexCount, usesTransparency, palettes };
    };
    exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
      return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
    };
    exports.getMaxDimensions = function(frames) {
      let maxWidth = 0, maxHeight = 0;
      frames.forEach((frame) => {
        const width = frame.xOffset + frame.bitmap.width;
        if (width > maxWidth) {
          maxWidth = width;
        }
        const height = frame.yOffset + frame.bitmap.height;
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      return { maxWidth, maxHeight };
    };
    exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
    };
    exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      histogram = histogram || "min-pop";
      let histogramID;
      switch (histogram) {
        case "min-pop":
          histogramID = 2;
          break;
        case "top-pop":
          histogramID = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
      }
      _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    };
    exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      significantBits = significantBits || 5;
      if (significantBits < 1 || significantBits > 8) {
        throw new Error("Invalid quantization quality");
      }
      _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    };
    exports.read = function(source, decoder) {
      decoder = decoder || defaultCodec;
      if (Buffer.isBuffer(source)) {
        return decoder.decodeGif(source);
      }
      return _readBinary(source).then((buffer) => {
        return decoder.decodeGif(buffer);
      });
    };
    exports.shareAsJimp = function(jimp, bitmapImageToShare) {
      const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
      jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
      return jimpImage;
    };
    exports.write = function(path2, frames, spec, encoder) {
      encoder = encoder || defaultCodec;
      const matches = path2.match(/\.[a-zA-Z]+$/);
      if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
        throw new Error(`GIF '${path2}' has an unexpected suffix`);
      }
      return encoder.encodeGif(frames, spec).then((gif) => {
        return _writeBinary(path2, gif.buffer).then(() => {
          return gif;
        });
      });
    };
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
      const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
      const ditherAlgs = [
        "FloydSteinberg",
        "FalseFloydSteinberg",
        "Stucki",
        "Atkinson",
        "Jarvis",
        "Burkes",
        "Sierra",
        "TwoSierra",
        "SierraLite"
      ];
      if (dither) {
        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
          throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
        }
        if (dither.serpentine === void 0) {
          dither.serpentine = true;
        }
        if (dither.minimumColorDistanceToDither === void 0) {
          dither.minimumColorDistanceToDither = 0;
        }
        if (dither.calculateErrorLikeGIMP === void 0) {
          dither.calculateErrorLikeGIMP = false;
        }
      }
      const distCalculator = new ImageQ.distance.Euclidean();
      const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
      let imageMaker;
      if (dither) {
        imageMaker = new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP);
      } else {
        imageMaker = new ImageQ.image.NearestColor(distCalculator);
      }
      const inputContainers = [];
      images.forEach((image2) => {
        const imageBuf = image2.bitmap.data;
        const inputBuf = new ArrayBuffer(imageBuf.length);
        const inputArray = new Uint32Array(inputBuf);
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          inputArray[ai] = imageBuf.readUInt32LE(bi, true);
        }
        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image2.bitmap.width, image2.bitmap.height);
        quantizer.sample(inputContainer);
        inputContainers.push(inputContainer);
      });
      const limitedPalette = quantizer.quantize();
      for (let i = 0; i < images.length; ++i) {
        const imageBuf = images[i].bitmap.data;
        const outputContainer = imageMaker.quantize(inputContainers[i], limitedPalette);
        const outputArray = outputContainer.toUint32Array();
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
      }
    }
    function _readBinary(path2) {
      return new Promise((resolve3, reject) => {
        fs3.readFile(path2, (err, buffer) => {
          if (err) {
            return reject(err);
          }
          return resolve3(buffer);
        });
      });
    }
    function _writeBinary(path2, buffer) {
      return new Promise((resolve3, reject) => {
        fs3.writeFile(path2, buffer, (err) => {
          if (err) {
            return reject(err);
          }
          return resolve3();
        });
      });
    }
  }
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS({
  "node_modules/gifwrap/src/gifcodec.js"(exports) {
    init_shims();
    "use strict";
    var Omggif = require_omggif();
    var { Gif, GifError: GifError2 } = require_gif();
    var GifUtil;
    process.nextTick(() => {
      GifUtil = require_gifutil();
    });
    var { GifFrame } = require_gifframe();
    var PER_GIF_OVERHEAD = 200;
    var PER_FRAME_OVERHEAD = 100;
    var GifCodec = class {
      constructor(options2 = {}) {
        this._transparentRGB = null;
        if (typeof options2.transparentRGB === "number" && options2.transparentRGB !== 0) {
          this._transparentRGBA = options2.transparentRGB * 256;
        }
        this._testInitialBufferSize = 0;
      }
      decodeGif(buffer) {
        try {
          let reader;
          try {
            reader = new Omggif.GifReader(buffer);
          } catch (err) {
            throw new GifError2(err);
          }
          const frameCount = reader.numFrames();
          const frames = [];
          const spec = {
            width: reader.width,
            height: reader.height,
            loops: reader.loopCount()
          };
          spec.usesTransparency = false;
          for (let i = 0; i < frameCount; ++i) {
            const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
            frames.push(frameInfo.frame);
            if (frameInfo.usesTransparency) {
              spec.usesTransparency = true;
            }
          }
          return Promise.resolve(new Gif(buffer, frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      encodeGif(frames, spec = {}) {
        try {
          if (frames === null || frames.length === 0) {
            throw new GifError2("there are no frames");
          }
          const dims = GifUtil.getMaxDimensions(frames);
          spec = Object.assign({}, spec);
          spec.width = dims.maxWidth;
          spec.height = dims.maxHeight;
          spec.loops = spec.loops || 0;
          spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
          return Promise.resolve(this._encodeGif(frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
        let info, buffer;
        try {
          info = reader.frameInfo(frameIndex);
          buffer = new Buffer(reader.width * reader.height * 4);
          reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
          if (info.width !== reader.width || info.height !== reader.height) {
            if (info.y) {
              buffer = buffer.slice(info.y * reader.width * 4);
            }
            if (reader.width > info.width) {
              for (let ii = 0; ii < info.height; ++ii) {
                buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);
              }
            }
            buffer = buffer.slice(0, info.width * info.height * 4);
          }
        } catch (err) {
          throw new GifError2(err);
        }
        let usesTransparency = false;
        if (this._transparentRGBA === null) {
          if (!alreadyUsedTransparency) {
            for (let i = 3; i < buffer.length; i += 4) {
              if (buffer[i] === 0) {
                usesTransparency = true;
                i = buffer.length;
              }
            }
          }
        } else {
          for (let i = 3; i < buffer.length; i += 4) {
            if (buffer[i] === 0) {
              buffer.writeUInt32BE(this._transparentRGBA, i - 3);
              usesTransparency = true;
            }
          }
        }
        const frame = new GifFrame(info.width, info.height, buffer, {
          xOffset: info.x,
          yOffset: info.y,
          disposalMethod: info.disposal,
          interlaced: info.interlaced,
          delayCentisecs: info.delay
        });
        return { frame, usesTransparency };
      }
      _encodeGif(frames, spec) {
        let colorInfo;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          colorInfo = GifUtil.getColorInfo(frames, 0);
        } else {
          colorInfo = GifUtil.getColorInfo(frames, 256);
          if (!colorInfo.colors) {
            if (spec.colorScope === Gif.GlobalColorsOnly) {
              throw new GifError2("Too many color indexes for global color table");
            }
            spec.colorScope = Gif.LocalColorsOnly;
          }
        }
        spec.usesTransparency = colorInfo.usesTransparency;
        const localPalettes = colorInfo.palettes;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          const localSizeEst = 2e3;
          return _encodeLocal(frames, spec, localSizeEst, localPalettes);
        }
        const globalSizeEst = 2e3;
        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
      }
      _getSizeEstimateGlobal(globalPalette, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
        const pixelBitWidth = _getPixelBitWidth(globalPalette);
        frames.forEach((frame) => {
          sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
        });
        return sizeEst;
      }
      _getSizeEstimateLocal(palettes, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD;
        for (let i = 0; i < frames.length; ++i) {
          const palette = palettes[i];
          const pixelBitWidth = _getPixelBitWidth(palette);
          sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
        }
        return sizeEst;
      }
    };
    exports.GifCodec = GifCodec;
    function _colorLookupLinear(colors, color) {
      const index2 = colors.indexOf(color);
      return index2 === -1 ? null : index2;
    }
    function _colorLookupBinary(colors, color) {
      var lo = 0, hi = colors.length - 1, mid;
      while (lo <= hi) {
        mid = Math.floor((lo + hi) / 2);
        if (colors[mid] > color)
          hi = mid - 1;
        else if (colors[mid] < color)
          lo = mid + 1;
        else
          return mid;
      }
      return null;
    }
    function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
      const extendedGlobalPalette = {
        colors: globalPalette.colors.slice(),
        usesTransparency: globalPalette.usesTransparency
      };
      _extendPaletteToPowerOf2(extendedGlobalPalette);
      const options2 = {
        palette: extendedGlobalPalette.colors,
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options2);
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i = 0; i < frames.length; ++i) {
        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
      const options2 = {
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options2);
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i = 0; i < frames.length; ++i) {
        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _extendPaletteToPowerOf2(palette) {
      const colors = palette.colors;
      if (palette.usesTransparency) {
        colors.push(0);
      }
      const colorCount = colors.length;
      let powerOf2 = 2;
      while (colorCount > powerOf2) {
        powerOf2 <<= 1;
      }
      colors.length = powerOf2;
      colors.fill(0, colorCount);
    }
    function _getFrameSizeEst(frame, pixelBitWidth) {
      let byteLength = frame.bitmap.width * frame.bitmap.height;
      byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
      byteLength += Math.ceil(byteLength / 255);
      return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
    }
    function _getIndexedImage(frameIndex, frame, palette) {
      const colors = palette.colors;
      const colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary;
      const colorBuffer = frame.bitmap.data;
      const indexBuffer = new Buffer(colorBuffer.length / 4);
      let transparentIndex = colors.length;
      let i = 0, j = 0;
      while (i < colorBuffer.length) {
        if (colorBuffer[i + 3] !== 0) {
          const color = colorBuffer.readUInt32BE(i, true) >> 8 & 16777215;
          indexBuffer[j] = colorToIndexFunc(colors, color);
        } else {
          indexBuffer[j] = transparentIndex;
        }
        i += 4;
        ++j;
      }
      if (palette.usesTransparency) {
        if (transparentIndex === 256) {
          throw new GifError2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
        }
      } else {
        transparentIndex = null;
      }
      return { buffer: indexBuffer, transparentIndex };
    }
    function _getPixelBitWidth(palette) {
      let indexCount = palette.indexCount;
      let pixelBitWidth = 0;
      --indexCount;
      while (indexCount) {
        ++pixelBitWidth;
        indexCount >>= 1;
      }
      return pixelBitWidth > 0 ? pixelBitWidth : 1;
    }
    function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
      if (frame.interlaced) {
        throw new GifError2("writing interlaced GIFs is not supported");
      }
      const frameInfo = _getIndexedImage(frameIndex, frame, palette);
      const options2 = {
        delay: frame.delayCentisecs,
        disposal: frame.disposalMethod,
        transparent: frameInfo.transparentIndex
      };
      if (isLocalPalette) {
        _extendPaletteToPowerOf2(palette);
        options2.palette = palette.colors;
      }
      try {
        let buffer = gifWriter.getOutputBuffer();
        let startOfFrame = gifWriter.getOutputBufferPosition();
        let endOfFrame;
        let tryAgain = true;
        while (tryAgain) {
          endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options2);
          tryAgain = false;
          if (endOfFrame >= buffer.length - 1) {
            const biggerBuffer = new Buffer(buffer.length * 1.5);
            buffer.copy(biggerBuffer);
            gifWriter.setOutputBuffer(biggerBuffer);
            gifWriter.setOutputBufferPosition(startOfFrame);
            buffer = biggerBuffer;
            tryAgain = true;
          }
        }
        return buffer;
      } catch (err) {
        throw new GifError2(err);
      }
    }
  }
});

// node_modules/gifwrap/src/index.js
var require_src = __commonJS({
  "node_modules/gifwrap/src/index.js"(exports, module) {
    init_shims();
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { Gif, GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var { GifFrame } = require_gifframe();
    var GifUtil = require_gifutil();
    module.exports = {
      BitmapImage,
      Gif,
      GifCodec,
      GifFrame,
      GifUtil,
      GifError: GifError2
    };
  }
});

// node_modules/@jimp/gif/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@jimp/gif/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _omggif = _interopRequireDefault(require_omggif());
    var _gifwrap = require_src();
    var MIME_TYPE = "image/gif";
    var _default = function _default2() {
      return {
        mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["gif"]),
        constants: {
          MIME_GIF: MIME_TYPE
        },
        decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
          var gifObj = new _omggif["default"].GifReader(data);
          var gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
          gifObj.decodeAndBlitFrameRGBA(0, gifData);
          return {
            data: gifData,
            width: gifObj.width,
            height: gifObj.height
          };
        }),
        encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
          var bitmap = new _gifwrap.BitmapImage(data.bitmap);
          _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
          var newFrame = new _gifwrap.GifFrame(bitmap);
          var gifCodec = new _gifwrap.GifCodec();
          return gifCodec.encodeGif([newFrame], {}).then(function(newGif) {
            return newGif.buffer;
          });
        })
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/types/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@jimp/types/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _timm = require_timm();
    var _jpeg = _interopRequireDefault(require_dist4());
    var _png = _interopRequireDefault(require_dist5());
    var _bmp = _interopRequireDefault(require_dist6());
    var _tiff = _interopRequireDefault(require_dist7());
    var _gif = _interopRequireDefault(require_dist8());
    var _default = function _default2() {
      return (0, _timm.mergeDeep)((0, _jpeg["default"])(), (0, _png["default"])(), (0, _bmp["default"])(), (0, _tiff["default"])(), (0, _gif["default"])());
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-blit/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@jimp/plugin-blit/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        blit: function blit(src2, x, y, srcx, srcy, srcw, srch, cb) {
          if (!(src2 instanceof this.constructor)) {
            return _utils.throwError.call(this, "The source must be a Jimp image", cb);
          }
          if (typeof x !== "number" || typeof y !== "number") {
            return _utils.throwError.call(this, "x and y must be numbers", cb);
          }
          if (typeof srcx === "function") {
            cb = srcx;
            srcx = 0;
            srcy = 0;
            srcw = src2.bitmap.width;
            srch = src2.bitmap.height;
          } else if ((0, _typeof2["default"])(srcx) === (0, _typeof2["default"])(srcy) && (0, _typeof2["default"])(srcy) === (0, _typeof2["default"])(srcw) && (0, _typeof2["default"])(srcw) === (0, _typeof2["default"])(srch)) {
            srcx = srcx || 0;
            srcy = srcy || 0;
            srcw = srcw || src2.bitmap.width;
            srch = srch || src2.bitmap.height;
          } else {
            return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
          }
          x = Math.round(x);
          y = Math.round(y);
          srcx = Math.round(srcx);
          srcy = Math.round(srcy);
          srcw = Math.round(srcw);
          srch = Math.round(srch);
          var maxWidth = this.bitmap.width;
          var maxHeight = this.bitmap.height;
          var baseImage = this;
          src2.scanQuiet(srcx, srcy, srcw, srch, function(sx, sy, idx) {
            var xOffset = x + sx - srcx;
            var yOffset = y + sy - srcy;
            if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
              var dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
              var _src = {
                r: this.bitmap.data[idx],
                g: this.bitmap.data[idx + 1],
                b: this.bitmap.data[idx + 2],
                a: this.bitmap.data[idx + 3]
              };
              var dst = {
                r: baseImage.bitmap.data[dstIdx],
                g: baseImage.bitmap.data[dstIdx + 1],
                b: baseImage.bitmap.data[dstIdx + 2],
                a: baseImage.bitmap.data[dstIdx + 3]
              };
              baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r;
              baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g;
              baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b;
              baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
            }
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-blur/dist/blur-tables.js
var require_blur_tables = __commonJS({
  "node_modules/@jimp/plugin-blur/dist/blur-tables.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.shgTable = exports.mulTable = void 0;
    var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
    exports.mulTable = mulTable;
    var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
    exports.shgTable = shgTable;
  }
});

// node_modules/@jimp/plugin-blur/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@jimp/plugin-blur/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _blurTables = require_blur_tables();
    var _default = function _default2() {
      return {
        blur: function blur(r, cb) {
          if (typeof r !== "number")
            return _utils.throwError.call(this, "r must be a number", cb);
          if (r < 1)
            return _utils.throwError.call(this, "r must be greater than 0", cb);
          var rsum;
          var gsum;
          var bsum;
          var asum;
          var x;
          var y;
          var i;
          var p;
          var p1;
          var p2;
          var yp;
          var yi;
          var yw;
          var pa;
          var wm2 = this.bitmap.width - 1;
          var hm = this.bitmap.height - 1;
          var rad1 = r + 1;
          var mulSum = _blurTables.mulTable[r];
          var shgSum = _blurTables.shgTable[r];
          var red = [];
          var green = [];
          var blue = [];
          var alpha = [];
          var vmin = [];
          var vmax = [];
          var iterations = 2;
          while (iterations-- > 0) {
            yi = 0;
            yw = 0;
            for (y = 0; y < this.bitmap.height; y++) {
              rsum = this.bitmap.data[yw] * rad1;
              gsum = this.bitmap.data[yw + 1] * rad1;
              bsum = this.bitmap.data[yw + 2] * rad1;
              asum = this.bitmap.data[yw + 3] * rad1;
              for (i = 1; i <= r; i++) {
                p = yw + ((i > wm2 ? wm2 : i) << 2);
                rsum += this.bitmap.data[p++];
                gsum += this.bitmap.data[p++];
                bsum += this.bitmap.data[p++];
                asum += this.bitmap.data[p];
              }
              for (x = 0; x < this.bitmap.width; x++) {
                red[yi] = rsum;
                green[yi] = gsum;
                blue[yi] = bsum;
                alpha[yi] = asum;
                if (y === 0) {
                  vmin[x] = ((p = x + rad1) < wm2 ? p : wm2) << 2;
                  vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
                }
                p1 = yw + vmin[x];
                p2 = yw + vmax[x];
                rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                asum += this.bitmap.data[p1] - this.bitmap.data[p2];
                yi++;
              }
              yw += this.bitmap.width << 2;
            }
            for (x = 0; x < this.bitmap.width; x++) {
              yp = x;
              rsum = red[yp] * rad1;
              gsum = green[yp] * rad1;
              bsum = blue[yp] * rad1;
              asum = alpha[yp] * rad1;
              for (i = 1; i <= r; i++) {
                yp += i > hm ? 0 : this.bitmap.width;
                rsum += red[yp];
                gsum += green[yp];
                bsum += blue[yp];
                asum += alpha[yp];
              }
              yi = x << 2;
              for (y = 0; y < this.bitmap.height; y++) {
                pa = asum * mulSum >>> shgSum;
                this.bitmap.data[yi + 3] = pa;
                if (pa > 255) {
                  this.bitmap.data[yi + 3] = 255;
                }
                if (pa > 0) {
                  pa = 255 / pa;
                  this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
                  this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
                  this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
                } else {
                  this.bitmap.data[yi + 2] = 0;
                  this.bitmap.data[yi + 1] = 0;
                  this.bitmap.data[yi] = 0;
                }
                if (x === 0) {
                  vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
                  vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
                }
                p1 = x + vmin[y];
                p2 = x + vmax[y];
                rsum += red[p1] - red[p2];
                gsum += green[p1] - green[p2];
                bsum += blue[p1] - blue[p2];
                asum += alpha[p1] - alpha[p2];
                yi += this.bitmap.width << 2;
              }
            }
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-circle/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@jimp/plugin-circle/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        circle: function circle() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var cb = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof options2 === "function") {
            cb = options2;
            options2 = {};
          }
          var radius = options2.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;
          var center = {
            x: typeof options2.x === "number" ? options2.x : this.bitmap.width / 2,
            y: typeof options2.y === "number" ? options2.y : this.bitmap.height / 2
          };
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
            if (radius - curR <= 0) {
              this.bitmap.data[idx + 3] = 0;
            } else if (radius - curR < 1) {
              this.bitmap.data[idx + 3] = 255 * (radius - curR);
            }
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-color/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@jimp/plugin-color/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _tinycolor = _interopRequireDefault(require_tinycolor());
    var _utils = require_dist();
    function applyKernel(im, kernel, x, y) {
      var value = [0, 0, 0];
      var size = (kernel.length - 1) / 2;
      for (var kx = 0; kx < kernel.length; kx += 1) {
        for (var ky = 0; ky < kernel[kx].length; ky += 1) {
          var idx = im.getPixelIndex(x + kx - size, y + ky - size);
          value[0] += im.bitmap.data[idx] * kernel[kx][ky];
          value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
          value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
        }
      }
      return value;
    }
    var isDef = function isDef2(v) {
      return typeof v !== "undefined" && v !== null;
    };
    function greyscale(cb) {
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
        this.bitmap.data[idx] = grey;
        this.bitmap.data[idx + 1] = grey;
        this.bitmap.data[idx + 2] = grey;
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    function mix(clr, clr2) {
      var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
      return {
        r: (clr2.r - clr.r) * (p / 100) + clr.r,
        g: (clr2.g - clr.g) * (p / 100) + clr.g,
        b: (clr2.b - clr.b) * (p / 100) + clr.b
      };
    }
    function colorFn(actions, cb) {
      var _this = this;
      if (!actions || !Array.isArray(actions)) {
        return _utils.throwError.call(this, "actions must be an array", cb);
      }
      actions = actions.map(function(action) {
        if (action.apply === "xor" || action.apply === "mix") {
          action.params[0] = (0, _tinycolor["default"])(action.params[0]).toRgb();
        }
        return action;
      });
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        var clr = {
          r: _this.bitmap.data[idx],
          g: _this.bitmap.data[idx + 1],
          b: _this.bitmap.data[idx + 2]
        };
        var colorModifier = function colorModifier2(i, amount) {
          return _this.constructor.limit255(clr[i] + amount);
        };
        actions.forEach(function(action) {
          if (action.apply === "mix") {
            clr = mix(clr, action.params[0], action.params[1]);
          } else if (action.apply === "tint") {
            clr = mix(clr, {
              r: 255,
              g: 255,
              b: 255
            }, action.params[0]);
          } else if (action.apply === "shade") {
            clr = mix(clr, {
              r: 0,
              g: 0,
              b: 0
            }, action.params[0]);
          } else if (action.apply === "xor") {
            clr = {
              r: clr.r ^ action.params[0].r,
              g: clr.g ^ action.params[0].g,
              b: clr.b ^ action.params[0].b
            };
          } else if (action.apply === "red") {
            clr.r = colorModifier("r", action.params[0]);
          } else if (action.apply === "green") {
            clr.g = colorModifier("g", action.params[0]);
          } else if (action.apply === "blue") {
            clr.b = colorModifier("b", action.params[0]);
          } else {
            var _clr;
            if (action.apply === "hue") {
              action.apply = "spin";
            }
            clr = (0, _tinycolor["default"])(clr);
            if (!clr[action.apply]) {
              return _utils.throwError.call(_this, "action " + action.apply + " not supported", cb);
            }
            clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2["default"])(action.params)).toRgb();
          }
        });
        _this.bitmap.data[idx] = clr.r;
        _this.bitmap.data[idx + 1] = clr.g;
        _this.bitmap.data[idx + 2] = clr.b;
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var _default = function _default2() {
      return {
        brightness: function brightness(val, cb) {
          if (typeof val !== "number") {
            return _utils.throwError.call(this, "val must be numbers", cb);
          }
          if (val < -1 || val > 1) {
            return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
          }
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            if (val < 0) {
              this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);
              this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);
              this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);
            } else {
              this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;
              this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;
              this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;
            }
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        contrast: function contrast(val, cb) {
          if (typeof val !== "number") {
            return _utils.throwError.call(this, "val must be numbers", cb);
          }
          if (val < -1 || val > 1) {
            return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
          }
          var factor = (val + 1) / (1 - val);
          function adjust(value) {
            value = Math.floor(factor * (value - 127) + 127);
            return value < 0 ? 0 : value > 255 ? 255 : value;
          }
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
            this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
            this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        posterize: function posterize(n, cb) {
          if (typeof n !== "number") {
            return _utils.throwError.call(this, "n must be numbers", cb);
          }
          if (n < 2) {
            n = 2;
          }
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
            this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
            this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        greyscale,
        grayscale: greyscale,
        opacity: function opacity(f, cb) {
          if (typeof f !== "number")
            return _utils.throwError.call(this, "f must be a number", cb);
          if (f < 0 || f > 1)
            return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var v = this.bitmap.data[idx + 3] * f;
            this.bitmap.data[idx + 3] = v;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        sepia: function sepia(cb) {
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var red = this.bitmap.data[idx];
            var green = this.bitmap.data[idx + 1];
            var blue = this.bitmap.data[idx + 2];
            red = red * 0.393 + green * 0.769 + blue * 0.189;
            green = red * 0.349 + green * 0.686 + blue * 0.168;
            blue = red * 0.272 + green * 0.534 + blue * 0.131;
            this.bitmap.data[idx] = red < 255 ? red : 255;
            this.bitmap.data[idx + 1] = green < 255 ? green : 255;
            this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        fade: function fade(f, cb) {
          if (typeof f !== "number") {
            return _utils.throwError.call(this, "f must be a number", cb);
          }
          if (f < 0 || f > 1) {
            return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
          }
          this.opacity(1 - f);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        convolution: function convolution(kernel, edgeHandling, cb) {
          if (typeof edgeHandling === "function" && typeof cb === "undefined") {
            cb = edgeHandling;
            edgeHandling = null;
          }
          if (!edgeHandling) {
            edgeHandling = this.constructor.EDGE_EXTEND;
          }
          var newData = Buffer.from(this.bitmap.data);
          var kRows = kernel.length;
          var kCols = kernel[0].length;
          var rowEnd = Math.floor(kRows / 2);
          var colEnd = Math.floor(kCols / 2);
          var rowIni = -rowEnd;
          var colIni = -colEnd;
          var weight;
          var rSum;
          var gSum;
          var bSum;
          var ri;
          var gi;
          var bi;
          var xi;
          var yi;
          var idxi;
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            bSum = 0;
            gSum = 0;
            rSum = 0;
            for (var row = rowIni; row <= rowEnd; row++) {
              for (var col = colIni; col <= colEnd; col++) {
                xi = x + col;
                yi = y + row;
                weight = kernel[row + rowEnd][col + colEnd];
                idxi = this.getPixelIndex(xi, yi, edgeHandling);
                if (idxi === -1) {
                  bi = 0;
                  gi = 0;
                  ri = 0;
                } else {
                  ri = this.bitmap.data[idxi + 0];
                  gi = this.bitmap.data[idxi + 1];
                  bi = this.bitmap.data[idxi + 2];
                }
                rSum += weight * ri;
                gSum += weight * gi;
                bSum += weight * bi;
              }
            }
            if (rSum < 0) {
              rSum = 0;
            }
            if (gSum < 0) {
              gSum = 0;
            }
            if (bSum < 0) {
              bSum = 0;
            }
            if (rSum > 255) {
              rSum = 255;
            }
            if (gSum > 255) {
              gSum = 255;
            }
            if (bSum > 255) {
              bSum = 255;
            }
            newData[idx + 0] = rSum;
            newData[idx + 1] = gSum;
            newData[idx + 2] = bSum;
          });
          this.bitmap.data = newData;
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        opaque: function opaque(cb) {
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            this.bitmap.data[idx + 3] = 255;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        pixelate: function pixelate(size, x, y, w, h, cb) {
          if (typeof x === "function") {
            cb = x;
            h = null;
            w = null;
            y = null;
            x = null;
          } else {
            if (typeof size !== "number") {
              return _utils.throwError.call(this, "size must be a number", cb);
            }
            if (isDef(x) && typeof x !== "number") {
              return _utils.throwError.call(this, "x must be a number", cb);
            }
            if (isDef(y) && typeof y !== "number") {
              return _utils.throwError.call(this, "y must be a number", cb);
            }
            if (isDef(w) && typeof w !== "number") {
              return _utils.throwError.call(this, "w must be a number", cb);
            }
            if (isDef(h) && typeof h !== "number") {
              return _utils.throwError.call(this, "h must be a number", cb);
            }
          }
          var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
          x = x || 0;
          y = y || 0;
          w = isDef(w) ? w : this.bitmap.width - x;
          h = isDef(h) ? h : this.bitmap.height - y;
          var source = this.cloneQuiet();
          this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
            xx = size * Math.floor(xx / size);
            yx = size * Math.floor(yx / size);
            var value = applyKernel(source, kernel, xx, yx);
            this.bitmap.data[idx] = value[0];
            this.bitmap.data[idx + 1] = value[1];
            this.bitmap.data[idx + 2] = value[2];
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        convolute: function convolute(kernel, x, y, w, h, cb) {
          if (!Array.isArray(kernel))
            return _utils.throwError.call(this, "the kernel must be an array", cb);
          if (typeof x === "function") {
            cb = x;
            x = null;
            y = null;
            w = null;
            h = null;
          } else {
            if (isDef(x) && typeof x !== "number") {
              return _utils.throwError.call(this, "x must be a number", cb);
            }
            if (isDef(y) && typeof y !== "number") {
              return _utils.throwError.call(this, "y must be a number", cb);
            }
            if (isDef(w) && typeof w !== "number") {
              return _utils.throwError.call(this, "w must be a number", cb);
            }
            if (isDef(h) && typeof h !== "number") {
              return _utils.throwError.call(this, "h must be a number", cb);
            }
          }
          var ksize = (kernel.length - 1) / 2;
          x = isDef(x) ? x : ksize;
          y = isDef(y) ? y : ksize;
          w = isDef(w) ? w : this.bitmap.width - x;
          h = isDef(h) ? h : this.bitmap.height - y;
          var source = this.cloneQuiet();
          this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
            var value = applyKernel(source, kernel, xx, yx);
            this.bitmap.data[idx] = this.constructor.limit255(value[0]);
            this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);
            this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        color: colorFn,
        colour: colorFn
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-contain/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/@jimp/plugin-contain/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        contain: function contain(w, h, alignBits, mode, cb) {
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers", cb);
          }
          if (typeof alignBits === "string") {
            if (typeof mode === "function" && typeof cb === "undefined")
              cb = mode;
            mode = alignBits;
            alignBits = null;
          }
          if (typeof alignBits === "function") {
            if (typeof cb === "undefined")
              cb = alignBits;
            mode = null;
            alignBits = null;
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
          var hbits = alignBits & (1 << 3) - 1;
          var vbits = alignBits >> 3;
          if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
            return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
          }
          var alignH = hbits >> 1;
          var alignV = vbits >> 1;
          var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
          var c = this.cloneQuiet().scale(f, mode);
          this.resize(w, h, mode);
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            this.bitmap.data.writeUInt32BE(this._background, idx);
          });
          this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-cover/dist/index.js
var require_dist15 = __commonJS({
  "node_modules/@jimp/plugin-cover/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        cover: function cover(w, h, alignBits, mode, cb) {
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers", cb);
          }
          if (alignBits && typeof alignBits === "function" && typeof cb === "undefined") {
            cb = alignBits;
            alignBits = null;
            mode = null;
          } else if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
          var hbits = alignBits & (1 << 3) - 1;
          var vbits = alignBits >> 3;
          if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1)))
            return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
          var alignH = hbits >> 1;
          var alignV = vbits >> 1;
          var f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
          this.scale(f, mode);
          this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-crop/dist/index.js
var require_dist16 = __commonJS({
  "node_modules/@jimp/plugin-crop/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = pluginCrop;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _utils = require_dist();
    function pluginCrop(event) {
      event("crop", function(x, y, w, h, cb) {
        if (typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        if (typeof w !== "number" || typeof h !== "number")
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        w = Math.round(w);
        h = Math.round(h);
        if (x === 0 && w === this.bitmap.width) {
          var start = w * y + x << 2;
          var end = start + h * w << 2;
          this.bitmap.data = this.bitmap.data.slice(start, end);
        } else {
          var bitmap = Buffer.allocUnsafe(w * h * 4);
          var offset = 0;
          this.scanQuiet(x, y, w, h, function(x2, y2, idx) {
            var data = this.bitmap.data.readUInt32BE(idx, true);
            bitmap.writeUInt32BE(data, offset, true);
            offset += 4;
          });
          this.bitmap.data = bitmap;
        }
        this.bitmap.width = w;
        this.bitmap.height = h;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      });
      return {
        "class": {
          autocrop: function autocrop() {
            var w = this.bitmap.width;
            var h = this.bitmap.height;
            var minPixelsPerSide = 1;
            var cb;
            var leaveBorder = 0;
            var tolerance = 2e-4;
            var cropOnlyFrames = true;
            var cropSymmetric = false;
            var ignoreSides = {
              north: false,
              south: false,
              east: false,
              west: false
            };
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            for (var a = 0, len = args.length; a < len; a++) {
              if (typeof args[a] === "number") {
                tolerance = args[a];
              }
              if (typeof args[a] === "boolean") {
                cropOnlyFrames = args[a];
              }
              if (typeof args[a] === "function") {
                cb = args[a];
              }
              if ((0, _typeof2["default"])(args[a]) === "object") {
                var config2 = args[a];
                if (typeof config2.tolerance !== "undefined") {
                  tolerance = config2.tolerance;
                }
                if (typeof config2.cropOnlyFrames !== "undefined") {
                  cropOnlyFrames = config2.cropOnlyFrames;
                }
                if (typeof config2.cropSymmetric !== "undefined") {
                  cropSymmetric = config2.cropSymmetric;
                }
                if (typeof config2.leaveBorder !== "undefined") {
                  leaveBorder = config2.leaveBorder;
                }
                if (typeof config2.ignoreSides !== "undefined") {
                  ignoreSides = config2.ignoreSides;
                }
              }
            }
            var colorTarget = this.getPixelColor(0, 0);
            var rgba1 = this.constructor.intToRGBA(colorTarget);
            var northPixelsToCrop = 0;
            var eastPixelsToCrop = 0;
            var southPixelsToCrop = 0;
            var westPixelsToCrop = 0;
            colorTarget = this.getPixelColor(0, 0);
            if (!ignoreSides.north) {
              north:
                for (var y = 0; y < h - minPixelsPerSide; y++) {
                  for (var x = 0; x < w; x++) {
                    var colorXY = this.getPixelColor(x, y);
                    var rgba2 = this.constructor.intToRGBA(colorXY);
                    if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                      break north;
                    }
                  }
                  northPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(w, 0);
            if (!ignoreSides.east) {
              east:
                for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
                  for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
                    var _colorXY = this.getPixelColor(_x, _y);
                    var _rgba = this.constructor.intToRGBA(_colorXY);
                    if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {
                      break east;
                    }
                  }
                  eastPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(0, h);
            if (!ignoreSides.south) {
              south:
                for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
                  for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
                    var _colorXY2 = this.getPixelColor(_x2, _y2);
                    var _rgba2 = this.constructor.intToRGBA(_colorXY2);
                    if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {
                      break south;
                    }
                  }
                  southPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(w, h);
            if (!ignoreSides.west) {
              west:
                for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
                  for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
                    var _colorXY3 = this.getPixelColor(_x3, _y3);
                    var _rgba3 = this.constructor.intToRGBA(_colorXY3);
                    if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {
                      break west;
                    }
                  }
                  westPixelsToCrop++;
                }
            }
            var doCrop = false;
            westPixelsToCrop -= leaveBorder;
            eastPixelsToCrop -= leaveBorder;
            northPixelsToCrop -= leaveBorder;
            southPixelsToCrop -= leaveBorder;
            if (cropSymmetric) {
              var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
              var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
              westPixelsToCrop = horizontal;
              eastPixelsToCrop = horizontal;
              northPixelsToCrop = vertical;
              southPixelsToCrop = vertical;
            }
            westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
            eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
            northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
            southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
            var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
            var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
            if (cropOnlyFrames) {
              doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
            } else {
              doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
            }
            if (doCrop) {
              this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
            }
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
        }
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-displace/dist/index.js
var require_dist17 = __commonJS({
  "node_modules/@jimp/plugin-displace/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        displace: function displace(map, offset, cb) {
          if ((0, _typeof2["default"])(map) !== "object" || map.constructor !== this.constructor) {
            return _utils.throwError.call(this, "The source must be a Jimp image", cb);
          }
          if (typeof offset !== "number") {
            return _utils.throwError.call(this, "factor must be a number", cb);
          }
          var source = this.cloneQuiet();
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var displacement = map.bitmap.data[idx] / 256 * offset;
            displacement = Math.round(displacement);
            var ids = this.getPixelIndex(x + displacement, y);
            this.bitmap.data[ids] = source.bitmap.data[idx];
            this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
            this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-dither/dist/index.js
var require_dist18 = __commonJS({
  "node_modules/@jimp/plugin-dither/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    function dither(cb) {
      var rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        var thresholdId = ((y & 3) << 2) + x % 4;
        var dither2 = rgb565Matrix[thresholdId];
        this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither2, 255);
        this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither2, 255);
        this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither2, 255);
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var _default = function _default2() {
      return {
        dither565: dither,
        dither16: dither
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-fisheye/dist/index.js
var require_dist19 = __commonJS({
  "node_modules/@jimp/plugin-fisheye/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        fisheye: function fisheye() {
          var _this = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            r: 2.5
          };
          var cb = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof options2 === "function") {
            cb = options2;
            options2 = {
              r: 2.5
            };
          }
          var source = this.cloneQuiet();
          var _source$bitmap = source.bitmap, width = _source$bitmap.width, height = _source$bitmap.height;
          source.scanQuiet(0, 0, width, height, function(x, y) {
            var hx = x / width;
            var hy = y / height;
            var r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
            var rn = 2 * Math.pow(r, options2.r);
            var cosA = (hx - 0.5) / r;
            var sinA = (hy - 0.5) / r;
            var newX = Math.round((rn * cosA + 0.5) * width);
            var newY = Math.round((rn * sinA + 0.5) * height);
            var color = source.getPixelColor(newX, newY);
            _this.setPixelColor(color, x, y);
          });
          this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-flip/dist/index.js
var require_dist20 = __commonJS({
  "node_modules/@jimp/plugin-flip/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    function flipFn(horizontal, vertical, cb) {
      if (typeof horizontal !== "boolean" || typeof vertical !== "boolean")
        return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
      var bitmap = Buffer.alloc(this.bitmap.data.length);
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        var _x = horizontal ? this.bitmap.width - 1 - x : x;
        var _y = vertical ? this.bitmap.height - 1 - y : y;
        var _idx = this.bitmap.width * _y + _x << 2;
        var data = this.bitmap.data.readUInt32BE(idx);
        bitmap.writeUInt32BE(data, _idx);
      });
      this.bitmap.data = Buffer.from(bitmap);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var _default = function _default2() {
      return {
        flip: flipFn,
        mirror: flipFn
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-gaussian/dist/index.js
var require_dist21 = __commonJS({
  "node_modules/@jimp/plugin-gaussian/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        gaussian: function gaussian(r, cb) {
          if (typeof r !== "number") {
            return _utils.throwError.call(this, "r must be a number", cb);
          }
          if (r < 1) {
            return _utils.throwError.call(this, "r must be greater than 0", cb);
          }
          var rs = Math.ceil(r * 2.57);
          var range = rs * 2 + 1;
          var rr2 = r * r * 2;
          var rr2pi = rr2 * Math.PI;
          var weights = [];
          for (var y = 0; y < range; y++) {
            weights[y] = [];
            for (var x = 0; x < range; x++) {
              var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
              weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
            }
          }
          for (var _y = 0; _y < this.bitmap.height; _y++) {
            for (var _x = 0; _x < this.bitmap.width; _x++) {
              var red = 0;
              var green = 0;
              var blue = 0;
              var alpha = 0;
              var wsum = 0;
              for (var iy = 0; iy < range; iy++) {
                for (var ix = 0; ix < range; ix++) {
                  var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs));
                  var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs));
                  var weight = weights[iy][ix];
                  var _idx = y1 * this.bitmap.width + x1 << 2;
                  red += this.bitmap.data[_idx] * weight;
                  green += this.bitmap.data[_idx + 1] * weight;
                  blue += this.bitmap.data[_idx + 2] * weight;
                  alpha += this.bitmap.data[_idx + 3] * weight;
                  wsum += weight;
                }
                var idx = _y * this.bitmap.width + _x << 2;
                this.bitmap.data[idx] = Math.round(red / wsum);
                this.bitmap.data[idx + 1] = Math.round(green / wsum);
                this.bitmap.data[idx + 2] = Math.round(blue / wsum);
                this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
              }
            }
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-invert/dist/index.js
var require_dist22 = __commonJS({
  "node_modules/@jimp/plugin-invert/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        invert: function invert(cb) {
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
            this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
            this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-mask/dist/index.js
var require_dist23 = __commonJS({
  "node_modules/@jimp/plugin-mask/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        mask: function mask(src2) {
          var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var cb = arguments.length > 3 ? arguments[3] : void 0;
          if (!(src2 instanceof this.constructor)) {
            return _utils.throwError.call(this, "The source must be a Jimp image", cb);
          }
          if (typeof x !== "number" || typeof y !== "number") {
            return _utils.throwError.call(this, "x and y must be numbers", cb);
          }
          x = Math.round(x);
          y = Math.round(y);
          var w = this.bitmap.width;
          var h = this.bitmap.height;
          var baseImage = this;
          src2.scanQuiet(0, 0, src2.bitmap.width, src2.bitmap.height, function(sx, sy, idx) {
            var destX = x + sx;
            var destY = y + sy;
            if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
              var dstIdx = baseImage.getPixelIndex(destX, destY);
              var data = this.bitmap.data;
              var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
              baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
            }
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-normalize/dist/index.js
var require_dist24 = __commonJS({
  "node_modules/@jimp/plugin-normalize/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    function histogram() {
      var histogram2 = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0)
      };
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index2) {
        histogram2.r[this.bitmap.data[index2 + 0]]++;
        histogram2.g[this.bitmap.data[index2 + 1]]++;
        histogram2.b[this.bitmap.data[index2 + 2]]++;
      });
      return histogram2;
    }
    var _normalize = function normalize3(value, min, max) {
      return (value - min) * 255 / (max - min);
    };
    var getBounds = function getBounds2(histogramChannel) {
      return [histogramChannel.findIndex(function(value) {
        return value > 0;
      }), 255 - histogramChannel.slice().reverse().findIndex(function(value) {
        return value > 0;
      })];
    };
    var _default = function _default2() {
      return {
        normalize: function normalize3(cb) {
          var h = histogram.call(this);
          var bounds = {
            r: getBounds(h.r),
            g: getBounds(h.g),
            b: getBounds(h.b)
          };
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var r = this.bitmap.data[idx + 0];
            var g = this.bitmap.data[idx + 1];
            var b = this.bitmap.data[idx + 2];
            this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);
            this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);
            this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/parse-bmfont-ascii/index.js
var require_parse_bmfont_ascii = __commonJS({
  "node_modules/parse-bmfont-ascii/index.js"(exports, module) {
    init_shims();
    module.exports = function parseBMFontAscii(data) {
      if (!data)
        throw new Error("no data provided");
      data = data.toString().trim();
      var output = {
        pages: [],
        chars: [],
        kernings: []
      };
      var lines = data.split(/\r\n?|\n/g);
      if (lines.length === 0)
        throw new Error("no data in BMFont file");
      for (var i = 0; i < lines.length; i++) {
        var lineData = splitLine(lines[i], i);
        if (!lineData)
          continue;
        if (lineData.key === "page") {
          if (typeof lineData.data.id !== "number")
            throw new Error("malformed file at line " + i + " -- needs page id=N");
          if (typeof lineData.data.file !== "string")
            throw new Error("malformed file at line " + i + ' -- needs page file="path"');
          output.pages[lineData.data.id] = lineData.data.file;
        } else if (lineData.key === "chars" || lineData.key === "kernings") {
        } else if (lineData.key === "char") {
          output.chars.push(lineData.data);
        } else if (lineData.key === "kerning") {
          output.kernings.push(lineData.data);
        } else {
          output[lineData.key] = lineData.data;
        }
      }
      return output;
    };
    function splitLine(line, idx) {
      line = line.replace(/\t+/g, " ").trim();
      if (!line)
        return null;
      var space = line.indexOf(" ");
      if (space === -1)
        throw new Error("no named row at line " + idx);
      var key = line.substring(0, space);
      line = line.substring(space + 1);
      line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, "");
      line = line.split("=");
      line = line.map(function(str) {
        return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
      });
      var data = [];
      for (var i = 0; i < line.length; i++) {
        var dt = line[i];
        if (i === 0) {
          data.push({
            key: dt[0],
            data: ""
          });
        } else if (i === line.length - 1) {
          data[data.length - 1].data = parseData(dt[0]);
        } else {
          data[data.length - 1].data = parseData(dt[0]);
          data.push({
            key: dt[1],
            data: ""
          });
        }
      }
      var out = {
        key,
        data: {}
      };
      data.forEach(function(v) {
        out.data[v.key] = v.data;
      });
      return out;
    }
    function parseData(data) {
      if (!data || data.length === 0)
        return "";
      if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
        return data.substring(1, data.length - 1);
      if (data.indexOf(",") !== -1)
        return parseIntList(data);
      return parseInt(data, 10);
    }
    function parseIntList(data) {
      return data.split(",").map(function(val) {
        return parseInt(val, 10);
      });
    }
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports) {
    init_shims();
    (function() {
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports, module) {
    init_shims();
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject2, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject2 = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject2(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module.exports.assign = assign;
      module.exports.isFunction = isFunction;
      module.exports.isObject = isObject2;
      module.exports.isArray = isArray;
      module.exports.isEmpty = isEmpty;
      module.exports.isPlainObject = isPlainObject;
      module.exports.getValue = getValue;
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module) {
    init_shims();
    (function() {
      var XMLDOMImplementation;
      module.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module) {
    init_shims();
    (function() {
      var XMLDOMErrorHandler;
      module.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        XMLDOMErrorHandler2.prototype.handleError = function(error2) {
          throw new Error(error2);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module) {
    init_shims();
    (function() {
      var XMLDOMStringList;
      module.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        XMLDOMStringList2.prototype.item = function(index2) {
          return this.arr[index2] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module) {
    init_shims();
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name) {
          if (this.params.hasOwnProperty(name)) {
            return this.params[name];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
          if (value != null) {
            return this.params[name] = value;
          } else {
            return delete this.params[name];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports, module) {
    init_shims();
    (function() {
      module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.value = this.stringify.attValue(value);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options2) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options2));
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module) {
    init_shims();
    (function() {
      var XMLNamedNodeMap;
      module.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
          return this.nodes[name];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
          var oldNode;
          oldNode = this.nodes[name];
          delete this.nodes[name];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index2) {
          return this.nodes[Object.keys(this.nodes)[index2]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject2, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject2 = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject2(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, j, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              attName = name[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options2) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options2));
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.getAttribute = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name) {
          return this.attribs.hasOwnProperty(name);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name, isId) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module) {
    init_shims();
    (function() {
      var XMLCharacterData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = "";
        }
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text2) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text2 == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text2);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options2) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options2));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text2) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text2 == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text2);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options2) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options2));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject2, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject2(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options2) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options2));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options2) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options2));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject2, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name);
          this.type = NodeType.EntityDeclaration;
          if (!isObject2(value)) {
            this.value = this.stringify.dtdEntityValue(value);
            this.internal = true;
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            this.internal = false;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        XMLDTDEntity2.prototype.toString = function(options2) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options2));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function(options2) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options2));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.NotationDeclaration;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        XMLDTDNotation2.prototype.toString = function(options2) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options2));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject2, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject2(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options2) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options2));
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text2) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text2 == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text2);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options2) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options2));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text2) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text2 == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text2);
        }
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options2) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options2));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options2) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options2));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options2) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module) {
    init_shims();
    (function() {
      var XMLNodeList;
      module.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index2) {
          return this.nodes[index2] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module) {
    init_shims();
    (function() {
      module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module) {
    init_shims();
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject2, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject2 = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLNode2.prototype.setParent = function(parent) {
          var child, j, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name, attributes, text2) {
          var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text2 == null) {
            ref2 = [{}, null], attributes = ref2[0], text2 = ref2[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref3 = [attributes, text2], text2 = ref3[0], attributes = ref3[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject2(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject2(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject2(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text2 === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text2);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text2);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text2);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text2);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text2);
            } else {
              lastChild = this.node(name, attributes, text2);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text2) {
          var child, i, newChild, refChild, removed;
          if (name != null ? name.type : void 0) {
            newChild = name;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i = children.indexOf(refChild);
              removed = children.splice(i);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.element(name, attributes, text2);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text2) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text2);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text2) {
          var child, ref2;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref2 = [attributes, text2], text2 = ref2[0], attributes = ref2[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text2 != null) {
            child.text(text2);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          if (isObject2(value)) {
            this.element(value);
          }
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject2(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            child = ref2[i];
            if (child.type === NodeType.DocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
            child = ref3[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options2) {
          return this.document().end(options2);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref2, ref3;
          name = name || this.name;
          if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes, text2) {
          return this.element(name, attributes, text2);
        };
        XMLNode2.prototype.nod = function(name, attributes, text2) {
          return this.node(name, attributes, text2);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name, attributes, text2) {
          return this.element(name, attributes, text2);
        };
        XMLNode2.prototype.n = function(name, attributes, text2) {
          return this.node(name, attributes, text2);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
            if (!this.children[i].isEqualNode(node.children[i])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module) {
    init_shims();
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module.exports = XMLStringifier = function() {
        function XMLStringifier2(options2) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options2 || (options2 = {});
          this.options = options2;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options2.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.name = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName("" + val || "");
        };
        XMLStringifier2.prototype.text = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.insValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports, module) {
    init_shims();
    (function() {
      module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options2) {
          var key, ref, value;
          options2 || (options2 = {});
          this.options = options2;
          ref = options2.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this["_" + key] = this[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function(options2) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options2 || (options2 = {});
          options2 = assign({}, this.options, options2);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options2.pretty || false;
          filteredOptions.allowEmpty = options2.allowEmpty || false;
          filteredOptions.indent = (ref = options2.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options2.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options2.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options2.dontPrettyTextNodes) != null ? ref4 : options2.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options2.spaceBeforeSlash) != null ? ref6 : options2.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options2, level) {
          var indentLevel;
          if (!options2.pretty || options2.suppressPrettyCount) {
            return "";
          } else if (options2.pretty) {
            indentLevel = (level || 0) + options2.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options2.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options2, level) {
          if (!options2.pretty || options2.suppressPrettyCount) {
            return "";
          } else {
            return options2.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options2, level) {
          var r;
          this.openAttribute(att, options2, level);
          r = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<![CDATA[";
          options2.state = WriterState.InsideTag;
          r += node.value;
          options2.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<!-- ";
          options2.state = WriterState.InsideTag;
          r += node.value;
          options2.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<?xml";
          options2.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + "?>";
          r += this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function(node, options2, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options2, level);
            options2.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options2, level + 1);
            }
            options2.state = WriterState.CloseTag;
            r += "]";
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + ">";
          r += this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function(node, options2, level) {
          var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = "";
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r += this.indent(node, options2, level) + "<" + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r += this.attribute(att, options2, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options2.allowEmpty) {
              r += ">";
              options2.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options2, level);
            } else {
              options2.state = WriterState.CloseTag;
              r += options2.spaceBeforeSlash + "/>" + this.endline(node, options2, level);
            }
          } else if (options2.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r += ">";
            options2.state = WriterState.InsideTag;
            options2.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options2, level + 1);
            options2.suppressPrettyCount--;
            prettySuppressed = false;
            options2.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options2, level);
          } else {
            if (options2.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options2.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options2, level);
            options2.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options2, level + 1);
            }
            options2.state = WriterState.CloseTag;
            r += this.indent(node, options2, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options2.suppressPrettyCount--;
            }
            r += this.endline(node, options2, level);
            options2.state = WriterState.None;
          }
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options2, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options2, level);
            case NodeType.Comment:
              return this.comment(node, options2, level);
            case NodeType.Element:
              return this.element(node, options2, level);
            case NodeType.Raw:
              return this.raw(node, options2, level);
            case NodeType.Text:
              return this.text(node, options2, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options2, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options2, level);
            case NodeType.DocType:
              return this.docType(node, options2, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options2, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options2, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options2, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options2, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<?";
          options2.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + "?>";
          r += this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level);
          options2.state = WriterState.InsideTag;
          r += node.value;
          options2.state = WriterState.CloseTag;
          r += this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level);
          options2.state = WriterState.InsideTag;
          r += node.value;
          options2.state = WriterState.CloseTag;
          r += this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<!ATTLIST";
          options2.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + ">" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<!ELEMENT";
          options2.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + ">" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<!ENTITY";
          options2.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + ">" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options2, level) {
          var r;
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          r = this.indent(node, options2, level) + "<!NOTATION";
          options2.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options2.state = WriterState.CloseTag;
          r += options2.spaceBeforeSlash + ">" + this.endline(node, options2, level);
          options2.state = WriterState.None;
          this.closeNode(node, options2, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function(node, options2, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options2, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options2, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options2, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module) {
    init_shims();
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options2) {
          XMLStringWriter2.__super__.constructor.call(this, options2);
        }
        XMLStringWriter2.prototype.document = function(doc, options2) {
          var child, i, len, r, ref;
          options2 = this.filterOptions(options2);
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options2, 0);
          }
          if (options2.pretty && r.slice(-options2.newline.length) === options2.newline) {
            r = r.slice(0, -options2.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options2) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options2 || (options2 = {});
          if (!options2.writer) {
            options2.writer = new XMLStringWriter();
          }
          this.options = options2;
          this.stringify = new XMLStringifier(options2);
        }
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options2) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options2));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject2, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject2 = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options2, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options2 || (options2 = {});
          writerOptions = {};
          if (!options2.writer) {
            options2.writer = new XMLStringWriter();
          } else if (isPlainObject(options2.writer)) {
            writerOptions = options2.writer;
            options2.writer = new XMLStringWriter();
          }
          this.options = options2;
          this.writer = options2.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options2);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes, child, i, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name, attributes, text2) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref1 = [attributes, text2], text2 = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text2 != null) {
            this.text(text2);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text2) {
          var child, i, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name) || isObject2(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text2);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject2(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject2(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk, name, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name in ref1) {
                if (!hasProp.call(ref1, name))
                  continue;
                att = ref1[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text2) {
          return this.node(name, attributes, text2);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text2) {
          return this.element(name, attributes, text2);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text2) {
          return this.node(name, attributes, text2);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options2) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options2);
        }
        XMLStreamWriter2.prototype.endline = function(node, options2, level) {
          if (node.isLastRootNode && options2.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options2, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options2) {
          var child, i, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options2 = this.filterOptions(options2);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options2, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options2, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options2, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options2, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options2, level));
            options2.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options2, level + 1);
            }
            options2.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options2.state = WriterState.CloseTag;
          this.stream.write(options2.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options2, level));
          options2.state = WriterState.None;
          return this.closeNode(node, options2, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options2, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options2, level);
          options2.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options2, level) + "<" + node.name);
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att, options2, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options2.allowEmpty) {
              this.stream.write(">");
              options2.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options2.state = WriterState.CloseTag;
              this.stream.write(options2.spaceBeforeSlash + "/>");
            }
          } else if (options2.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options2.state = WriterState.InsideTag;
            options2.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options2, level + 1);
            options2.suppressPrettyCount--;
            prettySuppressed = false;
            options2.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options2, level));
            options2.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options2, level + 1);
            }
            options2.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options2, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options2, level));
          options2.state = WriterState.None;
          return this.closeNode(node, options2, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options2, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options2, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options2, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports, module) {
    init_shims();
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module.exports.create = function(name, xmldec, doctype, options2) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options2 = assign({}, xmldec, doctype, options2);
        doc = new XMLDocument(options2);
        root = doc.element(name);
        if (!options2.headless) {
          doc.declaration(options2);
          if (options2.pubID != null || options2.sysID != null) {
            doc.dtd(options2);
          }
        }
        return root;
      };
      module.exports.begin = function(options2, onData, onEnd) {
        var ref1;
        if (isFunction(options2)) {
          ref1 = [options2, onData], onData = ref1[0], onEnd = ref1[1];
          options2 = {};
        }
        if (onData) {
          return new XMLDocumentCB(options2, onData, onEnd);
        } else {
          return new XMLDocument(options2);
        }
      };
      module.exports.stringWriter = function(options2) {
        return new XMLStringWriter(options2);
      };
      module.exports.streamWriter = function(stream, options2) {
        return new XMLStreamWriter(stream, options2);
      };
      module.exports.implementation = new XMLDOMImplementation();
      module.exports.nodeType = NodeType;
      module.exports.writerState = WriterState;
    }).call(exports);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports) {
    init_shims();
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render2, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render2 = function(_this) {
            return function(element, obj) {
              var attr, child, entry, index2, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index2 in obj) {
                  if (!hasProp.call(obj, index2))
                    continue;
                  child = obj[index2];
                  for (key in child) {
                    entry = child[key];
                    element = render2(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index2 in child) {
                      if (!hasProp.call(child, index2))
                        continue;
                      entry = child[index2];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render2(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render2(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render2(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    init_shims();
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error2(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = __require("stream").Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = __require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch2(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch2(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s3 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text2) {
        if (opt.trim)
          text2 = text2.trim();
        if (opt.normalize)
          text2 = text2.replace(/\s+/g, " ");
        return text2;
      }
      function error2(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error2(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error2(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s3 = parser.tags.length;
        while (s3-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error2(parser, "Cannot write after close. Assign an onready handler.");
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch2(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(parser, "Inappropriately located doctype declaration");
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch2(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch2(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch2(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch2(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch2(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch2(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch2(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index2 < length) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports) {
    init_shims();
    (function() {
      "use strict";
      exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports) {
    init_shims();
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports) {
    init_shims();
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = __require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate = __require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors2, item, key) {
        var i, len, process2;
        for (i = 0, len = processors2.length; i < len; i++) {
          process2 = processors2[i];
          item = process2(item, key);
        }
        return item;
      };
      exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error2) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error2);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s2, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s2 = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s2) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s2[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s2, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text2) {
              var charChild, s2;
              s2 = stack[stack.length - 1];
              if (s2) {
                s2[charkey] += text2;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text2.replace(/\\n/g, "").trim() !== "")) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text2;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s2[_this.options.childkey].push(charChild);
                }
                return s2;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text2) {
              var s2;
              s2 = ontext(text2);
              if (s2) {
                return s2.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser.prototype.parseStringPromise = function(str) {
          return new Promise(function(_this) {
            return function(resolve3, reject) {
              return _this.parseString(str, function(err, value) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve3(value);
                }
              });
            };
          }(this));
        };
        return Parser;
      }(events);
      exports.parseString = function(str, a, b) {
        var cb, options2, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options2 = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options2 = {};
        }
        parser = new exports.Parser(options2);
        return parser.parseString(str, cb);
      };
      exports.parseStringPromise = function(str, a) {
        var options2, parser;
        if (typeof a === "object") {
          options2 = a;
        }
        parser = new exports.Parser(options2);
        return parser.parseStringPromise(str);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports) {
    init_shims();
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser3();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
      exports.parseStringPromise = parser.parseStringPromise;
    }).call(exports);
  }
});

// node_modules/parse-bmfont-xml/lib/parse-attribs.js
var require_parse_attribs = __commonJS({
  "node_modules/parse-bmfont-xml/lib/parse-attribs.js"(exports, module) {
    init_shims();
    var GLYPH_DESIGNER_ERROR = "chasrset";
    module.exports = function parseAttributes(obj) {
      if (GLYPH_DESIGNER_ERROR in obj) {
        obj["charset"] = obj[GLYPH_DESIGNER_ERROR];
        delete obj[GLYPH_DESIGNER_ERROR];
      }
      for (var k in obj) {
        if (k === "face" || k === "charset")
          continue;
        else if (k === "padding" || k === "spacing")
          obj[k] = parseIntList(obj[k]);
        else
          obj[k] = parseInt(obj[k], 10);
      }
      return obj;
    };
    function parseIntList(data) {
      return data.split(",").map(function(val) {
        return parseInt(val, 10);
      });
    }
  }
});

// node_modules/parse-bmfont-xml/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/parse-bmfont-xml/lib/index.js"(exports, module) {
    init_shims();
    var xml2js = require_xml2js();
    var parseAttributes = require_parse_attribs();
    module.exports = function parseBMFontXML(data) {
      data = data.toString().trim();
      var output = {
        pages: [],
        chars: [],
        kernings: []
      };
      xml2js.parseString(data, function(err, result) {
        if (err)
          throw err;
        if (!result.font)
          throw "XML bitmap font doesn't have <font> root";
        result = result.font;
        output.common = parseAttributes(result.common[0].$);
        output.info = parseAttributes(result.info[0].$);
        for (var i = 0; i < result.pages.length; i++) {
          var p = result.pages[i].page[0].$;
          if (typeof p.id === "undefined")
            throw new Error("malformed file -- needs page id=N");
          if (typeof p.file !== "string")
            throw new Error('malformed file -- needs page file="path"');
          output.pages[parseInt(p.id, 10)] = p.file;
        }
        if (result.chars) {
          var chrArray = result.chars[0]["char"] || [];
          for (var i = 0; i < chrArray.length; i++) {
            output.chars.push(parseAttributes(chrArray[i].$));
          }
        }
        if (result.kernings) {
          var kernArray = result.kernings[0]["kerning"] || [];
          for (var i = 0; i < kernArray.length; i++) {
            output.kernings.push(parseAttributes(kernArray[i].$));
          }
        }
      });
      return output;
    };
  }
});

// node_modules/parse-bmfont-binary/index.js
var require_parse_bmfont_binary = __commonJS({
  "node_modules/parse-bmfont-binary/index.js"(exports, module) {
    init_shims();
    var HEADER = [66, 77, 70];
    module.exports = function readBMFontBinary(buf) {
      if (buf.length < 6)
        throw new Error("invalid buffer length for BMFont");
      var header = HEADER.every(function(byte, i2) {
        return buf.readUInt8(i2) === byte;
      });
      if (!header)
        throw new Error("BMFont missing BMF byte header");
      var i = 3;
      var vers = buf.readUInt8(i++);
      if (vers > 3)
        throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
      var target = { kernings: [], chars: [] };
      for (var b = 0; b < 5; b++)
        i += readBlock(target, buf, i);
      return target;
    };
    function readBlock(target, buf, i) {
      if (i > buf.length - 1)
        return 0;
      var blockID = buf.readUInt8(i++);
      var blockSize = buf.readInt32LE(i);
      i += 4;
      switch (blockID) {
        case 1:
          target.info = readInfo(buf, i);
          break;
        case 2:
          target.common = readCommon(buf, i);
          break;
        case 3:
          target.pages = readPages(buf, i, blockSize);
          break;
        case 4:
          target.chars = readChars(buf, i, blockSize);
          break;
        case 5:
          target.kernings = readKernings(buf, i, blockSize);
          break;
      }
      return 5 + blockSize;
    }
    function readInfo(buf, i) {
      var info = {};
      info.size = buf.readInt16LE(i);
      var bitField = buf.readUInt8(i + 2);
      info.smooth = bitField >> 7 & 1;
      info.unicode = bitField >> 6 & 1;
      info.italic = bitField >> 5 & 1;
      info.bold = bitField >> 4 & 1;
      if (bitField >> 3 & 1)
        info.fixedHeight = 1;
      info.charset = buf.readUInt8(i + 3) || "";
      info.stretchH = buf.readUInt16LE(i + 4);
      info.aa = buf.readUInt8(i + 6);
      info.padding = [
        buf.readInt8(i + 7),
        buf.readInt8(i + 8),
        buf.readInt8(i + 9),
        buf.readInt8(i + 10)
      ];
      info.spacing = [
        buf.readInt8(i + 11),
        buf.readInt8(i + 12)
      ];
      info.outline = buf.readUInt8(i + 13);
      info.face = readStringNT(buf, i + 14);
      return info;
    }
    function readCommon(buf, i) {
      var common = {};
      common.lineHeight = buf.readUInt16LE(i);
      common.base = buf.readUInt16LE(i + 2);
      common.scaleW = buf.readUInt16LE(i + 4);
      common.scaleH = buf.readUInt16LE(i + 6);
      common.pages = buf.readUInt16LE(i + 8);
      var bitField = buf.readUInt8(i + 10);
      common.packed = 0;
      common.alphaChnl = buf.readUInt8(i + 11);
      common.redChnl = buf.readUInt8(i + 12);
      common.greenChnl = buf.readUInt8(i + 13);
      common.blueChnl = buf.readUInt8(i + 14);
      return common;
    }
    function readPages(buf, i, size) {
      var pages = [];
      var text2 = readNameNT(buf, i);
      var len = text2.length + 1;
      var count = size / len;
      for (var c = 0; c < count; c++) {
        pages[c] = buf.slice(i, i + text2.length).toString("utf8");
        i += len;
      }
      return pages;
    }
    function readChars(buf, i, blockSize) {
      var chars2 = [];
      var count = blockSize / 20;
      for (var c = 0; c < count; c++) {
        var char = {};
        var off = c * 20;
        char.id = buf.readUInt32LE(i + 0 + off);
        char.x = buf.readUInt16LE(i + 4 + off);
        char.y = buf.readUInt16LE(i + 6 + off);
        char.width = buf.readUInt16LE(i + 8 + off);
        char.height = buf.readUInt16LE(i + 10 + off);
        char.xoffset = buf.readInt16LE(i + 12 + off);
        char.yoffset = buf.readInt16LE(i + 14 + off);
        char.xadvance = buf.readInt16LE(i + 16 + off);
        char.page = buf.readUInt8(i + 18 + off);
        char.chnl = buf.readUInt8(i + 19 + off);
        chars2[c] = char;
      }
      return chars2;
    }
    function readKernings(buf, i, blockSize) {
      var kernings = [];
      var count = blockSize / 10;
      for (var c = 0; c < count; c++) {
        var kern = {};
        var off = c * 10;
        kern.first = buf.readUInt32LE(i + 0 + off);
        kern.second = buf.readUInt32LE(i + 4 + off);
        kern.amount = buf.readInt16LE(i + 8 + off);
        kernings[c] = kern;
      }
      return kernings;
    }
    function readNameNT(buf, offset) {
      var pos = offset;
      for (; pos < buf.length; pos++) {
        if (buf[pos] === 0)
          break;
      }
      return buf.slice(offset, pos);
    }
    function readStringNT(buf, offset) {
      return readNameNT(buf, offset).toString("utf8");
    }
  }
});

// node_modules/mime/types.json
var require_types = __commonJS({
  "node_modules/mime/types.json"(exports, module) {
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/mime.js
var require_mime2 = __commonJS({
  "node_modules/mime/mime.js"(exports, module) {
    init_shims();
    var path2 = __require("path");
    var fs3 = __require("fs");
    function Mime2() {
      this.types = Object.create(null);
      this.extensions = Object.create(null);
    }
    Mime2.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts[i]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime2.prototype.load = function(file) {
      this._loading = file;
      var map = {}, content = fs3.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime2.prototype.lookup = function(path3, fallback) {
      var ext = path3.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime2.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime2();
    mime.define(require_types());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime2;
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
      }
    };
    module.exports = mime;
  }
});

// node_modules/buffer-equal/index.js
var require_buffer_equal = __commonJS({
  "node_modules/buffer-equal/index.js"(exports, module) {
    init_shims();
    var Buffer2 = __require("buffer").Buffer;
    module.exports = function(a, b) {
      if (!Buffer2.isBuffer(a))
        return void 0;
      if (!Buffer2.isBuffer(b))
        return void 0;
      if (typeof a.equals === "function")
        return a.equals(b);
      if (a.length !== b.length)
        return false;
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
  }
});

// node_modules/load-bmfont/lib/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/load-bmfont/lib/is-binary.js"(exports, module) {
    init_shims();
    var equal = require_buffer_equal();
    var HEADER = Buffer.from([66, 77, 70, 3]);
    module.exports = function(buf) {
      if (typeof buf === "string")
        return buf.substring(0, 3) === "BMF";
      return buf.length > 4 && equal(buf.slice(0, 4), HEADER);
    };
  }
});

// node_modules/load-bmfont/index.js
var require_load_bmfont = __commonJS({
  "node_modules/load-bmfont/index.js"(exports, module) {
    init_shims();
    var fs3 = __require("fs");
    var url = __require("url");
    var path2 = __require("path");
    var request = require_phin_compiled();
    var parseASCII = require_parse_bmfont_ascii();
    var parseXML = require_lib2();
    var readBinary = require_parse_bmfont_binary();
    var mime = require_mime2();
    var noop3 = function() {
    };
    var isBinary = require_is_binary();
    function parseFont(file, data, cb) {
      var result, binary;
      if (isBinary(data)) {
        if (typeof data === "string")
          data = Buffer.from(data, "binary");
        binary = true;
      } else
        data = data.toString().trim();
      try {
        if (binary)
          result = readBinary(data);
        else if (/json/.test(mime.lookup(file)) || data.charAt(0) === "{")
          result = JSON.parse(data);
        else if (/xml/.test(mime.lookup(file)) || data.charAt(0) === "<")
          result = parseXML(data);
        else
          result = parseASCII(data);
      } catch (e) {
        cb(e);
        cb = noop3;
      }
      cb(null, result);
    }
    module.exports = function loadFont(opt, cb) {
      cb = typeof cb === "function" ? cb : noop3;
      if (typeof opt === "string")
        opt = { uri: opt, url: opt };
      else if (!opt)
        opt = {};
      var file = opt.uri || opt.url;
      function handleData(err, data) {
        if (err)
          return cb(err);
        parseFont(file, data.body || data, cb);
      }
      if (url.parse(file).host) {
        request(opt, handleData);
      } else {
        fs3.readFile(file, opt, handleData);
      }
    };
  }
});

// node_modules/@jimp/plugin-print/dist/measure-text.js
var require_measure_text = __commonJS({
  "node_modules/@jimp/plugin-print/dist/measure-text.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.measureText = measureText;
    exports.measureTextHeight = measureTextHeight;
    function measureText(font, text2) {
      var x = 0;
      for (var i = 0; i < text2.length; i++) {
        if (font.chars[text2[i]]) {
          var kerning = font.kernings[text2[i]] && font.kernings[text2[i]][text2[i + 1]] ? font.kernings[text2[i]][text2[i + 1]] : 0;
          x += (font.chars[text2[i]].xadvance || 0) + kerning;
        }
      }
      return x;
    }
    function measureTextHeight(font, text2, maxWidth) {
      var words = text2.split(" ");
      var line = "";
      var textTotalHeight = font.common.lineHeight;
      for (var n = 0; n < words.length; n++) {
        var testLine = line + words[n] + " ";
        var testWidth = measureText(font, testLine);
        if (testWidth > maxWidth && n > 0) {
          textTotalHeight += font.common.lineHeight;
          line = words[n] + " ";
        } else {
          line = testLine;
        }
      }
      return textTotalHeight;
    }
  }
});

// node_modules/@jimp/plugin-print/dist/index.js
var require_dist25 = __commonJS({
  "node_modules/@jimp/plugin-print/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _path = _interopRequireDefault(__require("path"));
    var _loadBmfont = _interopRequireDefault(require_load_bmfont());
    var _utils = require_dist();
    var _measureText = require_measure_text();
    function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
      if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {
        return 0;
      }
      if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {
        return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;
      }
      return maxWidth - (0, _measureText.measureText)(font, line);
    }
    function drawCharacter(image2, font, x, y, _char) {
      if (_char.width > 0 && _char.height > 0) {
        var characterPage = font.pages[_char.page];
        image2.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);
      }
      return image2;
    }
    function printText(font, x, y, text2, defaultCharWidth) {
      for (var i = 0; i < text2.length; i++) {
        var _char2 = void 0;
        if (font.chars[text2[i]]) {
          _char2 = text2[i];
        } else if (/\s/.test(text2[i])) {
          _char2 = "";
        } else {
          _char2 = "?";
        }
        var fontChar = font.chars[_char2] || {};
        var fontKerning = font.kernings[_char2];
        drawCharacter(this, font, x, y, fontChar || {});
        var kerning = fontKerning && fontKerning[text2[i + 1]] ? fontKerning[text2[i + 1]] : 0;
        x += kerning + (fontChar.xadvance || defaultCharWidth);
      }
    }
    function splitLines(font, text2, maxWidth) {
      var words = text2.split(" ");
      var lines = [];
      var currentLine = [];
      var longestLine = 0;
      words.forEach(function(word) {
        var line = [].concat((0, _toConsumableArray2["default"])(currentLine), [word]).join(" ");
        var length = (0, _measureText.measureText)(font, line);
        if (length <= maxWidth) {
          if (length > longestLine) {
            longestLine = length;
          }
          currentLine.push(word);
        } else {
          lines.push(currentLine);
          currentLine = [word];
        }
      });
      lines.push(currentLine);
      return {
        lines,
        longestLine
      };
    }
    function loadPages(Jimp2, dir2, pages) {
      var newPages = pages.map(function(page2) {
        return Jimp2.read(dir2 + "/" + page2);
      });
      return Promise.all(newPages);
    }
    var dir = process.env.DIRNAME || "".concat(__dirname, "/../");
    var _default = function _default2() {
      return {
        constants: {
          measureText: _measureText.measureText,
          measureTextHeight: _measureText.measureTextHeight,
          FONT_SANS_8_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
          FONT_SANS_10_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
          FONT_SANS_12_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
          FONT_SANS_14_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
          FONT_SANS_16_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
          FONT_SANS_32_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
          FONT_SANS_64_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
          FONT_SANS_128_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
          FONT_SANS_8_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
          FONT_SANS_16_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
          FONT_SANS_32_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
          FONT_SANS_64_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
          FONT_SANS_128_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
          loadFont: function loadFont(file, cb) {
            var _this = this;
            if (typeof file !== "string")
              return _utils.throwError.call(this, "file must be a string", cb);
            return new Promise(function(resolve3, reject) {
              cb = cb || function(err, font) {
                if (err)
                  reject(err);
                else
                  resolve3(font);
              };
              (0, _loadBmfont["default"])(file, function(err, font) {
                var chars2 = {};
                var kernings = {};
                if (err) {
                  return _utils.throwError.call(_this, err, cb);
                }
                for (var i = 0; i < font.chars.length; i++) {
                  chars2[String.fromCharCode(font.chars[i].id)] = font.chars[i];
                }
                for (var _i = 0; _i < font.kernings.length; _i++) {
                  var firstString = String.fromCharCode(font.kernings[_i].first);
                  kernings[firstString] = kernings[firstString] || {};
                  kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
                }
                loadPages(_this, _path["default"].dirname(file), font.pages).then(function(pages) {
                  cb(null, {
                    chars: chars2,
                    kernings,
                    pages,
                    common: font.common,
                    info: font.info
                  });
                });
              });
            });
          }
        },
        "class": {
          print: function print(font, x, y, text2, maxWidth, maxHeight, cb) {
            var _this2 = this;
            if (typeof maxWidth === "function" && typeof cb === "undefined") {
              cb = maxWidth;
              maxWidth = Infinity;
            }
            if (typeof maxWidth === "undefined") {
              maxWidth = Infinity;
            }
            if (typeof maxHeight === "function" && typeof cb === "undefined") {
              cb = maxHeight;
              maxHeight = Infinity;
            }
            if (typeof maxHeight === "undefined") {
              maxHeight = Infinity;
            }
            if ((0, _typeof2["default"])(font) !== "object") {
              return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
            }
            if (typeof x !== "number" || typeof y !== "number" || typeof maxWidth !== "number") {
              return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
            }
            if (typeof maxWidth !== "number") {
              return _utils.throwError.call(this, "maxWidth must be a number", cb);
            }
            if (typeof maxHeight !== "number") {
              return _utils.throwError.call(this, "maxHeight must be a number", cb);
            }
            var alignmentX;
            var alignmentY;
            if ((0, _typeof2["default"])(text2) === "object" && text2.text !== null && text2.text !== void 0) {
              alignmentX = text2.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
              alignmentY = text2.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
              var _text = text2;
              text2 = _text.text;
            } else {
              alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
              alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
              text2 = text2.toString();
            }
            if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
              y += maxHeight - (0, _measureText.measureTextHeight)(font, text2, maxWidth);
            } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
              y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text2, maxWidth) / 2;
            }
            var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;
            var _splitLines = splitLines(font, text2, maxWidth), lines = _splitLines.lines, longestLine = _splitLines.longestLine;
            lines.forEach(function(line) {
              var lineString = line.join(" ");
              var alignmentWidth = xOffsetBasedOnAlignment(_this2.constructor, font, lineString, maxWidth, alignmentX);
              printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth);
              y += font.common.lineHeight;
            });
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this, {
                x: x + longestLine,
                y
              });
            }
            return this;
          }
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-resize/dist/modules/resize.js
var require_resize = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/modules/resize.js"(exports, module) {
    init_shims();
    "use strict";
    function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
      this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
      this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
      this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
      this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
      this.colorChannels = blendAlpha ? 4 : 3;
      this.interpolationPass = Boolean(interpolationPass);
      this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
      };
      this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
      this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
      this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
      this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
      this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
      this.initialize();
    }
    Resize.prototype.initialize = function() {
      if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
        this.configurePasses();
      } else {
        throw new Error("Invalid settings specified for the resizer.");
      }
    };
    Resize.prototype.configurePasses = function() {
      if (this.widthOriginal === this.targetWidth) {
        this.resizeWidth = this.bypassResizer;
      } else {
        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
          this.initializeFirstPassBuffers(true);
          this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
        } else {
          this.initializeFirstPassBuffers(false);
          this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
        }
      }
      if (this.heightOriginal === this.targetHeight) {
        this.resizeHeight = this.bypassResizer;
      } else {
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
          this.initializeSecondPassBuffers(true);
          this.resizeHeight = this.resizeHeightInterpolated;
        } else {
          this.initializeSecondPassBuffers(false);
          this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
      }
    };
    Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
      var channelsNum = fourthChannel ? 4 : 3;
      var ratioWeight = this.ratioWeightWidthPass;
      var outputBuffer = this.widthBuffer;
      var weight = 0;
      var finalOffset = 0;
      var pixelOffset = 0;
      var firstWeight = 0;
      var secondWeight = 0;
      var targetPosition;
      for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset] = buffer[pixelOffset];
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
      }
      weight -= 1 / 3;
      var interpolationWidthSourceReadStop;
      for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
        }
      }
      for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset] = buffer[pixelOffset];
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
      }
      return outputBuffer;
    };
    Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
      var channelsNum = fourthChannel ? 4 : 3;
      var ratioWeight = this.ratioWeightWidthPass;
      var ratioWeightDivisor = 1 / ratioWeight;
      var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
      var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
      var output = this.outputWidthWorkBench;
      var outputBuffer = this.widthBuffer;
      var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
      var weight = 0;
      var amountToNext = 0;
      var actualPosition = 0;
      var currentPosition = 0;
      var line = 0;
      var pixelOffset = 0;
      var outputOffset = 0;
      var multiplier = 1;
      var r = 0;
      var g = 0;
      var b = 0;
      var a = 0;
      do {
        for (line = 0; line < this.originalHeightMultipliedByChannels; ) {
          output[line++] = 0;
          output[line++] = 0;
          output[line++] = 0;
          if (fourthChannel) {
            output[line++] = 0;
            trustworthyColorsCount[line / channelsNum - 1] = 0;
          }
        }
        weight = ratioWeight;
        do {
          amountToNext = 1 + actualPosition - currentPosition;
          multiplier = Math.min(weight, amountToNext);
          for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
            r = buffer[pixelOffset];
            g = buffer[++pixelOffset];
            b = buffer[++pixelOffset];
            a = fourthChannel ? buffer[++pixelOffset] : 255;
            output[line++] += (a ? r : 0) * multiplier;
            output[line++] += (a ? g : 0) * multiplier;
            output[line++] += (a ? b : 0) * multiplier;
            if (fourthChannel) {
              output[line++] += a * multiplier;
              trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
            }
          }
          if (weight >= amountToNext) {
            actualPosition += channelsNum;
            currentPosition = actualPosition;
            weight -= amountToNext;
          } else {
            currentPosition += weight;
            break;
          }
        } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
          weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
          multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
          outputBuffer[pixelOffset] = output[line++] * multiplier;
          outputBuffer[++pixelOffset] = output[line++] * multiplier;
          outputBuffer[++pixelOffset] = output[line++] * multiplier;
          if (fourthChannel)
            outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += channelsNum;
      } while (outputOffset < this.targetWidthMultipliedByChannels);
      return outputBuffer;
    };
    Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
      var ratioWeight = this.ratioWeightHeightPass;
      var ratioWeightDivisor = 1 / ratioWeight;
      var output = this.outputHeightWorkBench;
      var outputBuffer = this.heightBuffer;
      var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
      var weight = 0;
      var amountToNext = 0;
      var actualPosition = 0;
      var currentPosition = 0;
      var pixelOffset = 0;
      var outputOffset = 0;
      var caret = 0;
      var multiplier = 1;
      var r = 0;
      var g = 0;
      var b = 0;
      var a = 0;
      do {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          output[pixelOffset++] = 0;
          output[pixelOffset++] = 0;
          output[pixelOffset++] = 0;
          if (fourthChannel) {
            output[pixelOffset++] = 0;
            trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
          }
        }
        weight = ratioWeight;
        do {
          amountToNext = 1 + actualPosition - currentPosition;
          multiplier = Math.min(weight, amountToNext);
          caret = actualPosition;
          for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
            r = buffer[caret++];
            g = buffer[caret++];
            b = buffer[caret++];
            a = fourthChannel ? buffer[caret++] : 255;
            output[pixelOffset++] += (a ? r : 0) * multiplier;
            output[pixelOffset++] += (a ? g : 0) * multiplier;
            output[pixelOffset++] += (a ? b : 0) * multiplier;
            if (fourthChannel) {
              output[pixelOffset++] += a * multiplier;
              trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
            }
          }
          if (weight >= amountToNext) {
            actualPosition = caret;
            currentPosition = actualPosition;
            weight -= amountToNext;
          } else {
            currentPosition += weight;
            break;
          }
        } while (weight > 0 && actualPosition < this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
          multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          if (fourthChannel) {
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
          }
        }
      } while (outputOffset < this.finalResultSize);
      return outputBuffer;
    };
    Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
      return this._resizeWidthInterpolatedRGBChannels(buffer, false);
    };
    Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
      return this._resizeWidthInterpolatedRGBChannels(buffer, true);
    };
    Resize.prototype.resizeWidthRGB = function(buffer) {
      return this._resizeWidthRGBChannels(buffer, false);
    };
    Resize.prototype.resizeWidthRGBA = function(buffer) {
      return this._resizeWidthRGBChannels(buffer, true);
    };
    Resize.prototype.resizeHeightInterpolated = function(buffer) {
      var ratioWeight = this.ratioWeightHeightPass;
      var outputBuffer = this.heightBuffer;
      var weight = 0;
      var finalOffset = 0;
      var pixelOffset = 0;
      var pixelOffsetAccumulated = 0;
      var pixelOffsetAccumulated2 = 0;
      var firstWeight = 0;
      var secondWeight = 0;
      var interpolationHeightSourceReadStop;
      for (; weight < 1 / 3; weight += ratioWeight) {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
        }
      }
      weight -= 1 / 3;
      for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
        pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
        }
      }
      while (finalOffset < this.finalResultSize) {
        for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
        }
      }
      return outputBuffer;
    };
    Resize.prototype.resizeHeightRGB = function(buffer) {
      return this._resizeHeightRGBChannels(buffer, false);
    };
    Resize.prototype.resizeHeightRGBA = function(buffer) {
      return this._resizeHeightRGBChannels(buffer, true);
    };
    Resize.prototype.resize = function(buffer) {
      this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
    };
    Resize.prototype.bypassResizer = function(buffer) {
      return buffer;
    };
    Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
      this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
      if (!BILINEARAlgo) {
        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
        if (this.colorChannels > 3) {
          this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
        }
      }
    };
    Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
      this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
      if (!BILINEARAlgo) {
        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
        if (this.colorChannels > 3) {
          this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
        }
      }
    };
    Resize.prototype.generateFloatBuffer = function(bufferLength) {
      try {
        return new Float32Array(bufferLength);
      } catch (error2) {
        return [];
      }
    };
    Resize.prototype.generateFloat64Buffer = function(bufferLength) {
      try {
        return new Float64Array(bufferLength);
      } catch (error2) {
        return [];
      }
    };
    Resize.prototype.generateUint8Buffer = function(bufferLength) {
      try {
        return new Uint8Array(bufferLength);
      } catch (error2) {
        return [];
      }
    };
    module.exports = Resize;
  }
});

// node_modules/@jimp/plugin-resize/dist/modules/resize2.js
var require_resize2 = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/modules/resize2.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      nearestNeighbor: function nearestNeighbor(src2, dst) {
        var wSrc = src2.width;
        var hSrc = src2.height;
        var wDst = dst.width;
        var hDst = dst.height;
        var bufSrc = src2.data;
        var bufDst = dst.data;
        for (var i = 0; i < hDst; i++) {
          for (var j = 0; j < wDst; j++) {
            var posDst = (i * wDst + j) * 4;
            var iSrc = Math.floor(i * hSrc / hDst);
            var jSrc = Math.floor(j * wSrc / wDst);
            var posSrc = (iSrc * wSrc + jSrc) * 4;
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
          }
        }
      },
      bilinearInterpolation: function bilinearInterpolation(src2, dst) {
        var wSrc = src2.width;
        var hSrc = src2.height;
        var wDst = dst.width;
        var hDst = dst.height;
        var bufSrc = src2.data;
        var bufDst = dst.data;
        var interpolate = function interpolate2(k, kMin, vMin, kMax, vMax) {
          if (kMin === kMax) {
            return vMin;
          }
          return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
        };
        var assign = function assign2(pos, offset, x2, xMin2, xMax2, y2, yMin2, yMax2) {
          var posMin = (yMin2 * wSrc + xMin2) * 4 + offset;
          var posMax = (yMin2 * wSrc + xMax2) * 4 + offset;
          var vMin = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
          if (yMax2 === yMin2) {
            bufDst[pos + offset] = vMin;
          } else {
            posMin = (yMax2 * wSrc + xMin2) * 4 + offset;
            posMax = (yMax2 * wSrc + xMax2) * 4 + offset;
            var vMax = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
            bufDst[pos + offset] = interpolate(y2, yMin2, vMin, yMax2, vMax);
          }
        };
        for (var i = 0; i < hDst; i++) {
          for (var j = 0; j < wDst; j++) {
            var posDst = (i * wDst + j) * 4;
            var x = j * wSrc / wDst;
            var xMin = Math.floor(x);
            var xMax = Math.min(Math.ceil(x), wSrc - 1);
            var y = i * hSrc / hDst;
            var yMin = Math.floor(y);
            var yMax = Math.min(Math.ceil(y), hSrc - 1);
            assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
          }
        }
      },
      _interpolate2D: function _interpolate2D(src2, dst, options2, interpolate) {
        var bufSrc = src2.data;
        var bufDst = dst.data;
        var wSrc = src2.width;
        var hSrc = src2.height;
        var wDst = dst.width;
        var hDst = dst.height;
        var wM = Math.max(1, Math.floor(wSrc / wDst));
        var wDst2 = wDst * wM;
        var hM = Math.max(1, Math.floor(hSrc / hDst));
        var hDst2 = hDst * hM;
        var buf1 = Buffer.alloc(wDst2 * hSrc * 4);
        for (var i = 0; i < hSrc; i++) {
          for (var j = 0; j < wDst2; j++) {
            var x = j * (wSrc - 1) / wDst2;
            var xPos = Math.floor(x);
            var t = x - xPos;
            var srcPos = (i * wSrc + xPos) * 4;
            var buf1Pos = (i * wDst2 + j) * 4;
            for (var k = 0; k < 4; k++) {
              var kPos = srcPos + k;
              var x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
              var x1 = bufSrc[kPos];
              var x2 = bufSrc[kPos + 4];
              var x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
              buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
            }
          }
        }
        var buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
        for (var _i = 0; _i < hDst2; _i++) {
          for (var _j = 0; _j < wDst2; _j++) {
            var y = _i * (hSrc - 1) / hDst2;
            var yPos = Math.floor(y);
            var _t = y - yPos;
            var _buf1Pos = (yPos * wDst2 + _j) * 4;
            var buf2Pos = (_i * wDst2 + _j) * 4;
            for (var _k = 0; _k < 4; _k++) {
              var _kPos = _buf1Pos + _k;
              var y0 = yPos > 0 ? buf1[_kPos - wDst2 * 4] : 2 * buf1[_kPos] - buf1[_kPos + wDst2 * 4];
              var y1 = buf1[_kPos];
              var y2 = buf1[_kPos + wDst2 * 4];
              var y3 = yPos < hSrc - 2 ? buf1[_kPos + wDst2 * 8] : 2 * buf1[_kPos + wDst2 * 4] - buf1[_kPos];
              buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
            }
          }
        }
        var m = wM * hM;
        if (m > 1) {
          for (var _i2 = 0; _i2 < hDst; _i2++) {
            for (var _j2 = 0; _j2 < wDst; _j2++) {
              var r = 0;
              var g = 0;
              var b = 0;
              var a = 0;
              var realColors = 0;
              for (var _y = 0; _y < hM; _y++) {
                var _yPos = _i2 * hM + _y;
                for (var _x = 0; _x < wM; _x++) {
                  var _xPos = _j2 * wM + _x;
                  var xyPos = (_yPos * wDst2 + _xPos) * 4;
                  var pixelAlpha = buf2[xyPos + 3];
                  if (pixelAlpha) {
                    r += buf2[xyPos];
                    g += buf2[xyPos + 1];
                    b += buf2[xyPos + 2];
                    realColors++;
                  }
                  a += pixelAlpha;
                }
              }
              var pos = (_i2 * wDst + _j2) * 4;
              bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
              bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
              bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
              bufDst[pos + 3] = Math.round(a / m);
            }
          }
        } else {
          dst.data = buf2;
        }
      },
      bicubicInterpolation: function bicubicInterpolation(src2, dst, options2) {
        var interpolateCubic = function interpolateCubic2(x0, x1, x2, x3, t) {
          var a0 = x3 - x2 - x0 + x1;
          var a1 = x0 - x1 - a0;
          var a2 = x2 - x0;
          var a3 = x1;
          return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
        };
        return this._interpolate2D(src2, dst, options2, interpolateCubic);
      },
      hermiteInterpolation: function hermiteInterpolation(src2, dst, options2) {
        var interpolateHermite = function interpolateHermite2(x0, x1, x2, x3, t) {
          var c0 = x1;
          var c1 = 0.5 * (x2 - x0);
          var c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
          var c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
          return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
        };
        return this._interpolate2D(src2, dst, options2, interpolateHermite);
      },
      bezierInterpolation: function bezierInterpolation(src2, dst, options2) {
        var interpolateBezier = function interpolateBezier2(x0, x1, x2, x3, t) {
          var cp1 = x1 + (x2 - x0) / 4;
          var cp2 = x2 - (x3 - x1) / 4;
          var nt = 1 - t;
          var c0 = x1 * nt * nt * nt;
          var c1 = 3 * cp1 * nt * nt * t;
          var c2 = 3 * cp2 * nt * t * t;
          var c3 = x2 * t * t * t;
          return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
        };
        return this._interpolate2D(src2, dst, options2, interpolateBezier);
      }
    };
  }
});

// node_modules/@jimp/plugin-resize/dist/index.js
var require_dist26 = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _resize = _interopRequireDefault(require_resize());
    var _resize2 = _interopRequireDefault(require_resize2());
    var _default = function _default2() {
      return {
        constants: {
          RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
          RESIZE_BILINEAR: "bilinearInterpolation",
          RESIZE_BICUBIC: "bicubicInterpolation",
          RESIZE_HERMITE: "hermiteInterpolation",
          RESIZE_BEZIER: "bezierInterpolation"
        },
        "class": {
          resize: function resize2(w, h, mode, cb) {
            if (typeof w !== "number" || typeof h !== "number") {
              return _utils.throwError.call(this, "w and h must be numbers", cb);
            }
            if (typeof mode === "function" && typeof cb === "undefined") {
              cb = mode;
              mode = null;
            }
            if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
              return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
            }
            if (w === this.constructor.AUTO) {
              w = this.bitmap.width * (h / this.bitmap.height);
            }
            if (h === this.constructor.AUTO) {
              h = this.bitmap.height * (w / this.bitmap.width);
            }
            if (w < 0 || h < 0) {
              return _utils.throwError.call(this, "w and h must be positive numbers", cb);
            }
            w = Math.round(w);
            h = Math.round(h);
            if (typeof _resize2["default"][mode] === "function") {
              var dst = {
                data: Buffer.alloc(w * h * 4),
                width: w,
                height: h
              };
              _resize2["default"][mode](this.bitmap, dst);
              this.bitmap = dst;
            } else {
              var image2 = this;
              var resize3 = new _resize["default"](this.bitmap.width, this.bitmap.height, w, h, true, true, function(buffer) {
                image2.bitmap.data = Buffer.from(buffer);
                image2.bitmap.width = w;
                image2.bitmap.height = h;
              });
              resize3.resize(this.bitmap.data);
            }
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-rotate/dist/index.js
var require_dist27 = __commonJS({
  "node_modules/@jimp/plugin-rotate/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    function advancedRotate(deg, mode) {
      deg %= 360;
      var rad = deg * Math.PI / 180;
      var cosine = Math.cos(rad);
      var sine = Math.sin(rad);
      var w = this.bitmap.width;
      var h = this.bitmap.height;
      if (mode === true || typeof mode === "string") {
        w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
        h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;
        if (w % 2 !== 0) {
          w++;
        }
        if (h % 2 !== 0) {
          h++;
        }
        var c = this.cloneQuiet();
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x2, y2, idx) {
          this.bitmap.data.writeUInt32BE(this._background, idx);
        });
        var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
        this.resize(max, max, mode);
        this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
      }
      var bW = this.bitmap.width;
      var bH = this.bitmap.height;
      var dstBuffer = Buffer.alloc(this.bitmap.data.length);
      function createTranslationFunction(deltaX, deltaY) {
        return function(x2, y2) {
          return {
            x: x2 + deltaX,
            y: y2 + deltaY
          };
        };
      }
      var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
      var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
      for (var y = 1; y <= bH; y++) {
        for (var x = 1; x <= bW; x++) {
          var cartesian = translate2Cartesian(x, y);
          var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
          var dstIdx = bW * (y - 1) + x - 1 << 2;
          if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
            var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
            var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
          } else {
            dstBuffer.writeUInt32BE(this._background, dstIdx);
          }
        }
      }
      this.bitmap.data = dstBuffer;
      if (mode === true || typeof mode === "string") {
        var _x = bW / 2 - w / 2;
        var _y = bH / 2 - h / 2;
        this.crop(_x, _y, w, h);
      }
    }
    var _default = function _default2() {
      return {
        rotate: function rotate(deg, mode, cb) {
          if (typeof mode === "undefined" || mode === null) {
            mode = true;
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = true;
          }
          if (typeof deg !== "number") {
            return _utils.throwError.call(this, "deg must be a number", cb);
          }
          if (typeof mode !== "boolean" && typeof mode !== "string") {
            return _utils.throwError.call(this, "mode must be a boolean or a string", cb);
          }
          advancedRotate.call(this, deg, mode, cb);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-scale/dist/index.js
var require_dist28 = __commonJS({
  "node_modules/@jimp/plugin-scale/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        scale: function scale(f, mode, cb) {
          if (typeof f !== "number") {
            return _utils.throwError.call(this, "f must be a number", cb);
          }
          if (f < 0) {
            return _utils.throwError.call(this, "f must be a positive number", cb);
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          var w = this.bitmap.width * f;
          var h = this.bitmap.height * f;
          this.resize(w, h, mode);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        scaleToFit: function scaleToFit(w, h, mode, cb) {
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers", cb);
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
          this.scale(f, mode);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-shadow/dist/index.js
var require_dist29 = __commonJS({
  "node_modules/@jimp/plugin-shadow/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        shadow: function shadow() {
          var _this = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var cb = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof options2 === "function") {
            cb = options2;
            options2 = {};
          }
          var _options = options2, _options$opacity = _options.opacity, opacity = _options$opacity === void 0 ? 0.7 : _options$opacity, _options$size = _options.size, size = _options$size === void 0 ? 1.1 : _options$size, _options$x = _options.x, x = _options$x === void 0 ? -25 : _options$x, _options$y = _options.y, y = _options$y === void 0 ? 25 : _options$y, _options$blur = _options.blur, blur = _options$blur === void 0 ? 5 : _options$blur;
          var orig = this.clone();
          var shadow2 = this.clone();
          shadow2.scan(0, 0, shadow2.bitmap.width, shadow2.bitmap.height, function(x2, y2, idx) {
            shadow2.bitmap.data[idx] = 0;
            shadow2.bitmap.data[idx + 1] = 0;
            shadow2.bitmap.data[idx + 2] = 0;
            shadow2.bitmap.data[idx + 3] = shadow2.constructor.limit255(shadow2.bitmap.data[idx + 3] * opacity);
            _this.bitmap.data[idx] = 0;
            _this.bitmap.data[idx + 1] = 0;
            _this.bitmap.data[idx + 2] = 0;
            _this.bitmap.data[idx + 3] = 0;
          });
          shadow2.resize(shadow2.bitmap.width * size, shadow2.bitmap.height * size).blur(blur);
          this.composite(shadow2, x, y);
          this.composite(orig, 0, 0);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugin-threshold/dist/index.js
var require_dist30 = __commonJS({
  "node_modules/@jimp/plugin-threshold/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _utils = require_dist();
    var _default = function _default2() {
      return {
        threshold: function threshold(_ref, cb) {
          var _this = this;
          var max = _ref.max, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? 255 : _ref$replace, _ref$autoGreyscale = _ref.autoGreyscale, autoGreyscale = _ref$autoGreyscale === void 0 ? true : _ref$autoGreyscale;
          if (typeof max !== "number") {
            return _utils.throwError.call(this, "max must be a number", cb);
          }
          if (typeof replace !== "number") {
            return _utils.throwError.call(this, "replace must be a number", cb);
          }
          if (typeof autoGreyscale !== "boolean") {
            return _utils.throwError.call(this, "autoGreyscale must be a boolean", cb);
          }
          max = this.constructor.limit255(max);
          replace = this.constructor.limit255(replace);
          if (autoGreyscale) {
            this.greyscale();
          }
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var grey = _this.bitmap.data[idx] < max ? _this.bitmap.data[idx] : replace;
            _this.bitmap.data[idx] = grey;
            _this.bitmap.data[idx + 1] = grey;
            _this.bitmap.data[idx + 2] = grey;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@jimp/plugins/dist/index.js
var require_dist31 = __commonJS({
  "node_modules/@jimp/plugins/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _timm = require_timm();
    var _pluginBlit = _interopRequireDefault(require_dist10());
    var _pluginBlur = _interopRequireDefault(require_dist11());
    var _pluginCircle = _interopRequireDefault(require_dist12());
    var _pluginColor = _interopRequireDefault(require_dist13());
    var _pluginContain = _interopRequireDefault(require_dist14());
    var _pluginCover = _interopRequireDefault(require_dist15());
    var _pluginCrop = _interopRequireDefault(require_dist16());
    var _pluginDisplace = _interopRequireDefault(require_dist17());
    var _pluginDither = _interopRequireDefault(require_dist18());
    var _pluginFisheye = _interopRequireDefault(require_dist19());
    var _pluginFlip = _interopRequireDefault(require_dist20());
    var _pluginGaussian = _interopRequireDefault(require_dist21());
    var _pluginInvert = _interopRequireDefault(require_dist22());
    var _pluginMask = _interopRequireDefault(require_dist23());
    var _pluginNormalize = _interopRequireDefault(require_dist24());
    var _pluginPrint = _interopRequireDefault(require_dist25());
    var _pluginResize = _interopRequireDefault(require_dist26());
    var _pluginRotate = _interopRequireDefault(require_dist27());
    var _pluginScale = _interopRequireDefault(require_dist28());
    var _pluginShadow = _interopRequireDefault(require_dist29());
    var _pluginThreshold = _interopRequireDefault(require_dist30());
    var plugins = [_pluginBlit["default"], _pluginBlur["default"], _pluginCircle["default"], _pluginColor["default"], _pluginContain["default"], _pluginCover["default"], _pluginCrop["default"], _pluginDisplace["default"], _pluginDither["default"], _pluginFisheye["default"], _pluginFlip["default"], _pluginGaussian["default"], _pluginInvert["default"], _pluginMask["default"], _pluginNormalize["default"], _pluginPrint["default"], _pluginResize["default"], _pluginRotate["default"], _pluginScale["default"], _pluginShadow["default"], _pluginThreshold["default"]];
    var _default = function _default2(jimpEvChange) {
      var initializedPlugins = plugins.map(function(pluginModule) {
        var plugin = pluginModule(jimpEvChange) || {};
        if (!plugin["class"] && !plugin.constants) {
          plugin = {
            "class": plugin
          };
        }
        return plugin;
      });
      return _timm.mergeDeep.apply(void 0, (0, _toConsumableArray2["default"])(initializedPlugins));
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/jimp/dist/index.js
var require_dist32 = __commonJS({
  "node_modules/jimp/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _custom = _interopRequireDefault(require_dist3());
    var _types = _interopRequireDefault(require_dist9());
    var _plugins = _interopRequireDefault(require_dist31());
    var _default = (0, _custom["default"])({
      types: [_types["default"]],
      plugins: [_plugins["default"]]
    });
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// .svelte-kit/node/middlewares.js
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
var import_jimp = __toModule(require_dist32());
import { google } from "googleapis";
import { ADB } from "appium-adb";
import { config } from "dotenv";
import fs from "fs";
import path from "path";
import startCase from "lodash.startcase";
import { Temporal } from "@js-temporal/polyfill";
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _map;
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error$1(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler) {
    return;
  }
  const params = route.params(match);
  const response = await handler(__spreadProps(__spreadValues({}, request), { params }));
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error$1(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error$1(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = __spreadProps(__spreadValues({}, headers), { "content-type": "application/json; charset=utf-8" });
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop$1() {
}
function safe_not_equal$1(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue$1 = [];
function writable$1(value, start = noop$1) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal$1(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue$1.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue$1.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue$1.length; i += 2) {
            subscriber_queue$1[i][0](subscriber_queue$1[i + 1]);
          }
          subscriber_queue$1.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page: page2
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable$1($session);
    const props = {
      stores: {
        page: writable$1(null),
        navigating: writable$1(null),
        session
      },
      page: page2,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2 && page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page2 && page2.path)},
						query: new URLSearchParams(${page2 ? s$1(page2.query.toString()) : ""}),
						params: ${page2 && s$1(page2.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name, message, stack }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node,
  $session,
  context,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page2, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page2.host}/${asset.file}`, opts);
        } else if (resolved.startsWith("/") && !resolved.startsWith("//")) {
          const relative = resolved;
          const headers = __spreadValues({}, opts.headers);
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = __spreadProps(__spreadValues({}, opts.headers), {
                cookie: request.headers.cookie
              });
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text2() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape$1(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text2;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text2());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: __spreadValues({}, context)
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
var escaped$2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape$1(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$2) {
      result += escaped$2[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path2) {
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path2);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path2.slice(path_match[0].length).split("/") : path2.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function coalesce_to_error(err) {
  return err instanceof Error ? err : new Error(JSON.stringify(err));
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    context: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      context: loaded ? loaded.context : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page: page2
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let context = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              node,
              context,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            }));
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error2 = e;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    node: error_node,
                    context: node_loaded.context,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.context) {
          context = __spreadValues(__spreadValues({}, context), loaded.loaded.context);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page: page2
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  constructor(map) {
    __privateAdd(this, _map, void 0);
    __privateSet(this, _map, map);
  }
  get(key) {
    const value = __privateGet(this, _map).get(key);
    return value && value[0];
  }
  getAll(key) {
    return __privateGet(this, _map).get(key);
  }
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of __privateGet(this, _map))
      yield key;
  }
  *values() {
    for (const [, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
_map = new WeakMap();
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text2 = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text2();
    case "application/json":
      return JSON.parse(text2());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text2());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text2(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text2) {
  const { data, append } = read_only_form_data();
  text2.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text2, boundary) {
  const parts = text2.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path2 = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path2 + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = __spreadProps(__spreadValues({}, incoming), {
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  });
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(request2.path);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                const etag = `"${hash(response.body || "")}"`;
                if (request2.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function noop() {
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
Promise.resolve();
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name) => {
    if (invalid_attribute_name_character.test(name))
      return;
    const value = attributes[name];
    if (value === true)
      str += " " + name;
    else if (boolean_attributes.has(name.toLowerCase())) {
      if (value)
        str += " " + name;
    } else if (value != null) {
      str += ` ${name}="${value}"`;
    }
  });
  return str;
}
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape(value) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function add_classes(classes) {
  return classes ? ` class="${classes}"` : "";
}
function afterUpdate() {
}
var css$3 = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\texport let props_3 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}>\\n\\t\\t\\t\\t\\t{#if components[3]}\\n\\t\\t\\t\\t\\t\\t<svelte:component this={components[3]} {...(props_3 || {})}/>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t</svelte:component>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AA2DC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  let { props_3 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  if ($$props.props_3 === void 0 && $$bindings.props_3 && props_3 !== void 0)
    $$bindings.props_3(props_3);
  $$result.css.add(css$3);
  {
    stores.page.set(page2);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {
        default: () => `${components[3] ? `${validate_component(components[3] || missing_component, "svelte:component").$$render($$result, Object.assign(props_3 || {}), {}, {})}` : ``}`
      })}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
var base = "";
var assets = "";
function set_paths(paths2) {
  base = paths2.base;
  assets = paths2.assets || base;
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" type="image/png" href="/logo.png" sizes="192x192" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		<link rel="stylesheet" href="/css/base.css" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
var default_settings = { paths: { "base": "", "assets": "" } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-a84f37a6.js",
      css: [assets + "/_app/assets/start-61d1577b.css"],
      js: [assets + "/_app/start-a84f37a6.js", assets + "/_app/chunks/vendor-c77ecffb.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "css/base.css", "size": 293, "type": "text/css" }, { "file": "img/daphne.jpg", "size": 21205, "type": "image/jpeg" }, { "file": "img/tiger.jpg", "size": 17240, "type": "image/jpeg" }, { "file": "logo.png", "size": 7581, "type": "image/png" }, { "file": "manifest.webmanifest", "size": 380, "type": "application/manifest+json" }, { "file": "preset/info.json", "size": 255, "type": "application/json" }, { "file": "preset/tea.json", "size": 539, "type": "application/json" }],
  layout: ".svelte-kit/build/components/layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/oauth2callback\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return oauth2callback;
      })
    },
    {
      type: "page",
      pattern: /^\/remote\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/remote/__layout.svelte", "src/routes/remote/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/remote\/custom\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/remote/__layout.svelte", "src/routes/remote/custom.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/remote\/image\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/remote/__layout.svelte", "src/routes/remote/image.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/remote\/edit\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/remote/__layout.svelte", "src/routes/remote/edit.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/page\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/page/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/page\/busy\/([^/]+?)\/?$/,
      params: (m) => ({ person: d(m[1]) }),
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/page/busy/[person].svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/page\/text\/?$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/page/text.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/api\/cellwall-version\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return cellwallVersion;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/third_party\/freebusy\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return freebusy;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/action\/refresh\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return refresh;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/action\/image\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$6;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/action\/image\/([^/]+?)\/?$/,
      params: (m) => ({ serial: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _serial_$3;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$5;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/power\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$4;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/power\/([^/]+?)\/?$/,
      params: (m) => ({ serial: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _serial_$2;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/state\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$3;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/state\/preset\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return preset;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/state\/([^/]+?)\/?$/,
      params: (m) => ({ serial: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _serial_$1;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/device\/([^/]+?)\/?$/,
      params: (m) => ({ serial: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _serial_;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve22 }) => resolve22(request)),
  handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
  externalFetch: hooks.externalFetch || fetch
});
var module_lookup = {
  ".svelte-kit/build/components/layout.svelte": () => Promise.resolve().then(function() {
    return layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/remote/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/remote/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/remote/custom.svelte": () => Promise.resolve().then(function() {
    return custom;
  }),
  "src/routes/remote/image.svelte": () => Promise.resolve().then(function() {
    return image;
  }),
  "src/routes/remote/edit.svelte": () => Promise.resolve().then(function() {
    return edit;
  }),
  "src/routes/page/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/page/busy/[person].svelte": () => Promise.resolve().then(function() {
    return _person_;
  }),
  "src/routes/page/text.svelte": () => Promise.resolve().then(function() {
    return text;
  })
};
var metadata_lookup = { ".svelte-kit/build/components/layout.svelte": { "entry": "layout.svelte-eacce105.js", "css": [], "js": ["layout.svelte-eacce105.js", "chunks/vendor-c77ecffb.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-6cda78b1.js", "css": [], "js": ["error.svelte-6cda78b1.js", "chunks/vendor-c77ecffb.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-7923e694.js", "css": [], "js": ["pages/index.svelte-7923e694.js", "chunks/vendor-c77ecffb.js"], "styles": [] }, "src/routes/remote/__layout.svelte": { "entry": "pages/remote/__layout.svelte-bded134e.js", "css": [], "js": ["pages/remote/__layout.svelte-bded134e.js", "chunks/vendor-c77ecffb.js"], "styles": [] }, "src/routes/remote/index.svelte": { "entry": "pages/remote/index.svelte-fede2d47.js", "css": ["assets/pages/remote/index.svelte-3d98ee13.css"], "js": ["pages/remote/index.svelte-fede2d47.js", "chunks/vendor-c77ecffb.js", "chunks/Form-b849c358.js", "chunks/_form-52443b97.js"], "styles": [] }, "src/routes/remote/custom.svelte": { "entry": "pages/remote/custom.svelte-27596e26.js", "css": [], "js": ["pages/remote/custom.svelte-27596e26.js", "chunks/vendor-c77ecffb.js", "chunks/_DeviceOption-fe3247c8.js", "chunks/state-33679332.js", "chunks/Form-b849c358.js", "chunks/_PowerButton-306e4904.js", "chunks/_form-52443b97.js"], "styles": [] }, "src/routes/remote/image.svelte": { "entry": "pages/remote/image.svelte-d79bf0eb.js", "css": [], "js": ["pages/remote/image.svelte-d79bf0eb.js", "chunks/vendor-c77ecffb.js", "chunks/_DeviceOption-fe3247c8.js", "chunks/Form-b849c358.js"], "styles": [] }, "src/routes/remote/edit.svelte": { "entry": "pages/remote/edit.svelte-b1375422.js", "css": [], "js": ["pages/remote/edit.svelte-b1375422.js", "chunks/vendor-c77ecffb.js", "chunks/_DeviceOption-fe3247c8.js", "chunks/Form-b849c358.js", "chunks/_PowerButton-306e4904.js", "chunks/_form-52443b97.js"], "styles": [] }, "src/routes/page/index.svelte": { "entry": "pages/page/index.svelte-dfd4d6d1.js", "css": [], "js": ["pages/page/index.svelte-dfd4d6d1.js", "chunks/vendor-c77ecffb.js", "chunks/state-33679332.js"], "styles": [] }, "src/routes/page/busy/[person].svelte": { "entry": "pages/page/busy/[person].svelte-0a2d01f7.js", "css": ["assets/pages/page/busy/[person].svelte-eab96ff7.css"], "js": ["pages/page/busy/[person].svelte-0a2d01f7.js", "chunks/vendor-c77ecffb.js"], "styles": [] }, "src/routes/page/text.svelte": { "entry": "pages/page/text.svelte-e67ba09c.js", "css": ["assets/pages/page/text.svelte-690dba16.css"], "js": ["pages/page/text.svelte-e67ba09c.js", "chunks/vendor-c77ecffb.js"], "styles": [] } };
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender: prerender2
} = {}) {
  const host = request.headers["host"];
  return respond(__spreadProps(__spreadValues({}, request), { host }), options, { prerender: prerender2 });
}
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
var POWER_BUTTON = 26;
async function checkIfOn(adb, cmdOutput = void 0) {
  var _a;
  const stdout = cmdOutput || await adb.shell(["dumpsys", "power"]);
  const wakefulness = (_a = /mWakefulness=(\w+)/.exec(stdout)) == null ? void 0 : _a[1];
  return wakefulness === "Awake";
}
async function togglePower(adb) {
  await adb.keyevent(POWER_BUTTON);
}
async function startIntent(adb, options2) {
  const { waitForLaunch = true, flags = [], extras = {} } = options2;
  const args = ["am", "start"];
  if (waitForLaunch) {
    args.push("-W");
  }
  if (options2.action) {
    args.push("-a", options2.action);
  }
  if (options2.dataUri) {
    args.push("-d", options2.dataUri);
  }
  if (options2.mimeType) {
    args.push("-t", options2.mimeType);
  }
  if (options2.category) {
    args.push("-c", options2.category);
  }
  if (options2.component) {
    args.push("-n", options2.component);
  }
  for (const flag of flags) {
    args.push("-f", flag);
  }
  for (const [key, extra] of Object.entries(extras)) {
    switch (typeof extra) {
      case "string":
        args.push("--es", key, extra);
        break;
      case "boolean":
        args.push("--ez", key, extra.toString());
        break;
      case "number":
        if (Number.isInteger(extra)) {
          args.push("--ei", key, extra.toString());
        } else {
          args.push("--ef", key, extra.toString());
        }
        break;
      case "object":
      case "undefined":
        if (extra == void 0) {
          args.push("--esn", key);
        } else if (Array.isArray(extra)) {
          const joined = extra.join(",");
          const flag = extra.every((n) => Number.isInteger(n)) ? "--eia" : "--efa";
          args.push(flag, key, joined);
        }
        break;
    }
  }
  let res;
  try {
    res = await adb.shell(args);
  } catch (err) {
    throw new Error(`Error attempting to start intent. Original error: ${err}`);
  }
  if (res.toLowerCase().includes("unable to resolve intent")) {
    throw new Error(res);
  }
}
var DeviceManager = class {
  constructor() {
    this._devices = writable(new Map());
    this.devices.subscribe((map) => {
      this._lastMap = map;
    });
  }
  get devices() {
    return this._devices;
  }
  async refreshDevices() {
    const adbGlobal = await ADB.createADB();
    const devices = await adbGlobal.getConnectedDevices();
    const clients = await Promise.all(devices.map(async (device) => {
      const adb = await ADB.createADB();
      adb.setDevice(device);
      return [device.udid, adb];
    }));
    const result = new Map(clients);
    this._devices.set(result);
    return result;
  }
  async checkIfOn(serial) {
    const adb = this._lastMap.get(serial);
    if (!adb)
      return false;
    return checkIfOn(adb);
  }
  async togglePower(serial) {
    const adb = this._lastMap.get(serial);
    if (!adb)
      return false;
    await togglePower(adb);
    return true;
  }
  async startIntent(serial, options2) {
    const adb = this._lastMap.get(serial);
    if (!adb)
      return false;
    await startIntent(adb, options2);
    return true;
  }
};
function asPower(primitive) {
  switch (primitive) {
    case "toggle":
    case true:
    case false:
      return primitive;
    case "true":
    case "false":
      return Boolean(primitive);
    default:
      return void 0;
  }
}
async function setPowerOne(client, on) {
  const isOn = await checkIfOn(client);
  if (isOn !== on) {
    await togglePower(client);
    return !isOn;
  }
  return on;
}
async function setPower(device, on) {
  if (device instanceof Map) {
    const devices = device;
    let allOn;
    if (on === "toggle") {
      const powerStates = await Promise.all(Array.from(devices.values()).map(async (client) => ({
        on: await checkIfOn(client),
        client
      })));
      const numOn = powerStates.filter((state) => state.on).length;
      const numOff = powerStates.length - numOn;
      allOn = numOn < numOff;
    } else {
      allOn = on;
    }
    await Promise.all(Array.from(devices.values()).map((client) => setPowerOne(client, allOn)));
    return allOn;
  } else {
    return await setPowerOne(device);
  }
}
var CellManager = class {
  constructor() {
    this._info = writable(new Map());
    this._state = writable(new Map());
  }
  get info() {
    return this._info;
  }
  get state() {
    return this._state;
  }
  async loadInfo(db) {
    try {
      const cells = await db.getCells();
      this._info.update((map) => {
        const newMap = new Map(map);
        for (const cell of cells) {
          newMap.set(cell.serial, cell);
        }
        return newMap;
      });
    } catch (err) {
      console.error("Could not load CellManager data", err);
    }
    return this;
  }
  async writeInfo(db) {
    await db.insertCells(Array.from(get_store_value(this.info).values()));
  }
  register(serial, info) {
    this._info.update((map) => new Map(map).set(serial, info));
  }
  setState(serial, state) {
    this._state.update((map) => new Map(map).set(serial, state));
  }
  setStateMap(states2) {
    const entries = typeof states2.entries === "function" ? states2.entries() : Object.entries(states2);
    this._state.update((map) => new Map([...map, ...entries]));
  }
};
function buildCellState(options2) {
  const { type, properties = {}, required = [] } = options2;
  return {
    type: "object",
    properties: __spreadValues({
      type: {
        type: "string",
        enum: [type]
      }
    }, properties),
    required: ["type", ...required]
  };
}
var cellStateBlankSchema = buildCellState({ type: "BLANK" });
var cellStateWebSchema = buildCellState({
  type: "WEB",
  properties: {
    url: { type: "string", format: "uri" }
  },
  required: ["url"]
});
var cellStateTextSchema = buildCellState({
  type: "TEXT",
  properties: {
    text: { type: "string" },
    backgroundColor: { type: "string" }
  },
  required: ["text"]
});
var cellStateImageSchema = buildCellState({
  type: "IMAGE",
  properties: {
    src: { type: "string", format: "uri" },
    scaleType: {
      type: "string",
      enum: ["FIT_CENTER", "FIT_XY", "CENTER_INSIDE"]
    }
  },
  required: ["src"]
});
var allCellStateSchemas = [
  cellStateBlankSchema,
  cellStateImageSchema,
  cellStateTextSchema,
  cellStateWebSchema
];
function getTypeFromSchema(schema) {
  return schema.properties.type.enum[0];
}
var CellStateType;
(function(CellStateType2) {
  CellStateType2["BLANK"] = "BLANK";
  CellStateType2["CONFIGURE"] = "CONFIGURE";
  CellStateType2["TEXT"] = "TEXT";
  CellStateType2["IMAGE"] = "IMAGE";
  CellStateType2["BUTTON"] = "BUTTON";
  CellStateType2["WEB"] = "WEB";
})(CellStateType || (CellStateType = {}));
function blankState() {
  return { type: CellStateType.BLANK };
}
function toUri(state, base2) {
  const _a = state, { type } = _a, props = __objRest(_a, ["type"]);
  switch (type.toUpperCase()) {
    case CellStateType.WEB: {
      const web = props;
      return new URL(web.url, base2).toString();
    }
    case CellStateType.IMAGE: {
      const imgProps = props;
      imgProps.src = new URL(imgProps.src, base2).toString();
    }
    default: {
      const url = new URL(`cellwall://${type}`);
      for (const [key, value] of Object.entries(props)) {
        url.searchParams.append(key, value);
      }
      return url.toString();
    }
  }
}
config();
var VERSION = "4.0.0";
var SERVER_ADDRESS = process.env["SERVER_ADDRESS"];
var PACKAGE_NAME = "com.tigeroakes.cellwall.client";
var GOOGLE_CLIENT_ID = process.env["GOOGLE_CLIENT_ID"];
var GOOGLE_CLIENT_SECRET = process.env["GOOGLE_CLIENT_SECRET"];
var DATABASE_FILENAME = process.env["DATABASE_FILENAME"];
function initializeGoogle(credentials, googleClientId, googleClientServer) {
  const client = new google.auth.OAuth2(googleClientId, googleClientServer, "https://cellwall.tigeroakes.com/oauth2callback");
  if (credentials) {
    console.log("Loading Google authentication from storage");
    client.setCredentials(credentials);
    return { client };
  }
  const authorizeUrl = client.generateAuthUrl({
    access_type: "offline",
    scope: ["https://www.googleapis.com/auth/calendar.readonly"]
  });
  return { client, authorizeUrl };
}
async function authenticateGoogle(client, code) {
  const res = await client.getToken(code);
  client.setCredentials(res.tokens);
  return res.tokens;
}
function transformMap(map, transform) {
  return new Map(Array.from(map.entries(), ([key, value]) => {
    return [key, transform(value, key)];
  }));
}
function filterMap(map, predicate) {
  return new Map(Array.from(map.entries()).filter(([key, value]) => predicate(value, key)));
}
async function transformMapAsync(map, transform) {
  return new Map(await Promise.all(Array.from(map.entries(), async ([key, value]) => {
    return [key, await transform(value, key)];
  })));
}
var AXIS_TO_POS = new Map().set("width", "x").set("height", "y");
function cellCanvas(cells) {
  const canvas = { x: Infinity, y: Infinity, width: 0, height: 0 };
  for (const info of cells) {
    for (const [axis, pos] of AXIS_TO_POS) {
      const value = info[pos] + info[axis];
      if (!Number.isNaN(value)) {
        canvas[pos] = Math.min(canvas[pos], info[pos]);
        canvas[axis] = Math.max(canvas[axis], info[pos] + info[axis]);
      }
    }
  }
  canvas.width = canvas.width - canvas.x;
  canvas.height = canvas.height - canvas.y;
  return canvas;
}
function shiftCell(canvas, cell) {
  const copy = __spreadValues({}, cell);
  copy.x = cell.x - canvas.x;
  copy.y = cell.y - canvas.y;
  return copy;
}
var ALIGN_QUERY = {
  left: import_jimp.default.HORIZONTAL_ALIGN_LEFT,
  right: import_jimp.default.HORIZONTAL_ALIGN_RIGHT,
  center: import_jimp.default.HORIZONTAL_ALIGN_CENTER,
  top: import_jimp.default.VERTICAL_ALIGN_TOP,
  bottom: import_jimp.default.VERTICAL_ALIGN_BOTTOM,
  middle: import_jimp.default.VERTICAL_ALIGN_MIDDLE
};
var RESIZE = new Set([
  import_jimp.default.RESIZE_NEAREST_NEIGHBOR,
  import_jimp.default.RESIZE_BILINEAR,
  import_jimp.default.RESIZE_BICUBIC,
  import_jimp.default.RESIZE_HERMITE,
  import_jimp.default.RESIZE_BEZIER
]);
function has(set, item) {
  return set.has(item);
}
function parseResizeOptions(query = {}) {
  const horizontalFlag = ALIGN_QUERY[query.horizontalAlign] || 0;
  const verticalFlag = ALIGN_QUERY[query.verticalAlign] || 0;
  const resize2 = has(RESIZE, query.resize) ? query.resize : void 0;
  return {
    alignBits: horizontalFlag | verticalFlag,
    resizeMode: resize2
  };
}
function resize(image2, { width, height }, query = {}) {
  const { alignBits, resizeMode } = parseResizeOptions(query);
  return new Promise((resolve22, reject) => image2.cover(width, height, alignBits, resizeMode, (err, value) => {
    if (err)
      reject(err);
    else
      resolve22(value);
  }));
}
function crop(image2, cell) {
  return new Promise((resolve22, reject) => image2.crop(cell.x, cell.y, cell.width, cell.height, (err, value) => {
    if (err)
      reject(err);
    else
      resolve22(value);
  }));
}
async function splitImage(image2, cells, options2 = {}) {
  const canvas = cellCanvas(cells.values());
  await resize(image2, canvas, options2);
  return await transformMapAsync(cells, async (info) => {
    const copy = await import_jimp.default.create(image2);
    const shifted = shiftCell(canvas, info);
    return {
      info: shifted,
      img: await crop(copy, shifted)
    };
  });
}
var SplitImageCache = class {
  constructor() {
    this.cache = new Map();
  }
  get(serial) {
    return this.cache.get(serial);
  }
  clear() {
    this.cache.clear();
  }
  async insert(image2, rects, options2) {
    const cropped = await splitImage(image2, rects, options2);
    this.clear();
    return transformMap(cropped, ({ info, img }, serial) => {
      this.cache.set(serial, img);
      return info;
    });
  }
};
function asArray(items) {
  return Array.isArray(items) ? items : [items];
}
function getAll(map, keys) {
  const result = new Map();
  for (const key of keys) {
    const value = map.get(key);
    if (value !== void 0) {
      result.set(key, value);
    }
  }
  return result;
}
function subscribeToMapStore(store, subscription) {
  let oldMap;
  return store.subscribe((newMap) => {
    subscription(newMap, oldMap);
    oldMap = newMap;
  });
}
function memo(func) {
  let result;
  return function memoized(...args) {
    if (result === void 0) {
      result = func.apply(this, args);
    }
    return result;
  };
}
var __classPrivateFieldSet$3 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Writer_instances;
var _Writer_filename;
var _Writer_tempFilename;
var _Writer_locked;
var _Writer_prev;
var _Writer_next;
var _Writer_nextPromise;
var _Writer_nextData;
var _Writer_add;
var _Writer_write;
function getTempFilename(file) {
  return path.join(path.dirname(file), "." + path.basename(file) + ".tmp");
}
var Writer = class {
  constructor(filename) {
    _Writer_instances.add(this);
    _Writer_filename.set(this, void 0);
    _Writer_tempFilename.set(this, void 0);
    _Writer_locked.set(this, false);
    _Writer_prev.set(this, null);
    _Writer_next.set(this, null);
    _Writer_nextPromise.set(this, null);
    _Writer_nextData.set(this, null);
    __classPrivateFieldSet$3(this, _Writer_filename, filename, "f");
    __classPrivateFieldSet$3(this, _Writer_tempFilename, getTempFilename(filename), "f");
  }
  async write(data) {
    return __classPrivateFieldGet$3(this, _Writer_locked, "f") ? __classPrivateFieldGet$3(this, _Writer_instances, "m", _Writer_add).call(this, data) : __classPrivateFieldGet$3(this, _Writer_instances, "m", _Writer_write).call(this, data);
  }
};
_Writer_filename = new WeakMap(), _Writer_tempFilename = new WeakMap(), _Writer_locked = new WeakMap(), _Writer_prev = new WeakMap(), _Writer_next = new WeakMap(), _Writer_nextPromise = new WeakMap(), _Writer_nextData = new WeakMap(), _Writer_instances = new WeakSet(), _Writer_add = function _Writer_add2(data) {
  __classPrivateFieldSet$3(this, _Writer_nextData, data, "f");
  __classPrivateFieldSet$3(this, _Writer_nextPromise, __classPrivateFieldGet$3(this, _Writer_nextPromise, "f") || new Promise((resolve22, reject) => {
    __classPrivateFieldSet$3(this, _Writer_next, [resolve22, reject], "f");
  }), "f");
  return new Promise((resolve22, reject) => {
    var _a;
    (_a = __classPrivateFieldGet$3(this, _Writer_nextPromise, "f")) === null || _a === void 0 ? void 0 : _a.then(resolve22).catch(reject);
  });
}, _Writer_write = async function _Writer_write2(data) {
  var _a, _b;
  __classPrivateFieldSet$3(this, _Writer_locked, true, "f");
  try {
    await fs.promises.writeFile(__classPrivateFieldGet$3(this, _Writer_tempFilename, "f"), data, "utf-8");
    await fs.promises.rename(__classPrivateFieldGet$3(this, _Writer_tempFilename, "f"), __classPrivateFieldGet$3(this, _Writer_filename, "f"));
    (_a = __classPrivateFieldGet$3(this, _Writer_prev, "f")) === null || _a === void 0 ? void 0 : _a[0]();
  } catch (err) {
    (_b = __classPrivateFieldGet$3(this, _Writer_prev, "f")) === null || _b === void 0 ? void 0 : _b[1](err);
    throw err;
  } finally {
    __classPrivateFieldSet$3(this, _Writer_locked, false, "f");
    __classPrivateFieldSet$3(this, _Writer_prev, __classPrivateFieldGet$3(this, _Writer_next, "f"), "f");
    __classPrivateFieldSet$3(this, _Writer_next, __classPrivateFieldSet$3(this, _Writer_nextPromise, null, "f"), "f");
    if (__classPrivateFieldGet$3(this, _Writer_nextData, "f") !== null) {
      const nextData = __classPrivateFieldGet$3(this, _Writer_nextData, "f");
      __classPrivateFieldSet$3(this, _Writer_nextData, null, "f");
      await this.write(nextData);
    }
  }
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TextFile_filename;
var _TextFile_writer;
var TextFile = class {
  constructor(filename) {
    _TextFile_filename.set(this, void 0);
    _TextFile_writer.set(this, void 0);
    __classPrivateFieldSet$2(this, _TextFile_filename, filename, "f");
    __classPrivateFieldSet$2(this, _TextFile_writer, new Writer(filename), "f");
  }
  async read() {
    let data;
    try {
      data = await fs.promises.readFile(__classPrivateFieldGet$2(this, _TextFile_filename, "f"), "utf-8");
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return data;
  }
  write(str) {
    return __classPrivateFieldGet$2(this, _TextFile_writer, "f").write(str);
  }
};
_TextFile_filename = new WeakMap(), _TextFile_writer = new WeakMap();
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JSONFile_adapter;
var JSONFile = class {
  constructor(filename) {
    _JSONFile_adapter.set(this, void 0);
    __classPrivateFieldSet$1(this, _JSONFile_adapter, new TextFile(filename), "f");
  }
  async read() {
    const data = await __classPrivateFieldGet$1(this, _JSONFile_adapter, "f").read();
    if (data === null) {
      return null;
    } else {
      return JSON.parse(data);
    }
  }
  write(obj) {
    return __classPrivateFieldGet$1(this, _JSONFile_adapter, "f").write(JSON.stringify(obj, null, 2));
  }
};
_JSONFile_adapter = new WeakMap();
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _Memory_data;
var Memory = class {
  constructor() {
    _Memory_data.set(this, null);
  }
  read() {
    return Promise.resolve(__classPrivateFieldGet(this, _Memory_data, "f"));
  }
  write(obj) {
    __classPrivateFieldSet(this, _Memory_data, obj, "f");
    return Promise.resolve();
  }
};
_Memory_data = new WeakMap();
var MissingAdapterError = class extends Error {
  constructor() {
    super();
    this.message = "Missing Adapter";
  }
};
var Low = class {
  constructor(adapter) {
    Object.defineProperty(this, "adapter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    if (adapter) {
      this.adapter = adapter;
    } else {
      throw new MissingAdapterError();
    }
  }
  async read() {
    this.data = await this.adapter.read();
  }
  async write() {
    if (this.data) {
      await this.adapter.write(this.data);
    }
  }
};
async function database(filename) {
  const adapter = filename ? new JSONFile(filename) : new Memory();
  const db = new Low(adapter);
  await db.read();
  function initData() {
    return db.data || (db.data = { cells: {} });
  }
  return {
    async getGoogleCredentials() {
      var _a;
      return (_a = db.data) == null ? void 0 : _a.googleCredentials;
    },
    async setGoogleCredentials(credentials) {
      initData().googleCredentials = credentials;
      await db.write();
    },
    async getCell(name) {
      var _a, _b;
      return (_b = (_a = db.data) == null ? void 0 : _a.cells) == null ? void 0 : _b[name];
    },
    async getCells() {
      return Object.values(initData().cells);
    },
    async insertCell(cell) {
      initData().cells[cell.serial] = cell;
      await db.write();
    },
    async insertCells(cells) {
      const data = initData();
      for (const cell of cells) {
        data.cells[cell.serial] = cell;
      }
      await db.write();
    }
  };
}
function sendIntentOnStateChange(cellManager, deviceManager) {
  subscribeToMapStore(cellManager.state, (newStates, oldStates) => {
    const changes = new Map(newStates);
    if (oldStates) {
      for (const [serial, state] of oldStates) {
        if (changes.get(serial) === state) {
          changes.delete(serial);
        }
      }
    }
    const info = get_store_value(cellManager.info);
    Promise.all(Array.from(changes).map(([serial, state]) => {
      var _a;
      console.log(serial, state);
      const base2 = ((_a = info.get(serial)) == null ? void 0 : _a.server) || SERVER_ADDRESS;
      return deviceManager.startIntent(serial, {
        action: `${PACKAGE_NAME}.DISPLAY`,
        dataUri: toUri(state, base2).replace(/&/g, "\\&").replace(/'/g, "%27")
      });
    }));
  });
}
function deriveCellInfo(cellManager, deviceManager) {
  return derived([cellManager.info, cellManager.state, deviceManager.devices], ([infoMap, states2, devices]) => {
    const cellInfoMap = new Map();
    for (const [serial, info] of infoMap) {
      cellInfoMap.set(serial, { serial, info, connected: false });
    }
    for (const [serial, state] of states2) {
      const existing = cellInfoMap.get(serial);
      if (existing) {
        existing.state = state;
      } else {
        cellInfoMap.set(serial, { serial, state, connected: false });
      }
    }
    for (const serial of devices.keys()) {
      const existing = cellInfoMap.get(serial);
      if (existing) {
        existing.connected = true;
      } else {
        cellInfoMap.set(serial, { serial, connected: true });
      }
    }
    return cellInfoMap;
  }, new Map());
}
function repository() {
  const dbPromise = database(DATABASE_FILENAME);
  const deviceManager = new DeviceManager();
  let deviceManagerPromise = deviceManager.refreshDevices().then(() => deviceManager);
  const cellManager = new CellManager();
  const cellManagerPromise = dbPromise.then((db) => cellManager.loadInfo(db));
  sendIntentOnStateChange(cellManager, deviceManager);
  const cellData = deriveCellInfo(cellManager, deviceManager);
  const googleApi = memo(async function googleApi2() {
    if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {
      throw new Error(`Missing Google API keys`);
    }
    const db = await dbPromise;
    const credentials = await db.getGoogleCredentials();
    const googleClient = initializeGoogle(credentials, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET);
    if (googleClient.authorizeUrl) {
      console.log(`
---
Authenticate with Google:
${googleClient.authorizeUrl}
---
`);
    }
    return googleClient;
  });
  return {
    cellData,
    cellDataJson: derived(cellData, (map) => JSON.stringify(Object.fromEntries(map))),
    images: new SplitImageCache(),
    refreshDevices() {
      const refreshPromise = deviceManager.refreshDevices();
      deviceManagerPromise = refreshPromise.then(() => deviceManager);
      return refreshPromise;
    },
    googleApi,
    async authenticateGoogleApi(code) {
      const db = await dbPromise;
      const googleClient = await googleApi();
      const credentials = await authenticateGoogle(googleClient.client, code);
      await db.setGoogleCredentials(credentials);
    },
    async getPower(serial) {
      const deviceManager2 = await deviceManagerPromise;
      return deviceManager2.checkIfOn(serial);
    },
    async setPower(serial, on) {
      const deviceManager2 = await deviceManagerPromise;
      const devices = get_store_value(deviceManager2.devices);
      const serialList = asArray(serial);
      return setPower(getAll(devices, serialList), on);
    },
    async setState(serial, state) {
      const cellManager2 = await cellManagerPromise;
      cellManager2.setState(serial, state);
    },
    async setStates(states2) {
      const cellManager2 = await cellManagerPromise;
      cellManager2.setStateMap(states2);
    },
    async registerCell(info) {
      const cellManager2 = await cellManagerPromise;
      cellManager2.register(info.serial, info);
      const db = await dbPromise;
      await cellManager2.writeInfo(db);
    }
  };
}
var repo = repository();
globalThis._repo = repo;
var get$8 = async function get2({ query }) {
  const code = query.get("code");
  if (!code) {
    return {
      status: 400,
      error: new Error("Missing code")
    };
  }
  await repo.authenticateGoogleApi(code);
  return {
    body: "Authentication successful! Please return to the console."
  };
};
var oauth2callback = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$8
});
var get$7 = async function get22() {
  return {
    body: { version: VERSION }
  };
};
var cellwallVersion = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$7
});
function bodyType({ headers, body }) {
  const [type] = (headers["content-type"] || "").split(/;\s*/);
  switch (type) {
    case "text/plain":
      if (typeof body === "string") {
        return { type: "text", body };
      } else {
        throw new Error(`Content-Type ${type} does not match ${typeof body} body`);
      }
    case "application/json":
      return { type: "json", body };
    case "application/x-www-form-urlencoded":
    case "multipart/form-data":
      if (typeof body === "string" || body === null || body instanceof Uint8Array) {
        throw new Error(`Content-Type ${type} does not match ${typeof body} body`);
      } else {
        return { type: "form", body };
      }
    default:
      if (body === null) {
        return { type: "null", body };
      } else if (body instanceof Uint8Array) {
        return { type: "raw", body };
      } else {
        throw new Error(`Content-Type ${type} does not match ${typeof body} body`);
      }
  }
}
function isObject(maybe) {
  return typeof maybe === "object" && maybe !== null;
}
function bodyAsJson(input) {
  const body = bodyType(input);
  switch (body.type) {
    case "json":
      return body.body;
    case "text":
      return JSON.parse(body.body);
    case "form":
      return Object.fromEntries(body.body.entries());
    default:
      return void 0;
  }
}
var post$9 = async function post2(input) {
  const { client } = await repo.googleApi();
  const requestBody = bodyAsJson(input);
  if (!requestBody) {
    return {
      status: 400,
      error: `Request body should be JSON`
    };
  }
  const api = google.calendar({ version: "v3", auth: client });
  const res = await api.freebusy.query({
    requestBody
  });
  if (res.status < 200 || res.status >= 300) {
    return {
      status: res.status,
      error: new Error(`Could not load calendar, ${res.statusText}`)
    };
  }
  const { errors, busy } = Object.values(res.data.calendars)[0];
  if (errors && errors.length > 0) {
    return {
      status: 500,
      error: new Error(errors.map((error2) => error2.reason).join())
    };
  }
  return {
    status: res.status,
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(busy)
  };
};
var freebusy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$9
});
var post$8 = async function post22() {
  const devices = await repo.refreshDevices();
  return {
    body: Array.from(devices.keys())
  };
};
var refresh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$8
});
function isNumber(number) {
  return typeof number === "number" && !Number.isNaN(number);
}
function validRect(rect = {}) {
  return isNumber(rect.x) && isNumber(rect.y) && isNumber(rect.width) && isNumber(rect.height);
}
async function updateRemainingCells(remaining, behaviour) {
  switch (behaviour) {
    case "blank":
      await repo.setStates(new Map(remaining.map((serial) => [serial, { type: CellStateType.BLANK }])));
      break;
    case "off":
      await repo.setPower(remaining, false);
      break;
  }
}
var post$7 = async function post23(input) {
  const image2 = await import_jimp.default.create(Buffer.from(input.body));
  const devices = new Set(input.query.getAll("device"));
  const includes = devices.size > 0 ? devices.has.bind(devices) : () => true;
  const cellData = get_store_value(repo.cellData);
  const cells = filterMap(cellData, (cell) => validRect(cell.info) && includes(cell.serial));
  const rects = transformMap(cells, (cell) => cell.info);
  const options2 = {
    horizontalAlign: input.query.get("horizontalAlign"),
    verticalAlign: input.query.get("verticalAlign"),
    resize: input.query.get("resize")
  };
  repo.images.clear();
  await repo.images.insert(image2, rects, options2);
  repo.setStates(transformMap(rects, (_, serial) => ({
    type: CellStateType.IMAGE,
    src: `/api/action/image/${serial}`
  })));
  if (input.query.has("rest")) {
    const remaining = Array.from(cellData.keys()).filter((serial) => !rects.has(serial));
    const rest = input.query.get("rest");
    await updateRemainingCells(remaining, rest != null ? rest : "ignore");
  }
  return {
    body: Array.from(rects.keys())
  };
};
var del = async function del2() {
  repo.images.clear();
  return {
    status: 201
  };
};
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$7,
  del
});
var get$6 = async function get23(input) {
  const { serial } = input.params;
  const cached = repo.images.get(serial);
  if (!cached) {
    return {
      status: 404
    };
  }
  const mime = cached.getMIME();
  const buffer = await cached.getBufferAsync(mime);
  return {
    headers: {
      "Content-Type": mime
    },
    body: buffer
  };
};
var _serial_$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$6
});
var get$5 = async function get24() {
  return {
    body: JSON.stringify(Object.fromEntries(get_store_value(repo.cellData)))
  };
};
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$5
});
function isRawBody(maybeRaw) {
  return maybeRaw === null || maybeRaw instanceof Uint8Array;
}
function asCellState(maybeState) {
  if (isObject(maybeState)) {
    const state = maybeState;
    if (state.type in CellStateType) {
      return state;
    }
  }
  return void 0;
}
function parsePowerBody(body) {
  if (typeof body === "string") {
    const json = JSON.parse(body);
    if (typeof json === "boolean" || typeof json === "string") {
      return asPower(json);
    } else if (typeof json === "object" && json !== null) {
      const { on } = json;
      return asPower(on);
    }
  } else if (!isRawBody(body)) {
    return asPower(body.get("on"));
  }
  return void 0;
}
var get$4 = async function get25() {
  return {
    body: {
      devices: Object.entries(await transformMapAsync(get_store_value(repo.cellData), (_data, serial) => repo.getPower(serial)))
    }
  };
};
var post$6 = async function post24({ body }) {
  const power = parsePowerBody(body);
  if (power === void 0) {
    return {
      status: 400,
      error: new Error(`Invalid body ${body}`)
    };
  }
  const serials = Array.from(get_store_value(repo.cellData).keys());
  return {
    body: await repo.setPower(serials, power)
  };
};
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$4,
  post: post$6
});
var get$3 = async function get26({ params }) {
  const { serial } = params;
  return {
    body: {
      devices: {
        [serial]: await repo.getPower(serial)
      }
    }
  };
};
var post$5 = async function post25({ params, body }) {
  const { serial } = params;
  const power = parsePowerBody(body);
  if (power === void 0) {
    return {
      status: 400,
      error: new Error(`Invalid body ${body}`)
    };
  }
  return {
    body: await repo.setPower(serial, power)
  };
};
var _serial_$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$3,
  post: post$5
});
var get$2 = async function get27() {
  return {
    body: Object.entries(transformMap(get_store_value(repo.cellData), (data) => {
      var _a;
      return (_a = data.state) != null ? _a : blankState();
    }))
  };
};
var post$4 = async function post26({ body }) {
  if (typeof body !== "string") {
    return {
      status: 400,
      error: new Error(`Invalid body ${body}`)
    };
  }
  const states2 = JSON.parse(body);
  await repo.setStates(states2);
  return {
    body: Object.keys(states2)
  };
};
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$2,
  post: post$4
});
var post$3 = async function post27({
  host,
  body
}) {
  const preset2 = body.get("preset");
  const presetResponse = await fetch(`http://${host}${assets}/preset/${preset2}.json`);
  const presetStates = await presetResponse.json();
  await repo.setStates(presetStates);
  return {
    body: presetStates
  };
};
var preset = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$3
});
var get$1 = async function get28({ params }) {
  var _a, _b;
  const { serial } = params;
  return {
    body: JSON.stringify({
      [serial]: (_b = (_a = get_store_value(repo.cellData).get(serial)) == null ? void 0 : _a.state) != null ? _b : blankState()
    })
  };
};
var post$2 = async function post28(input) {
  const { serial } = input.params;
  const state = asCellState(bodyAsJson(input));
  if (!state) {
    return {
      status: 400,
      error: new Error(`Invalid body ${input.body}`)
    };
  }
  await repo.setState(serial, state);
  return {
    body: [serial]
  };
};
var _serial_$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1,
  post: post$2
});
var get = async function get29({ params }) {
  var _a;
  const { serial } = params;
  return {
    body: JSON.stringify((_a = get_store_value(repo.cellData).get(serial)) != null ? _a : null)
  };
};
var post$1 = async function post29(input) {
  const { serial } = input.params;
  const info = bodyAsJson(input);
  if (!info) {
    return {
      status: 400,
      error: new Error(`Invalid body ${input.body}`)
    };
  }
  info.serial = serial;
  info.server || (info.server = `http://${input.host}`);
  await repo.registerCell(info);
  return {
    body: [serial]
  };
};
var _serial_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get,
  post: post$1
});
var Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${slots.default ? slots.default({}) : ``}`;
});
var layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout
});
function load$5({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error2 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
});
var error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$5
});
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve22) {
      resolve22(value);
    });
  }
  return new (P || (P = Promise))(function(resolve22, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var load$4 = () => __awaiter$1(void 0, void 0, void 0, function* () {
  return { status: 301, redirect: "/remote/" };
});
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `Authentication successful! Please return to the console.`;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load: load$4
});
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let open = false;
  return `${$$result.head += `${$$result.title = `<title>CellWall Remote</title>`, ""}<link rel="${"stylesheet"}" href="${"https://jenil.github.io/bulmaswatch/darkly/bulmaswatch.min.css"}" data-svelte="svelte-1nhegv1"><link rel="${"manifest"}" href="${"/manifest.webmanifest"}" data-svelte="svelte-1nhegv1">`, ""}

<nav class="${"navbar"}" role="${"navigation"}" aria-label="${"main navigation"}"><div class="${"navbar-brand"}"><a class="${"navbar-item"}" href="${"https://github.com/NotWoods/cell-wall"}"><img src="${"/logo.png"}" alt="${""}" width="${"28"}" height="${"28"}">
			<span style="${"margin-left: 0.5rem"}">CellWall Remote</span></a>

		
		<a role="${"button"}" class="${["navbar-burger burger", ""].join(" ").trim()}" aria-label="${"menu"}"${add_attribute("aria-expanded", open, 0)} data-target="${"navMenu"}"><span aria-hidden="${"true"}"></span>
			<span aria-hidden="${"true"}"></span>
			<span aria-hidden="${"true"}"></span></a></div>

	<div id="${"navMenu"}" class="${["navbar-menu", ""].join(" ").trim()}"><div class="${"navbar-start"}"><a class="${"navbar-item"}" href="${"/remote/"}">Preset </a>
			<a class="${"navbar-item"}" href="${"/remote/image"}">Image </a>
			<a class="${"navbar-item"}" href="${"/remote/custom"}">Custom </a></div>
		<div class="${"navbar-end"}"><a class="${"navbar-item"}" href="${"/remote/edit"}">Edit </a></div></div></nav>

<main class="${"section"}"><div class="${"container"}">${slots.default ? slots.default({}) : ``}</div></main>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
var Form = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { action } = $$props;
  let { onSubmit } = $$props;
  let form;
  let loading = Promise.resolve();
  if ($$props.action === void 0 && $$bindings.action && action !== void 0)
    $$bindings.action(action);
  if ($$props.onSubmit === void 0 && $$bindings.onSubmit && onSubmit !== void 0)
    $$bindings.onSubmit(onSubmit);
  return `<form method="${"post"}"${add_attribute("action", action, 0)}${add_attribute("this", form, 0)}>${slots.default ? slots.default({ loading }) : ``}</form>`;
});
async function post(action, body) {
  try {
    const res = await fetch(action, {
      method: "post",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      throw new Error(res.statusText);
    }
    return res;
  } catch (err) {
    console.error(err);
    throw err;
  }
}
function formDataAsSearchParams(formData) {
  const params = new URLSearchParams();
  for (const [key, value] of formData) {
    if (typeof value === "string") {
      params.append(key, value);
    }
  }
  return params;
}
var css$2 = {
  code: "article.svelte-dvwrrs{display:flex;flex-direction:column}.buttons.svelte-dvwrrs{margin-top:auto}",
  map: '{"version":3,"file":"_PresetCard.svelte","sources":["_PresetCard.svelte"],"sourcesContent":["<script lang=\\"ts\\">export let title;\\nexport let preset;\\n<\/script>\\n\\n<article class=\\"tile is-child box\\">\\n\\t<p class=\\"title\\">{title}</p>\\n\\t<p class=\\"subtitle\\">\\n\\t\\t<slot />\\n\\t</p>\\n\\t<div class=\\"buttons is-right\\">\\n\\t\\t<button type=\\"submit\\" name=\\"preset\\" value={preset} class=\\"button is-outlined\\">Activate</button>\\n\\t</div>\\n</article>\\n\\n<style>\\n\\tarticle {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t}\\n\\n\\t.buttons {\\n\\t\\tmargin-top: auto;\\n\\t}\\n</style>\\n"],"names":[],"mappings":"AAeC,OAAO,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACvB,CAAC,AAED,QAAQ,cAAC,CAAC,AACT,UAAU,CAAE,IAAI,AACjB,CAAC"}'
};
var PresetCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { title } = $$props;
  let { preset: preset2 } = $$props;
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.preset === void 0 && $$bindings.preset && preset2 !== void 0)
    $$bindings.preset(preset2);
  $$result.css.add(css$2);
  return `<article class="${"tile is-child box svelte-dvwrrs"}"><p class="${"title"}">${escape(title)}</p>
	<p class="${"subtitle"}">${slots.default ? slots.default({}) : ``}</p>
	<div class="${"buttons is-right svelte-dvwrrs"}"><button type="${"submit"}" name="${"preset"}"${add_attribute("value", preset2, 0)} class="${"button is-outlined"}">Activate</button></div>
</article>`;
});
var prerender$1 = true;
var Remote = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve22) {
        resolve22(value);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function submit(data, action) {
    return __awaiter2(this, void 0, void 0, function* () {
      const res = yield fetch(action.toString(), {
        method: "post",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formDataAsSearchParams(data)
      });
      console.log(yield res.json());
    });
  }
  return `${validate_component(Form, "Form").$$render($$result, {
    action: "/api/device/state/preset",
    onSubmit: submit
  }, {}, {
    default: ({ loading }) => `${function(__value) {
      if (is_promise(__value))
        return `
		<progress class="${"progress is-small is-primary"}" max="${"100"}">Loading</progress>
	`;
      return function(res) {
        return `
		<progress class="${"progress is-small is-primary"}"${add_attribute("value", res != void 0 ? "100" : "0", 0)} max="${"100"}">Done</progress>
	`;
      }(__value);
    }(loading)}

	<div class="${"tile is-ancestor"}"><div class="${"tile is-parent is-vertical"}">${validate_component(PresetCard, "PresetCard").$$render($$result, { title: "Info", preset: "info" }, {}, {
      default: () => `Calendar indicators and the week&#39;s weather.`
    })}
			${validate_component(PresetCard, "PresetCard").$$render($$result, { title: "Tea list", preset: "tea" }, {}, {
      default: () => `What&#39;s avaliable to drink?`
    })}</div>
		<div class="${"tile is-parent"}"><article class="${"tile is-child notification"}"><figure class="${"image"}"><img alt="${""}" src="${"https://raw.githubusercontent.com/NotWoods/cell-wall/main/images/finished.jpg"}"></figure>
				<div class="${"field"}"><label class="${"label"}" for="${"control-rest"}">Remaining cells</label>
					<div class="${"control"}"><div class="${"select"}"><select id="${"control-rest"}" name="${"rest"}"><option value="${"ignore"}">Ignore</option><option value="${"blank"}">Blank</option><option value="${"off"}">Off</option></select></div></div></div></article></div></div>`
  })}`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Remote,
  prerender: prerender$1
});
function createLoadWithDevices() {
  return async ({ fetch: fetch2 }) => {
    const res = await fetch2(`/api/device`);
    if (res.ok) {
      return {
        props: {
          devices: Object.values(await res.json())
        }
      };
    } else {
      return {
        status: res.status,
        error: new Error(`Could not load devices, ${res.statusText}`)
      };
    }
  };
}
var SubmitButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { loading } = $$props;
  if ($$props.loading === void 0 && $$bindings.loading && loading !== void 0)
    $$bindings.loading(loading);
  return `<p class="${"control"}">${function(__value) {
    if (is_promise(__value))
      return `
		<button type="${"submit"}" class="${"button is-primary is-loading"}">Loading</button>
	`;
    return function(_) {
      return `
		<button type="${"submit"}" class="${"button is-primary"}">Submit</button>
	`;
    }();
  }(loading)}</p>`;
});
var Field = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { label } = $$props;
  let { htmlFor = void 0 } = $$props;
  let { narrow = false } = $$props;
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  if ($$props.htmlFor === void 0 && $$bindings.htmlFor && htmlFor !== void 0)
    $$bindings.htmlFor(htmlFor);
  if ($$props.narrow === void 0 && $$bindings.narrow && narrow !== void 0)
    $$bindings.narrow(narrow);
  return `<div class="${"field is-horizontal"}"><div class="${"field-label is-normal"}"><label class="${"label"}"${add_attribute("for", htmlFor, 0)}>${escape(label)}</label></div>
	<div class="${"field-body"}"><div class="${["field", narrow ? "is-narrow" : ""].join(" ").trim()}"><div class="${"control"}">${slots.default ? slots.default({}) : ``}</div></div></div></div>`;
});
function getInputType(name, property) {
  if (Array.isArray(property.enum))
    return "select";
  if (name.endsWith("Color"))
    return "color";
  if (property.format === "uri")
    return "url";
  switch (property.type) {
    case "number":
      return "number";
    default:
      return "text";
  }
}
var ControllerFields = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let required;
  let properties;
  function getInputName(name) {
    switch (name) {
      case "url":
        return "URL";
      case "src":
        return "Source";
      default:
        return startCase(name);
    }
  }
  let { schema } = $$props;
  if ($$props.schema === void 0 && $$bindings.schema && schema !== void 0)
    $$bindings.schema(schema);
  required = new Set((schema === null || schema === void 0 ? void 0 : schema.required) || []);
  properties = Object.entries((schema === null || schema === void 0 ? void 0 : schema.properties) || {}).filter(([name]) => name !== "type").map(([name, property]) => ({
    name,
    property,
    type: getInputType(name, property)
  }));
  return `${each(properties, ({ name, type, property }) => `${validate_component(Field, "Field").$$render($$result, {
    htmlFor: "control-" + name,
    label: getInputName(name),
    narrow: type === "color"
  }, {}, {
    default: () => `${Array.isArray(property.enum) ? `<div class="${"select"}"><select id="${"control-" + escape(name)}"${add_attribute("name", name, 0)}>${each(property.enum, (option) => `<option${add_attribute("value", option, 0)}>${escape(option)}</option>`)}</select>
			</div>` : `<input id="${"control-" + escape(name)}" class="${"input"}"${add_attribute("name", name, 0)}${add_attribute("type", type, 0)} ${required.has(name) ? "required" : ""}>`}
	`
  })}`)}`;
});
var PowerButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  (function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve22) {
        resolve22(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let { serial } = $$props;
  let { value } = $$props;
  const props = {
    type: "button",
    name: "on",
    value: value.toString()
  };
  let loading = Promise.resolve();
  if ($$props.serial === void 0 && $$bindings.serial && serial !== void 0)
    $$bindings.serial(serial);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  return `${function(__value) {
    if (is_promise(__value))
      return `
	<button${spread([
        escape_object(props),
        { type: "submit" },
        {
          formaction: "/api/device/power/$" + escape(serial)
        },
        { class: "button is-loading" }
      ])}>${slots.default ? slots.default({}) : ``}</button>
`;
    return function(_) {
      return `
	<button${spread([
        escape_object(props),
        { type: "submit" },
        {
          formaction: "/api/device/power/$" + escape(serial)
        },
        { class: "button" }
      ])}>${slots.default ? slots.default({}) : ``}</button>
`;
    }();
  }(loading)}`;
});
var TypeTab = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let type;
  let typeName;
  createEventDispatcher();
  let { selected } = $$props;
  let { schema } = $$props;
  if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
    $$bindings.selected(selected);
  if ($$props.schema === void 0 && $$bindings.schema && schema !== void 0)
    $$bindings.schema(schema);
  type = getTypeFromSchema(schema);
  typeName = startCase(type.toLocaleLowerCase());
  return `<li${add_classes([type === selected ? "is-active" : ""].join(" ").trim())}>
	<a${add_attribute("data-type", type, 0)}>${escape(typeName)}</a></li>`;
});
var DeviceOption = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a;
  let { device } = $$props;
  if ($$props.device === void 0 && $$bindings.device && device !== void 0)
    $$bindings.device(device);
  return `<option${add_attribute("value", device.serial, 0)} ${!device.connected ? "disabled" : ""}>${escape(((_a = device.info) == null ? void 0 : _a.deviceName) || device.serial)}</option>`;
});
var load$3 = createLoadWithDevices();
var Custom = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let activeSchema;
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve22) {
        resolve22(value);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { devices } = $$props;
  let selectedType = "BLANK";
  let selectedDevice = "";
  function submit(formData, action) {
    return __awaiter2(this, void 0, void 0, function* () {
      const data = Object.fromEntries(formData);
      yield post(action.toString(), Object.assign(Object.assign({}, data), { type: selectedType }));
    });
  }
  if ($$props.devices === void 0 && $$bindings.devices && devices !== void 0)
    $$bindings.devices(devices);
  activeSchema = allCellStateSchemas.find((schema) => getTypeFromSchema(schema) === selectedType);
  return `<nav class="${"tabs is-centered"}"><ul>${each(allCellStateSchemas, (schema) => `${validate_component(TypeTab, "TypeTab").$$render($$result, { selected: selectedType, schema }, {}, {})}`)}</ul></nav>

${validate_component(Form, "Form").$$render($$result, {
    action: "/api/device/state/" + selectedDevice,
    onSubmit: submit
  }, {}, {
    default: ({ loading }) => `${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-serial",
      label: "Device"
    }, {}, {
      default: () => `<div class="${"select"}"><select id="${"control-serial"}"><option value="${""}">All devices</option>${each(devices, (device) => `${validate_component(DeviceOption, "DeviceOption").$$render($$result, { device }, {}, {})}`)}</select></div>`
    })}

	<div class="${"field is-horizontal"}"><div class="${"field-label is-normal"}"><span class="${"label"}">Power</span></div>
		<div class="${"field-body"}"><div class="${"buttons has-addons"}">${validate_component(PowerButton, "PowerButton").$$render($$result, { serial: selectedDevice, value: false }, {}, { default: () => `Off` })}
				${validate_component(PowerButton, "PowerButton").$$render($$result, { serial: selectedDevice, value: true }, {}, { default: () => `On` })}</div></div></div>

	${validate_component(ControllerFields, "ControllerFields").$$render($$result, { schema: activeSchema }, {}, {})}

	<div class="${"field is-grouped is-grouped-right"}" style="${"margin-top: 3rem"}"><p class="${"control"}"><button type="${"reset"}" class="${"button is-light"}">Reset</button></p>
		${validate_component(SubmitButton, "SubmitButton").$$render($$result, { loading }, {}, {})}</div>`
  })}`;
});
var custom = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Custom,
  load: load$3
});
var load$2 = createLoadWithDevices();
var Image = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve22) {
        resolve22(value);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { devices } = $$props;
  let fileName = "";
  function submit(data, action) {
    return __awaiter2(this, void 0, void 0, function* () {
      const image2 = data.get("image");
      data.delete("image");
      for (const [key, value] of data) {
        action.searchParams.append(key, value);
      }
      try {
        const res = yield fetch(action.toString(), {
          method: "post",
          headers: { "content-type": image2.type },
          body: image2
        });
        if (!res.ok) {
          throw new Error(res.statusText);
        }
      } catch (err) {
        console.error(err);
        throw err;
      }
    });
  }
  if ($$props.devices === void 0 && $$bindings.devices && devices !== void 0)
    $$bindings.devices(devices);
  return `${validate_component(Form, "Form").$$render($$result, {
    action: "/api/action/image",
    onSubmit: submit
  }, {}, {
    default: ({ loading }) => `${validate_component(Field, "Field").$$render($$result, { htmlFor: "control-image", label: "Image" }, {}, {
      default: () => `<div class="${"file has-name"}"><label class="${"file-label"}"><input class="${"file-input"}" type="${"file"}" required accept="${"image/*"}" name="${"image"}">
				<span class="${"file-cta"}"><span class="${"file-icon"}"><svg width="${"24"}" height="${"24"}" viewBox="${"4 3 18 17"}" style="${"fill: currentColor"}"><path d="${"M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z"}"></path></svg></span>
					<span class="${"file-label"}">Choose a file\u2026 </span></span>
				<span class="${"file-name"}">${escape(fileName)}</span></label></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-serial",
      label: "Devices"
    }, {}, {
      default: () => `<div class="${"select is-multiple"}"><select multiple name="${"device"}" id="${"control-serial"}">${each(devices, (device) => `${validate_component(DeviceOption, "DeviceOption").$$render($$result, { device }, {}, {})}`)}</select></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-hozalign",
      label: "Horizontal Alignment"
    }, {}, {
      default: () => `<div class="${"select"}"><select id="${"control-hozalign"}" name="${"horizontalAlign"}"><option value="${"center"}">Center</option><option value="${"left"}">Left</option><option value="${"right"}">Right</option></select></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-veralign",
      label: "Vertical Alignment"
    }, {}, {
      default: () => `<div class="${"select"}"><select id="${"control-veralign"}" name="${"verticalAlign"}"><option value="${"middle"}">Middle</option><option value="${"top"}">Top</option><option value="${"bottom"}">Bottom</option></select></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-resize",
      label: "Resize Mode"
    }, {}, {
      default: () => `<div class="${"select"}"><select id="${"control-resize"}" name="${"resize"}"><option value="${"bilinearInterpolation"}">Bilinear</option><option value="${"bicubicInterpolation"}">Bicubic</option><option value="${"hermiteInterpolation"}">Hermite</option><option value="${"bezierInterpolation"}">Bezier</option><option value="${"nearestNeighbor"}">Nearest Neighbor</option></select></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-rest",
      label: "Remaining Cells"
    }, {}, {
      default: () => `<div class="${"select"}"><select id="${"control-rest"}" name="${"rest"}"><option value="${"ignore"}">Ignore</option><option value="${"blank"}">Blank</option><option value="${"off"}">Off</option></select></div>`
    })}

	<div class="${"field is-grouped is-grouped-right"}" style="${"margin-top: 3rem"}"><p class="${"control"}"><button type="${"reset"}" class="${"button is-light"}">Reset</button></p>
		${validate_component(SubmitButton, "SubmitButton").$$render($$result, { loading }, {}, {})}</div>`
  })}`;
});
var image = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Image,
  load: load$2
});
var load$1 = createLoadWithDevices();
var Edit = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let selectedCell;
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve22) {
        resolve22(value);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  let { devices } = $$props;
  let selectedDeviceSerial = (_a = devices[0]) === null || _a === void 0 ? void 0 : _a.serial;
  function submit(formData, action) {
    return __awaiter2(this, void 0, void 0, function* () {
      const res = yield fetch(action.toString(), {
        method: "post",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formDataAsSearchParams(formData)
      });
      console.log(yield res.json());
    });
  }
  if ($$props.devices === void 0 && $$bindings.devices && devices !== void 0)
    $$bindings.devices(devices);
  selectedCell = devices.find((cell) => cell.serial === selectedDeviceSerial);
  return `${validate_component(Form, "Form").$$render($$result, {
    action: "/api/device/" + selectedDeviceSerial,
    onSubmit: submit
  }, {}, {
    default: ({ loading }) => `${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-serial",
      label: "Device"
    }, {}, {
      default: () => `<div class="${"select"}"><select name="${"serial"}" id="${"control-serial"}">${each(devices, (device) => `${validate_component(DeviceOption, "DeviceOption").$$render($$result, { device }, {}, {})}`)}</select></div>`
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-connected",
      label: "Connected"
    }, {}, {
      default: () => {
        var _a2;
        return `<input type="${"checkbox"}" id="${"control-connected"}" name="${"connected"}" disabled ${((_a2 = selectedCell == null ? void 0 : selectedCell.connected) != null ? _a2 : false) ? "checked" : ""}>`;
      }
    })}

	<div class="${"field is-horizontal"}"><div class="${"field-label is-normal"}"><span class="${"label"}">Power</span></div>
		<div class="${"field-body"}"><div class="${"buttons has-addons"}">${validate_component(PowerButton, "PowerButton").$$render($$result, {
      serial: selectedDeviceSerial,
      value: false
    }, {}, { default: () => `Off` })}
				${validate_component(PowerButton, "PowerButton").$$render($$result, {
      serial: selectedDeviceSerial,
      value: true
    }, {}, { default: () => `On` })}</div></div></div>

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-deviceName",
      label: "Device Name"
    }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-deviceName"}" class="${"input"}" name="${"deviceName"}" type="${"text"}"${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.deviceName) != null ? _b : "", 0)}>`;
      }
    })}

	${validate_component(Field, "Field").$$render($$result, { htmlFor: "control-width", label: "Width" }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-width"}" class="${"input"}" name="${"width"}" type="${"number"}"${add_attribute("min", 0, 0)}${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.width) != null ? _b : "", 0)}>`;
      }
    })}
	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-height",
      label: "Height"
    }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-height"}" class="${"input"}" name="${"height"}" type="${"number"}"${add_attribute("min", 0, 0)}${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.height) != null ? _b : "", 0)}>`;
      }
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-x",
      label: "X Position"
    }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-x"}" class="${"input"}" name="${"x"}" type="${"number"}"${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.x) != null ? _b : "", 0)}>`;
      }
    })}
	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-y",
      label: "Y Position"
    }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-y"}" class="${"input"}" name="${"y"}" type="${"number"}"${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.y) != null ? _b : "", 0)}>`;
      }
    })}

	${validate_component(Field, "Field").$$render($$result, {
      htmlFor: "control-server",
      label: "Asset Server"
    }, {}, {
      default: () => {
        var _a2, _b;
        return `<input id="${"control-server"}" class="${"input"}" name="${"server"}" type="${"url"}"${add_attribute("value", (_b = (_a2 = selectedCell == null ? void 0 : selectedCell.info) == null ? void 0 : _a2.server) != null ? _b : "", 0)}>`;
      }
    })}

	<div class="${"field is-grouped is-grouped-right"}" style="${"margin-top: 3rem"}">${validate_component(SubmitButton, "SubmitButton").$$render($$result, { loading }, {}, {})}</div>`
  })}`;
});
var edit = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Edit,
  load: load$1
});
function socketStore(url, defaultValue) {
  {
    return readable(defaultValue);
  }
}
var ws = derived(socketStore("ws://localhost:3000", "{}"), (json) => JSON.parse(json));
function stateToUrl({ state, info } = {}) {
  switch (state === null || state === void 0 ? void 0 : state.type) {
    case CellStateType.WEB:
      return new URL(state.url, info === null || info === void 0 ? void 0 : info.server);
    default:
      return void 0;
  }
}
var Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let cellData;
  let href;
  let $ws, $$unsubscribe_ws;
  $$unsubscribe_ws = subscribe(ws, (value) => $ws = value);
  var _a, _b;
  let { serial } = $$props;
  let anchor;
  if ($$props.serial === void 0 && $$bindings.serial && serial !== void 0)
    $$bindings.serial(serial);
  cellData = $ws[serial];
  href = (_b = (_a = stateToUrl(cellData)) === null || _a === void 0 ? void 0 : _a.href) !== null && _b !== void 0 ? _b : "#";
  {
    {
      console.log(cellData);
    }
  }
  $$unsubscribe_ws();
  return `<a hidden${add_attribute("href", href, 0)}${add_attribute("this", anchor, 0)}>Refresh</a>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Page
});
function convert(range) {
  function fromTimeStamp(timestamp) {
    if (timestamp) {
      return Temporal.Instant.from(timestamp).toZonedDateTimeISO("UTC");
    } else {
      return void 0;
    }
  }
  return {
    start: fromTimeStamp(range.start),
    end: fromTimeStamp(range.end)
  };
}
function isBusy(time, ranges) {
  for (const range of ranges) {
    const { start, end } = range;
    if (start && Temporal.ZonedDateTime.compare(time, start) < 0) {
      return { busy: false, next: range.start };
    } else if (!end || Temporal.ZonedDateTime.compare(time, end) <= 0) {
      return { busy: true, next: range.end };
    } else {
      continue;
    }
  }
  return { busy: false, next: void 0 };
}
function isBusyInterval(ranges, callback) {
  const dateTimeRanges = ranges.map(convert);
  function checkBusy() {
    const now = Temporal.Now.zonedDateTimeISO("UTC");
    const { busy, next } = isBusy(now, dateTimeRanges);
    callback(busy);
    if (next) {
      const duration = now.until(next);
      console.log(`Waiting until ${duration}`);
      const ms = duration.total({ unit: "milliseconds" });
      setTimeout(checkBusy, Math.max(ms, 1e3));
    }
  }
  checkBusy();
}
var css$1 = {
  code: "body.svelte-8rd6l6{display:flex;flex-direction:column;justify-content:center}.profile.svelte-8rd6l6{display:block;border-radius:50%}",
  map: `{"version":3,"file":"[person].svelte","sources":["[person].svelte"],"sourcesContent":["<script lang=\\"ts\\" context=\\"module\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nimport { Temporal } from '@js-temporal/polyfill';\\nimport { isBusyInterval } from './_range';\\nconst people = {\\n    tiger: {\\n        name: 'Tiger',\\n        image: '/assets/img/tiger.jpg',\\n        calendar: 'tigeroakes@gmail.com'\\n    },\\n    daphne: {\\n        name: 'Daphne',\\n        image: '/assets/img/daphne.jpg',\\n        calendar: 'daphne.liu97@gmail.com'\\n    }\\n};\\nconst states = {\\n    free: {\\n        text: 'Free',\\n        background: '#262626'\\n    },\\n    busy: {\\n        text: 'Busy',\\n        background: '#d87220'\\n    }\\n};\\nfunction isPerson(person) {\\n    return person in people;\\n}\\nexport const load = ({ page }) => __awaiter(void 0, void 0, void 0, function* () {\\n    const { person } = page.params;\\n    if (!isPerson(person)) {\\n        return {\\n            status: 404,\\n            error: new Error(\`No matching data for \${person}\`)\\n        };\\n    }\\n    const today = Temporal.Now.zonedDateTimeISO('UTC').startOfDay();\\n    const nextWeek = today.add({ days: 5 });\\n    const toStringOptions = {\\n        timeZoneName: 'never',\\n        smallestUnit: 'second'\\n    };\\n    const body = {\\n        timeMin: today.toString(toStringOptions),\\n        timeMax: nextWeek.toString(toStringOptions),\\n        items: [{ id: people[person].calendar }]\\n    };\\n    const res = yield fetch('/api/third_party/freebusy', {\\n        method: 'post',\\n        headers: {\\n            'Content-Type': 'application/json'\\n        },\\n        body: JSON.stringify(body)\\n    });\\n    if (!res.ok) {\\n        return {\\n            status: res.status,\\n            error: new Error(\`Could not load calendar, \${res.statusText}\`)\\n        };\\n    }\\n    const busy = yield res.json();\\n    return {\\n        props: {\\n            name: person,\\n            busyRanges: busy\\n        }\\n    };\\n});\\n<\/script>\\n\\n<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nexport let busyRanges;\\nexport let name;\\n$: person = people[name];\\nlet stateName = 'free';\\n$: state = states[stateName];\\nisBusyInterval(busyRanges, (isBusy) => {\\n    stateName = isBusy ? 'busy' : 'free';\\n});\\n<\/script>\\n\\n<body style=\\"background: {state.background}\\">\\n\\t<img\\n\\t\\tclass=\\"profile\\"\\n\\t\\talt=\\"Portrait of \${person.name}\\"\\n\\t\\tsrc=\\"\${person.image}\\"\\n\\t\\twidth=\\"150\\"\\n\\t\\theight=\\"150\\"\\n\\t/>\\n\\t<h1 class=\\"headline-1\\">{state.text}</h1>\\n</body>\\n\\n<style>\\n\\tbody {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t}\\n\\t.profile {\\n\\t\\tdisplay: block;\\n\\t\\tborder-radius: 50%;\\n\\t}\\n</style>\\n"],"names":[],"mappings":"AA6GC,IAAI,cAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,QAAQ,cAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,aAAa,CAAE,GAAG,AACnB,CAAC"}`
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve22) {
      resolve22(value);
    });
  }
  return new (P || (P = Promise))(function(resolve22, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var people = {
  tiger: {
    name: "Tiger",
    image: "/assets/img/tiger.jpg",
    calendar: "tigeroakes@gmail.com"
  },
  daphne: {
    name: "Daphne",
    image: "/assets/img/daphne.jpg",
    calendar: "daphne.liu97@gmail.com"
  }
};
var states = {
  free: { text: "Free", background: "#262626" },
  busy: { text: "Busy", background: "#d87220" }
};
function isPerson(person) {
  return person in people;
}
var load = ({ page: page2 }) => __awaiter(void 0, void 0, void 0, function* () {
  const { person } = page2.params;
  if (!isPerson(person)) {
    return {
      status: 404,
      error: new Error(`No matching data for ${person}`)
    };
  }
  const today = Temporal.Now.zonedDateTimeISO("UTC").startOfDay();
  const nextWeek = today.add({ days: 5 });
  const toStringOptions = {
    timeZoneName: "never",
    smallestUnit: "second"
  };
  const body = {
    timeMin: today.toString(toStringOptions),
    timeMax: nextWeek.toString(toStringOptions),
    items: [{ id: people[person].calendar }]
  };
  const res = yield fetch("/api/third_party/freebusy", {
    method: "post",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  if (!res.ok) {
    return {
      status: res.status,
      error: new Error(`Could not load calendar, ${res.statusText}`)
    };
  }
  const busy = yield res.json();
  return {
    props: { name: person, busyRanges: busy }
  };
});
var U5Bpersonu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let person;
  let state;
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve22) {
        resolve22(value);
      });
    }
    return new (P || (P = Promise))(function(resolve22, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve22(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let { busyRanges } = $$props;
  let { name } = $$props;
  let stateName = "free";
  isBusyInterval(busyRanges, (isBusy2) => {
    stateName = isBusy2 ? "busy" : "free";
  });
  if ($$props.busyRanges === void 0 && $$bindings.busyRanges && busyRanges !== void 0)
    $$bindings.busyRanges(busyRanges);
  if ($$props.name === void 0 && $$bindings.name && name !== void 0)
    $$bindings.name(name);
  $$result.css.add(css$1);
  person = people[name];
  state = states[stateName];
  return `<body style="${"background: " + escape(state.background)}" class="${"svelte-8rd6l6"}"><img class="${"profile svelte-8rd6l6"}" alt="${"Portrait of $" + escape(person.name)}" src="${"$" + escape(person.image)}" width="${"150"}" height="${"150"}">
	<h1 class="${"headline-1"}">${escape(state.text)}</h1>
</body>`;
});
var _person_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bpersonu5D,
  load
});
var getStores = () => {
  const stores = getContext("__svelte__");
  return {
    page: {
      subscribe: stores.page.subscribe
    },
    navigating: {
      subscribe: stores.navigating.subscribe
    },
    get preloading() {
      console.error("stores.preloading is deprecated; use stores.navigating instead");
      return {
        subscribe: stores.navigating.subscribe
      };
    },
    session: stores.session
  };
};
var page = {
  subscribe(fn) {
    const store = getStores().page;
    return store.subscribe(fn);
  }
};
var css = {
  code: "main.svelte-12o3ebn{display:flex;height:100vh;align-items:center}h1.svelte-12o3ebn{margin:8px}",
  map: `{"version":3,"file":"text.svelte","sources":["text.svelte"],"sourcesContent":["<script lang=\\"ts\\" context=\\"module\\">export const router = false;\\nexport const prerender = true;\\n<\/script>\\n\\n<script lang=\\"ts\\">import { page } from '$app/stores';\\n$: text = $page.query.get('text') || 'CellWall';\\n$: backgroundColor = $page.query.get('backgroundColor') || '#429A46';\\n<\/script>\\n\\n<main style=\\"background: {backgroundColor};\\">\\n\\t<h1 class=\\"headline-1\\">{text}</h1>\\n</main>\\n\\n<style>\\n\\tmain {\\n\\t\\tdisplay: flex;\\n\\t\\theight: 100vh;\\n\\t\\talign-items: center;\\n\\t}\\n\\th1 {\\n\\t\\tmargin: 8px;\\n\\t}\\n</style>\\n"],"names":[],"mappings":"AAcC,IAAI,eAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,KAAK,CACb,WAAW,CAAE,MAAM,AACpB,CAAC,AACD,EAAE,eAAC,CAAC,AACH,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var router = false;
var prerender = true;
var Text = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let text2;
  let backgroundColor;
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  $$result.css.add(css);
  text2 = $page.query.get("text") || "CellWall";
  backgroundColor = $page.query.get("backgroundColor") || "#429A46";
  $$unsubscribe_page();
  return `<main style="${"background: " + escape(backgroundColor) + ";"}" class="${"svelte-12o3ebn"}"><h1 class="${"headline-1 svelte-12o3ebn"}">${escape(text2)}</h1>
</main>`;
});
var text = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Text,
  router,
  prerender
});

// .svelte-kit/node/middlewares.js
import {
  createReadStream,
  existsSync,
  statSync
} from "fs";
import fs__default, { readdirSync, statSync as statSync2 } from "fs";
import { resolve as resolve2, join, normalize as normalize2, dirname } from "path";
import {
  parse
} from "querystring";
import { fileURLToPath } from "url";
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
function create_kit_middleware({ render: render2 }) {
  return async (req, res) => {
    const parsed = new URL(req.url || "", "http://localhost");
    let body;
    try {
      body = await getRawBody(req);
    } catch (err) {
      res.statusCode = err.status || 400;
      return res.end(err.reason || "Invalid request body");
    }
    const rendered = await render2({
      method: req.method,
      headers: req.headers,
      path: parsed.pathname,
      query: parsed.searchParams,
      rawBody: body
    });
    if (rendered) {
      res.writeHead(rendered.status, rendered.headers);
      if (rendered.body) {
        res.write(rendered.body);
      }
      res.end();
    } else {
      res.statusCode = 404;
      res.end("Not found");
    }
  };
}
function parse2(req, toDecode) {
  let raw = req.url;
  if (raw == null)
    return;
  let prev = req._parsedUrl, encoded = !req._decoded;
  if (prev && prev.raw === raw && !toDecode === encoded)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = parse(search.substring(1));
      }
    }
    if (!!toDecode && encoded) {
      req._decoded = true;
      if (pathname.indexOf("%") !== -1) {
        try {
          pathname = decodeURIComponent(pathname);
        } catch (e) {
        }
      }
    }
  }
  return req._parsedUrl = { pathname, search, query, raw };
}
function list(dir, callback, pre = "") {
  dir = resolve2(".", dir);
  let arr = readdirSync(dir);
  let i = 0, abs, stats;
  for (; i < arr.length; i++) {
    abs = join(dir, arr[i]);
    stats = statSync2(abs);
    stats.isDirectory() ? list(abs, callback, join(pre, arr[i])) : callback(join(pre, arr[i]), abs, stats);
  }
}
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);
  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime.prototype.getType = function(path2) {
  path2 = String(path2);
  let last = path2.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path2.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma", "es"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/mrb-consumer+xml": ["*xdf"], "application/mrb-publish+xml": ["*xdf"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["*xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-error+xml": ["xer"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
var lite = new Mime_1(standard);
var noop2 = () => {
};
function isMatch(uri, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].test(uri))
      return true;
  }
}
function toAssume(uri, extns) {
  let i = 0, x, len = uri.length - 1;
  if (uri.charCodeAt(len) === 47) {
    uri = uri.substring(0, len);
  }
  let arr = [], tmp = `${uri}/index`;
  for (; i < extns.length; i++) {
    x = extns[i] ? `.${extns[i]}` : "";
    if (uri)
      arr.push(uri + x);
    arr.push(tmp + x);
  }
  return arr;
}
function viaCache(cache, uri, extns) {
  let i = 0, data, arr = toAssume(uri, extns);
  for (; i < arr.length; i++) {
    if (data = cache[arr[i]])
      return data;
  }
}
function viaLocal(dir, isEtag, uri, extns) {
  let i = 0, arr = toAssume(uri, extns);
  let abs, stats, name, headers;
  for (; i < arr.length; i++) {
    abs = normalize2(join(dir, name = arr[i]));
    if (abs.startsWith(dir) && existsSync(abs)) {
      stats = statSync(abs);
      if (stats.isDirectory())
        continue;
      headers = toHeaders(name, stats, isEtag);
      headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
      return { abs, stats, headers };
    }
  }
}
function is404(req, res) {
  return res.statusCode = 404, res.end();
}
function send(req, res, file, stats, headers) {
  let code = 200, tmp, opts = {};
  headers = __spreadValues({}, headers);
  for (let key in headers) {
    tmp = res.getHeader(key);
    if (tmp)
      headers[key] = tmp;
  }
  if (tmp = res.getHeader("content-type")) {
    headers["Content-Type"] = tmp;
  }
  if (req.headers.range) {
    code = 206;
    let [x, y] = req.headers.range.replace("bytes=", "").split("-");
    let end = opts.end = parseInt(y, 10) || stats.size - 1;
    let start = opts.start = parseInt(x, 10) || 0;
    if (start >= stats.size || end >= stats.size) {
      res.setHeader("Content-Range", `bytes */${stats.size}`);
      res.statusCode = 416;
      return res.end();
    }
    headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
    headers["Content-Length"] = end - start + 1;
    headers["Accept-Ranges"] = "bytes";
  }
  res.writeHead(code, headers);
  createReadStream(file, opts).pipe(res);
}
function isEncoding(name, type, headers) {
  headers["Content-Encoding"] = type;
  headers["Content-Type"] = lite.getType(name.replace(/\.([^.]*)$/, "")) || "";
}
function toHeaders(name, stats, isEtag) {
  let headers = {
    "Content-Length": stats.size,
    "Content-Type": lite.getType(name) || "",
    "Last-Modified": stats.mtime.toUTCString()
  };
  if (isEtag)
    headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
  if (/\.br$/.test(name))
    isEncoding(name, "br", headers);
  if (/\.gz$/.test(name))
    isEncoding(name, "gzip", headers);
  return headers;
}
function sirv(dir, opts = {}) {
  dir = resolve2(dir || ".");
  let isNotFound = opts.onNoMatch || is404;
  let setHeaders = opts.setHeaders || noop2;
  let extensions = opts.extensions || ["html", "htm"];
  let gzips = opts.gzip && extensions.map((x) => `${x}.gz`).concat("gz");
  let brots = opts.brotli && extensions.map((x) => `${x}.br`).concat("br");
  const FILES = {};
  let fallback = "/";
  let isEtag = !!opts.etag;
  let isSPA = !!opts.single;
  if (typeof opts.single === "string") {
    let idx = opts.single.lastIndexOf(".");
    fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
  }
  let ignores = [];
  if (opts.ignores !== false) {
    ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
    if (opts.dotfiles)
      ignores.push(/\/\.\w/);
    else
      ignores.push(/\/\.well-known/);
    [].concat(opts.ignores || []).forEach((x) => {
      ignores.push(new RegExp(x, "i"));
    });
  }
  let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
  if (cc && opts.immutable)
    cc += ",immutable";
  else if (cc && opts.maxAge === 0)
    cc += ",must-revalidate";
  if (!opts.dev) {
    list(dir, (name, abs, stats) => {
      if (/\.well-known[\\+\/]/.test(name))
        ;
      else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name))
        return;
      let headers = toHeaders(name, stats, isEtag);
      if (cc)
        headers["Cache-Control"] = cc;
      FILES["/" + name.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
    });
  }
  let lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
  return function(req, res, next) {
    let extns = [""];
    let val = req.headers["accept-encoding"] || "";
    if (gzips && val.includes("gzip"))
      extns.unshift(...gzips);
    if (brots && /(br|brotli)/i.test(val))
      extns.unshift(...brots);
    extns.push(...extensions);
    let pathname = !!req._decoded && req.path || parse2(req, true).pathname;
    let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
    if (!data)
      return next ? next() : isNotFound(req, res);
    if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
      res.writeHead(304);
      return res.end();
    }
    if (gzips || brots) {
      res.setHeader("Vary", "Accept-Encoding");
    }
    setHeaders(res, pathname, data.stats);
    send(req, res, data.abs, data.stats, data.headers);
  };
}
var __dirname2 = dirname(fileURLToPath(import.meta.url));
var noop_handler = (_req, _res, next) => next();
var paths = {
  assets: join(__dirname2, "/assets"),
  prerendered: join(__dirname2, "/prerendered")
};
var prerenderedMiddleware = fs__default.existsSync(paths.prerendered) ? sirv(paths.prerendered, {
  etag: true,
  maxAge: 0,
  gzip: true,
  brotli: true
}) : noop_handler;
var assetsMiddleware = fs__default.existsSync(paths.assets) ? sirv(paths.assets, {
  setHeaders: (res, pathname) => {
    if (pathname.startsWith("/_app/")) {
      res.setHeader("cache-control", "public, max-age=31536000, immutable");
    }
  },
  gzip: true,
  brotli: true
}) : noop_handler;
var kitMiddleware = function() {
  init();
  return create_kit_middleware({ render });
}();
export {
  assetsMiddleware,
  kitMiddleware,
  prerenderedMiddleware
};
/*!
 * Timm
 *
 * Immutability helpers with fast reads and acceptable writes.
 *
 * @copyright Guillermo Grau Panea 2016
 * @license MIT
 */
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */
